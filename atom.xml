<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Sample Site Posts</title><id>https://matsubara0507.github.io/scrapbook-example/atom.xml</id><updated>2018-07-09T00:00:00Z</updated><link href="https://matsubara0507.github.io/scrapbook-example"/><entry><id>https://haskell.e-bigmoon.com/posts/2018/07-09-quiz-11.html</id><title type="text">Haskell Quiz No.11 isUpper と isAsciiUpper</title><updated>2018-07-09T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/07-09-quiz-11.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.11"&gt;Haskell Quiz No.11&lt;/h2&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;以下のプログラムの実行結果はどうなるでしょうか？&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.17&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  print &lt;span class="fu"&gt;$&lt;/span&gt; isUpper &lt;span class="ch"&gt;&amp;#39;あ&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  print &lt;span class="fu"&gt;$&lt;/span&gt; isAsciiUpper &lt;span class="ch"&gt;&amp;#39;あ&amp;#39;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは次回。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./07-08-quiz-10.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;以下の実行結果はどうなるでしょう！&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.17&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; runConduit &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; iterMC print &lt;span class="fu"&gt;.|&lt;/span&gt; return ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;何も表示されない。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz10.hs&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;yieldMany&lt;/code&gt; 関数があるので &lt;code&gt;iterMC print&lt;/code&gt; によって &lt;code&gt;1 〜 10&lt;/code&gt; が表示されるように思うかもしれません。&lt;/p&gt;
&lt;p&gt;しかし、最後のパイプが &lt;code&gt;return ()&lt;/code&gt; となっているため、何も起きません。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Conduit は値が上流から自然に流れてくるのではなく、必要な時に下流から引っ張っているイメージで考えると良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/07-08-quiz-10.html</id><title type="text">Haskell Quiz No.10 Conduit Part.6</title><updated>2018-07-08T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/07-08-quiz-10.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.10"&gt;Haskell Quiz No.10&lt;/h2&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;以下の実行結果はどうなるでしょう！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.17&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; runConduit &lt;span class="fu"&gt;$&lt;/span&gt; yieldMany [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;.|&lt;/span&gt; iterMC print &lt;span class="fu"&gt;.|&lt;/span&gt; return ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは&lt;a href="./07-09-quiz-11.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./07-06-quiz-9.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の2つのコードのうち、1つめはコンパイルできますが、2つめはコンパイルできません。&lt;/p&gt;
&lt;p&gt;なぜでしょう！&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.16&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; return () &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.16&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;  mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;  sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;エラーメッセージ&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;error:
    • No instance for (Num ()) arising from the literal ‘1’
    • In the expression: 1
      In the second argument of ‘mapM_’, namely ‘[1 .. 10]’
      In a stmt of a &amp;#39;do&amp;#39; block: mapM_ leftover [1 .. 10]

    mapM_ leftover [1..10]&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;先に2つ目の例がエラーとなってしまう理由を確認します。&lt;/p&gt;
&lt;p&gt;まずは関数の型を確認しておきましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;runConduitPure ::&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="ot"&gt;leftover ::&lt;/span&gt; i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="ot"&gt;sinkList ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; a o m [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;mapM_&lt;span class="ot"&gt; ::&lt;/span&gt; (&lt;span class="dt"&gt;Foldable&lt;/span&gt; t, &lt;span class="dt"&gt;Monad&lt;/span&gt; m) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; t a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;mapM_&lt;span class="ot"&gt; leftover ::&lt;/span&gt; t i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;span class="ot"&gt; ::&lt;/span&gt; (&lt;span class="dt"&gt;Enum&lt;/span&gt; i, &lt;span class="dt"&gt;Num&lt;/span&gt; i) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次にモナドの型クラスも一応確認しておきます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Applicative&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; (&lt;span class="ot"&gt;m ::&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;*&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  return ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="ot"&gt;  (&amp;gt;&amp;gt;=)  ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  (&amp;gt;&amp;gt;)   ::&lt;/span&gt; m a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m b&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さらに型を確認していきます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; (&lt;span class="dt"&gt;Monad&lt;/span&gt; m, &lt;span class="dt"&gt;Enum&lt;/span&gt; i, &lt;span class="dt"&gt;Num&lt;/span&gt; i) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m [i]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて、ここまで確認するとなぜ2つ目の結果がエラーとなることがわかります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;runConduitPure ::&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; (&lt;span class="dt"&gt;Monad&lt;/span&gt; m, &lt;span class="dt"&gt;Enum&lt;/span&gt; i, &lt;span class="dt"&gt;Num&lt;/span&gt; i) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m [i]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ConduitT&lt;/code&gt; のパラメータはそれぞれ以下のような具体的な型になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; = &lt;code&gt;()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; = &lt;code&gt;Void&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; = &lt;code&gt;Identity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; = &lt;code&gt;[i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さらに &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;i&lt;/code&gt; にはクラス制約があるため以下のインスタンス定義が要求されます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;instance Monad Identity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance Enum ()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instance Num ()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここで &lt;a href="https://www.stackage.org/haddock/lts-11.17/base-4.10.1.0/Prelude.html#t:Num"&gt;Num&lt;/a&gt; クラスのインスタンス定義には &lt;code&gt;()&lt;/code&gt; が含まれないため、エラーとなってしまいました。&lt;/p&gt;
&lt;h4 id="つ目の例がエラーにならない理由"&gt;１つ目の例がエラーにならない理由&lt;/h4&gt;
&lt;p&gt;ではなぜ &lt;code&gt;return () .|&lt;/code&gt; が追加されるとエラーにならないのでしょうか？&lt;/p&gt;
&lt;p&gt;型を確認してみます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;(.|)   ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; a b m () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; b c m r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; a c m r&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;return&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;return&lt;span class="ot"&gt; ()      ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;(return () &lt;span class="fu"&gt;.|&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; o c m r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i c m r&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; sinkList&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; (&lt;span class="dt"&gt;Monad&lt;/span&gt; m, &lt;span class="dt"&gt;Enum&lt;/span&gt; i, &lt;span class="dt"&gt;Num&lt;/span&gt; i) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m [i]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;(return () &lt;span class="fu"&gt;.|&lt;/span&gt; mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; sinkList)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;span class="ot"&gt;  ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m [i]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2つ目の例では &lt;code&gt;runConduitPure&lt;/code&gt; に直接適用してしまったため、型クラス制約が必要になりましたが、今回は &lt;code&gt;return ()&lt;/code&gt; と合成した結果を &lt;code&gt;runConduitPure&lt;/code&gt; に適用するため、この問題を回避することができています。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;runConduitPure&lt;/code&gt; に適用する時に今回のようなエラーが出てしまう場合は &lt;code&gt;return () .|&lt;/code&gt; として合成してから適用すると良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/07-06-quiz-9.html</id><title type="text">Haskell Quiz No.9 Conduit Part.5</title><updated>2018-07-06T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/07-06-quiz-9.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.9"&gt;Haskell Quiz No.9&lt;/h2&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下の2つのコードのうち、1つめはコンパイルできますが、2つめはコンパイルできません。&lt;/p&gt;
&lt;p&gt;なぜでしょう！&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.16&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; return () &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.16&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;  sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;エラーメッセージ&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;error:
    • No instance for (Num ()) arising from the literal ‘1’
    • In the expression: 1
      In the second argument of ‘mapM_’, namely ‘[1 .. 10]’
      In a stmt of a &amp;#39;do&amp;#39; block: mapM_ leftover [1 .. 10]

    mapM_ leftover [1..10]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答えは&lt;a href="./07-08-quiz-10.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./04-08-quiz-8.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λλλ&lt;/p&gt;
&lt;p&gt;以下の &lt;code&gt;Conduit&lt;/code&gt; を使ったコードの実行結果を予想してみてください！&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; return () &lt;span class="fu"&gt;.|&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;  mapM_ leftover [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;  sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;実際に実行してみましょう！&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Quiz8.hs
[10,9,8,7,6,5,4,3,2,1]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;leftover&lt;/code&gt; に &lt;code&gt;[1..10]&lt;/code&gt; を与えたのに、なぜか逆順になってしまいましたね。&lt;/p&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;この問題で抑えておきたいポイントは &lt;code&gt;leftover&lt;/code&gt; の動作についてです。&lt;/p&gt;
&lt;p&gt;問題の例を上記のように &lt;code&gt;leftover&lt;/code&gt; ではなく &lt;code&gt;sourceList&lt;/code&gt; を使うように修正した場合、プログラムの実行結果は次のようになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Conduit.List&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; sourceList [(&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt;::&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;                             &lt;span class="fu"&gt;.|&lt;/span&gt; sinkList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;[1,2,3,4,5,6,7,8,9,10]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;入力として与えたリストの順番がきちんと保存されています。&lt;/p&gt;
&lt;p&gt;この挙動を理解するためには &lt;code&gt;Conduit&lt;/code&gt; の内部をちょっとだけみていく必要があります。&lt;/p&gt;
&lt;h4 id="定義の確認"&gt;定義の確認&lt;/h4&gt;
&lt;p&gt;まずは &lt;code&gt;sourceList&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;leftover&lt;/code&gt; の定義を確認してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;sourceList ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i a m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;sourceList &lt;span class="fu"&gt;=&lt;/span&gt; Prelude.mapM_ yield&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="ot"&gt;yield ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; o &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;yield    o &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; \rest &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;HaveOutput&lt;/span&gt; (rest ()) o&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;leftover ::&lt;/span&gt; i &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i o m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;leftover i &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; \rest &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Leftover&lt;/span&gt;   (rest ()) i&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;yeld&lt;/code&gt; と &lt;code&gt;leftover&lt;/code&gt; はほとんど同じ関数です。本質的に異なる点は &lt;code&gt;HaveOutput&lt;/code&gt; と &lt;code&gt;Leftover&lt;/code&gt; という構成子の違いだけです。&lt;/p&gt;
&lt;p&gt;しかし、この違いが今回のような違いを生み出します。&lt;/p&gt;
&lt;p&gt;次に、&lt;code&gt;runConduitPure&lt;/code&gt; 関数の定義を確認します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;runConduitPure ::&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;runConduitPure &lt;span class="fu"&gt;=&lt;/span&gt; runIdentity &lt;span class="fu"&gt;.&lt;/span&gt; runConduit&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="ot"&gt;runConduit ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; () &lt;span class="dt"&gt;Void&lt;/span&gt; m r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m r&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;runConduit (&lt;span class="dt"&gt;ConduitT&lt;/span&gt; p) &lt;span class="fu"&gt;=&lt;/span&gt; runPipe &lt;span class="fu"&gt;$&lt;/span&gt; injectLeftovers &lt;span class="fu"&gt;$&lt;/span&gt; p &lt;span class="dt"&gt;Done&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;injectLeftovers&lt;/code&gt; が今回の問題で一番重要な関数です。&lt;/p&gt;
&lt;h4 id="injectleftovers-関数"&gt;injectLeftovers 関数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;injectLeftovers&lt;/code&gt; 関数の定義は以下のとおりです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;injectLeftovers ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i i o u m r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; l i o u m r&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;injectLeftovers &lt;span class="fu"&gt;=&lt;/span&gt; go []&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;    go ls (&lt;span class="dt"&gt;HaveOutput&lt;/span&gt; p o) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;HaveOutput&lt;/span&gt; (go ls p) o&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;    go (l&lt;span class="fu"&gt;:&lt;/span&gt;ls) (&lt;span class="dt"&gt;NeedInput&lt;/span&gt; p _) &lt;span class="fu"&gt;=&lt;/span&gt; go ls &lt;span class="fu"&gt;$&lt;/span&gt; p l&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;    go [] (&lt;span class="dt"&gt;NeedInput&lt;/span&gt; p c) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;NeedInput&lt;/span&gt; (go [] &lt;span class="fu"&gt;.&lt;/span&gt; p) (go [] &lt;span class="fu"&gt;.&lt;/span&gt; c)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;    go _ (&lt;span class="dt"&gt;Done&lt;/span&gt; r) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Done&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;    go ls (&lt;span class="dt"&gt;PipeM&lt;/span&gt; mp) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PipeM&lt;/span&gt; (liftM (go ls) mp)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;    go ls (&lt;span class="dt"&gt;Leftover&lt;/span&gt; p l) &lt;span class="fu"&gt;=&lt;/span&gt; go (l&lt;span class="fu"&gt;:&lt;/span&gt;ls) p&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;go&lt;/code&gt; が少しごちゃごちゃしていますが、実際に着目すべきポイントは以下の行です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;injectLeftovers ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; i i o u m r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Pipe&lt;/span&gt; l i o u m r&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;injectLeftovers &lt;span class="fu"&gt;=&lt;/span&gt; go []&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  　&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;    go ls (&lt;span class="dt"&gt;Leftover&lt;/span&gt; p l) &lt;span class="fu"&gt;=&lt;/span&gt; go (l&lt;span class="fu"&gt;:&lt;/span&gt;ls) p&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;go&lt;/code&gt; 関数の第一引数の &lt;code&gt;ls&lt;/code&gt; は &lt;code&gt;leftover&lt;/code&gt; によって上流に戻される値を保存しておくための蓄積変数です。&lt;/p&gt;
&lt;p&gt;ここで &lt;code&gt;mapM_ leftover [1..10]&lt;/code&gt; はこんなような形をしているパイプです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;p &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Leftover&lt;/span&gt; (&lt;span class="dt"&gt;Leftover&lt;/span&gt; (&lt;span class="dt"&gt;Leftover&lt;/span&gt; nextPipe &lt;span class="dv"&gt;3&lt;/span&gt;) &lt;span class="dv"&gt;2&lt;/span&gt;) &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mapM_ leftover [1..10]&lt;/code&gt; のときに、&lt;code&gt;ls&lt;/code&gt; が逆順になっていることを確認するため、実際に &lt;code&gt;go&lt;/code&gt; 関数を簡約してみます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;go [] p&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; go [] (&lt;span class="dt"&gt;Leftover&lt;/span&gt; (&lt;span class="dt"&gt;Leftover&lt;/span&gt; (&lt;span class="dt"&gt;Leftover&lt;/span&gt; p &lt;span class="dv"&gt;3&lt;/span&gt;) &lt;span class="dv"&gt;2&lt;/span&gt;) &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; go (&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;[]) (&lt;span class="dt"&gt;Leftover&lt;/span&gt; (&lt;span class="dt"&gt;Leftover&lt;/span&gt; p &lt;span class="dv"&gt;3&lt;/span&gt;) &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; go (&lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;[])) (&lt;span class="dt"&gt;Leftover&lt;/span&gt; p &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; go (&lt;span class="dv"&gt;3&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;(&lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;[]))) p&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで &lt;code&gt;leftover&lt;/code&gt; した値が逆順で蓄積され、次のパイプに渡されることになります。&lt;/p&gt;
&lt;p&gt;今回の例では、次のパイプは &lt;code&gt;sinkList&lt;/code&gt; となっていました。実装は次のようになっています。&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;sinkList ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; a o m [a]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;sinkList &lt;span class="fu"&gt;=&lt;/span&gt; loop id&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;    loop front &lt;span class="fu"&gt;=&lt;/span&gt; await &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; maybe (return &lt;span class="fu"&gt;$&lt;/span&gt; front []) (\x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; loop &lt;span class="fu"&gt;$&lt;/span&gt; front &lt;span class="fu"&gt;.&lt;/span&gt; (x&lt;span class="fu"&gt;:&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;&lt;span class="ot"&gt;await ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Consumer&lt;/span&gt; i m (&lt;span class="dt"&gt;Maybe&lt;/span&gt; i)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;await &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; \f &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;NeedInput&lt;/span&gt; (f &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt;) (const &lt;span class="fu"&gt;$&lt;/span&gt; f &lt;span class="dt"&gt;Nothing&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; は &lt;code&gt;NeedInput&lt;/code&gt; になっていますね。&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;injectLeftovers&lt;/code&gt; の &lt;code&gt;go&lt;/code&gt; ではこのようにパターンマッチしていました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;go (l&lt;span class="fu"&gt;:&lt;/span&gt;ls) (&lt;span class="dt"&gt;NeedInput&lt;/span&gt; p _) &lt;span class="fu"&gt;=&lt;/span&gt; go ls &lt;span class="fu"&gt;$&lt;/span&gt; p l&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;go [] (&lt;span class="dt"&gt;NeedInput&lt;/span&gt; p c) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;NeedInput&lt;/span&gt; (go [] &lt;span class="fu"&gt;.&lt;/span&gt; p) (go [] &lt;span class="fu"&gt;.&lt;/span&gt; c)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;つまり、先に &lt;code&gt;leftover&lt;/code&gt; で積んだ値を全て消費してから、上流に対して値を要求します。&lt;/p&gt;
&lt;h2 id="おわりに"&gt;おわりに&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;leftover&lt;/code&gt; を使えば任意の値を上流に返すことができる。(実際には消費した値を返すことが多いと思う)&lt;/li&gt;
&lt;li&gt;値を1つだけ上流に返す場合は特に気にすることは無い&lt;/li&gt;
&lt;li&gt;一度にまとめて複数の値を返そうとすると、処理の順番が変わってしまうことがあるので注意が必要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html</id><title type="text">Ruby Hack Challenge ＃4 に参加してきた</title><updated>2018-07-01T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Ruby Hack Challenge ＃4 に参加してきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-07-01" itemprop="datePublished"&gt;
        Jul 1, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Ruby.html"&gt;Ruby&lt;/a&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先週 &lt;a href="https://cookpad.connpass.com/event/88471/"&gt;Ruby Hack Cavalage #4&lt;/a&gt; に参加してきたので，そのメモ書きです．&lt;/p&gt;
&lt;p&gt;ちなみに，Ruby は自分が最初に触ったスクリプト言語で，現在仕事で使っているメインの言語です． 推し言語(Haskell)とは異なり，動的型付けではありますが，「&lt;a href="http://i.loveruby.net/ja/rhg/book/"&gt;Rubyソースコード完全解説&lt;/a&gt;」や「&lt;a href="https://tatsu-zine.com/books/ruby-under-a-microscope-ja"&gt;Rubyのしくみ&lt;/a&gt;」のような処理系内部を紹介してる読み物も多く，かなり好きな方な言語です.&lt;/p&gt;
&lt;h2 id="ruby-hack-challenge"&gt;Ruby Hack Challenge&lt;/h2&gt;
&lt;p&gt;Ruby 処理系をハックしようというイベントで，コアコミッタの &lt;a href="https://github.com/mame"&gt;mame&lt;/a&gt; 氏と &lt;a href="https://github.com/ko1"&gt;ko1&lt;/a&gt; 氏が講師として企画してくれている． ふたりが在籍しているということで，会場はクックパッドで行っている．&lt;/p&gt;
&lt;p&gt;毎回，前半に講義的なものがあり，後半で実際に手を動かして Ruby にコミットするといった感じらしい． ただし，2日開催だったり，半日だったり時間はまちまち(今回は半日だった)． イベント名的に Ruby のハッカソンみたいだが，Ruby 処理系はC言語で書かれているためC言語を書くことになる(笑)&lt;/p&gt;
&lt;h3 id="カバレッジ特別会"&gt;カバレッジ特別会&lt;/h3&gt;
&lt;p&gt;しかし，4回目(となっているが3回目が見当たらないので3回目かも？？)となる今回は，カバレッジ特別会ということで多くの人たちが Ruby を読み書きしていた． なぜかというと，標準ライブラリは Ruby で書かれており，今回は標準ライブラリのテストカバレッジをあげても良かったからだ． というか，C で書かれているコア部分は mame 氏が昔に大分カバレッジをあげてしまったため，そっちをやるのは難しいと言っていた．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;C言語の部分で残っているとすれば本質的に難しい部分(副作用とか並行並列とか)か最近追加された部分か(JITとか？)だそうだ．&lt;/p&gt;
&lt;h3 id="資料"&gt;資料&lt;/h3&gt;
&lt;p&gt;今までのも含め，資料は(いくつか？)公開されているので誰でも見れる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ko1/rubyhackchallenge"&gt;ko1/rubyhackchallenge - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.slideshare.net/mametter/ruby-hack-challenge-4"&gt;Ruby Hack Challenge #4 カバレッジ特別回 資料 - SlideShare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また Gitter で連絡を取り合っており，実は誰でも参加できる(たぶん)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitter.im/rubyhackchallenge/Lobby"&gt;rubyhackchallenge/Lobby - Gitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，ボクはもともとこのイベントは参加したいなぁと思っていた(言語好きなので)．&lt;/p&gt;
&lt;h2 id="ruby-のテストカバレッジ"&gt;Ruby のテストカバレッジ&lt;/h2&gt;
&lt;p&gt;Ruby のテストカバレッジは Web から確認できる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://rubyci.s3.amazonaws.com/debian8-coverage/ruby-trunk/lcov/index.html"&gt;LCOV - code coverage report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを見てカバレッジの低いところにねらい目を付けてテストを追加する(ないしは不要な実装なら削る)． 標準ライブラリのいくつかは個別に GitHub で管理されているので，GitHub で管理されてる場合はそっちに PR を投げれば良いようだ(今回は事情が共有されてたせいかすぐマージされた)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;a href="https://github.com/ruby/ruby/blob/trunk/doc/maintainers.rdoc"&gt;ココ&lt;/a&gt;を見ると誰がメンテナーで，どこに報告すれば良いかが書いてある．&lt;/p&gt;
&lt;h3 id="環境構築"&gt;環境構築&lt;/h3&gt;
&lt;p&gt;は事前にやっとくと，当日はすんなりコミットできた(構築方法はスライドに書いてある)． 事前にって言ってもぼくは行きの電車でやったけど(笑)&lt;/p&gt;
&lt;p&gt;Windows と Mac を持ってるけど，どっちも素でやるのは難しいので，Debian の Docker コンテナの上で構築した． Docker ありがとう！ ビルドがめっちゃ遅いけどね！&lt;/p&gt;
&lt;h2 id="当日やったこと"&gt;当日やったこと&lt;/h2&gt;
&lt;p&gt;すっっっごい簡単にカバレッジをあげれそうなのがあったのサクッと直して PR をだした．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ruby/cmath/pull/2"&gt;Add test for coverage by matsubara0507 · Pull Request #2 · ruby/cmath&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CMath&lt;/code&gt; モジュールは &lt;code&gt;Math&lt;/code&gt; モジュールをラップして複素数(Complex number)にまで対応させたものだ． そのため，虚数を含む複素数に関するテストしかなく，実数に関するテストが無かったためカバレッジが低かった． 愚直に全部書いたら100%まで行きましたちゃんちゃんってだけです．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，他にも4,5個ほど PR が出ていた． すごいね！&lt;/p&gt;
&lt;h2 id="もくもく会"&gt;もくもく会&lt;/h2&gt;
&lt;p&gt;あと，Ruby Hack Challenge もくもく会というのがあるらしいので行ってみたい(&lt;a href="https://connpass.com/event/93131/"&gt;次回はこれ&lt;/a&gt;)． MJIT のコードとか読んでみたいよね． それと型検査(はどうなるかまだ分からないらしいけど)．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;そういえば，ko1 氏がお子さんと奥さんを連れてきていた(たぶん)． そういう事に理解のある会社っていいなぁと感じた．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html</id><title type="text">namespaced templates</title><updated>2018-06-27T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;つい先日 &lt;a href="https://github.com/commercialhaskell/stack/pull/4103"&gt;namespaced templates&lt;/a&gt; という、PRが &lt;strong&gt;master&lt;/strong&gt; にマージされました。(&lt;a href="https://github.com/commercialhaskell/stack/issues/4039"&gt;Namespaced templates #4039&lt;/a&gt; が該当する isssue です)&lt;/p&gt;
&lt;p&gt;通常、&lt;strong&gt;stack new&lt;/strong&gt; コマンドを実行すると、ローカルに保存されている &lt;a href="https://github.com/commercialhaskell/stack-templates/blob/master/new-template.hsfiles"&gt;new-template&lt;/a&gt; の内容に基づいてプロジェクトの雛形が作成されます。&lt;/p&gt;
&lt;p&gt;もし、ローカルに保存されているテンプレートの内容を確認したい場合は以下のようなコマンドを実行すれば良いでしょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ cat $(stack path --stack-root)/templates/new-template.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;config.yaml&lt;/strong&gt; を変更すれば、このデフォルトテンプレートを変更することもできます。(詳しくは &lt;a href="https://haskell.e-bigmoon.com/stack/tips/config-yaml.html"&gt;config.yaml のよくある設定&lt;/a&gt; をご確認ください)&lt;/p&gt;
&lt;p&gt;今回新たに実装された namespaced templates 機能は、これらのテンプレート機能をより強化するものとなっています。&lt;/p&gt;
&lt;p&gt;具体的には &lt;strong&gt;username/foo&lt;/strong&gt; という形式でリモートリポジトリから自分のプロジェクトテンプレートをダウンロードし、それをもとにプロジェクトを作成できるようになります。&lt;/p&gt;
&lt;p&gt;それでは使い方を見ていきたいと思います。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack --version
Version 1.8.0, Git revision 466da22ce21cddc20323fc2611cd2a2d3cc56ec6 (dirty) (5998 commits) x86_64 hpack-0.28.2&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h2 id="リポジトリを用意しよう"&gt;リポジトリを用意しよう！&lt;/h2&gt;
&lt;p&gt;namespaced templates 機能は以下のサービスで利用可能です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;li&gt;gitlab&lt;/li&gt;
&lt;li&gt;bitbucket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まずは、&lt;strong&gt;stack-templates&lt;/strong&gt; という名前でリポジトリを作っておいてください。(今のところは任意の名前に変更する方法はありません。)&lt;/p&gt;
&lt;p&gt;この名前のリポジトリに存在するテンプレートファイルを参照することができます。&lt;/p&gt;
&lt;h2 id="テンプレートファイルを作ってみよう"&gt;テンプレートファイルを作ってみよう！&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートの参考になるのは &lt;a href="https://github.com/commercialhaskell/stack-templates/blob/master/simple.hsfiles"&gt;commercialhaskell/simple.hsfiles&lt;/a&gt; です。&lt;/li&gt;
&lt;li&gt;テンプレートエンジンは &lt;a href="https://mustache.github.io/mustache.1.html"&gt;mustache&lt;/a&gt; を使っているそうです。&lt;/li&gt;
&lt;li&gt;今から作るテンプレートファイルは &lt;a href="https://github.com/e-bigmoon/stack-templates/blob/master/sample.hsfiles"&gt;e-bigmoon/sample.hsfiles&lt;/a&gt; にあります。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="最小のプロジェクトテンプレート"&gt;最小のプロジェクトテンプレート&lt;/h3&gt;
&lt;p&gt;とりあえず &lt;strong&gt;Readme.md&lt;/strong&gt; ぐらいは欲しいですよね。&lt;/p&gt;
&lt;pre class="mastache"&gt;&lt;code&gt;{-# START_FILE README.md #-}
# {{name}}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{-# START_FILE README.md #-}&lt;/code&gt; はそれ以降に続く内容で &lt;strong&gt;README.md&lt;/strong&gt; というファイルを作ります ｰ &lt;code&gt;{{name}}&lt;/code&gt; には、&lt;strong&gt;stack new&lt;/strong&gt; の引数で与えたプロジェクト名が挿入されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまでで実際に動かして確認してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ cd /tmp
$ stack new test-proj e-bigmoon/sample
Downloading template &amp;quot;e-bigmoon/sample&amp;quot; to create project &amp;quot;test-proj&amp;quot; in test-proj/ ...
The template &amp;quot;e-bigmoon/sample&amp;quot; is invalid and could not be used. The error was: Template does not contain a .cabal or package.yaml file&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;怒られました。どうやら &lt;strong&gt;cabal&lt;/strong&gt; ファイルか &lt;strong&gt;package.yaml&lt;/strong&gt; が含まれている必要があるみたいです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;package.yaml&lt;/strong&gt; ファイルも追加して作成するために、少し編集しましょう。&lt;/p&gt;
&lt;pre class="mastache"&gt;&lt;code&gt;{-# START_FILE README.md #-}
# {{name}}

{-# START_FILE package.yaml #-}
name: {{name}}
dependencies:
  - base
library: {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もう一度実行してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj e-bigmoon/sample
...
All done.

$ tree test-proj/
test-proj/
├── package.yaml
├── README.md
├── stack.yaml
└── test-proj.cabal&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今度は成功しました。簡単でいいですね。&lt;/p&gt;
&lt;p&gt;ダウンロードしたテンプレートファイルは &lt;code&gt;~/.stack/templates/&amp;lt;username&amp;gt;/&amp;lt;template&amp;gt;&lt;/code&gt; というパスで保存されています。&lt;/p&gt;
&lt;h2 id="stack-new-コマンド"&gt;stack new コマンド&lt;/h2&gt;
&lt;p&gt;先程は github リポジトリ上のテンプレートファイルを取得したので以下のコマンドを実行しました。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj e-bigmoon/sample&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコマンドは次のコマンドの省略形です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj github:e-bigmoon/sample.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;そのため gitlab や bitbucket にあるテンプレートファイルをダウンロードする場合は以下のようになります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;# gitlab
$ stack new test-proj gitlab:e-bigmoon/sample.hsfiles

# bitbucket
$ stack new test-proj bitbucket:e-bigmoon/sample.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、テンプレート名を省略した場合は公式のテンプレートが利用されるため、次のコマンドを実行していることと同じです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj commercialhaskell/new-template&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完全なURLで別のサーバーにあるテンプレートファイルを指定することも可能です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj https://my-site.com/content/template9.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;github のテンプレートファイルを完全なURLで指定する際、上記のURLは invalid なので注意。ちゃんと raw の URL を指定しましょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;# NG
$ stack new test-proj https://github.com/commercialhaskell/stack-templates/blob/master/hspec.hsfiles

# OK
$ stack new test-proj https://raw.githubusercontent.com/commercialhaskell/stack-templates/master/new-template.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="stack.yaml-が含まれる場合"&gt;stack.yaml が含まれる場合&lt;/h2&gt;
&lt;p&gt;プロジェクトテンプレートに &lt;strong&gt;stack.yaml&lt;/strong&gt; が含まれる場合は初期化処理がスキップされます。(&lt;a href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html"&gt;v1.7.1&lt;/a&gt; で導入された修正ですね)&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new test-proj e-bigmoon/sample
Downloading template &amp;quot;e-bigmoon/sample&amp;quot; to create project &amp;quot;test-proj&amp;quot; in test-proj/ ...
Initialized empty Git repository in /tmp/test-proj/.git/&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="もっと複雑なテンプレート"&gt;もっと複雑なテンプレート&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;~/.stack/config.yaml&lt;/code&gt; に変数を定義しておき、プロジェクトテンプレートから参照することもできます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;config.yaml&lt;/strong&gt; ファイルの内容が以下のようになっているとしましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="fu"&gt;templates:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;params:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;author-email:&lt;/span&gt;&lt;span class="at"&gt; chrisdone@gmail.com&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;author-name:&lt;/span&gt;&lt;span class="at"&gt; Chris Done&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;copyright:&lt;/span&gt;&lt;span class="at"&gt; 2018 Chris Done&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;    &lt;span class="fu"&gt;github-username:&lt;/span&gt;&lt;span class="at"&gt; chrisdone&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;category:&lt;/span&gt;&lt;span class="at"&gt; Development&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;テンプレートファイル内から単純に &lt;code&gt;{{author-email}}&lt;/code&gt; の形式で変数を展開できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{-# START_FILE {{name}}.cabal #-}
name:                {{name}}
version:             0.1.0.0
-- synopsis:
-- description:
homepage:            https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme
license:             BSD3
license-file:        LICENSE
author:              {{author-name}}{{^author-name}}Author name here{{/author-name}}
maintainer:          {{author-email}}{{^author-email}}example@example.com{{/author-email}}
copyright:           {{copyright}}{{^copyright}}{{year}}{{^year}}2018{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}
category:            {{category}}{{^category}}Web{{/category}}&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今までも自分で作ったプロジェクトテンプレートを使うことはできましたが、&lt;strong&gt;new-template&lt;/strong&gt; を置き換えるか &lt;strong&gt;config.yml&lt;/strong&gt; を設定する必要がありました。&lt;/p&gt;
&lt;p&gt;今回の機能追加により、&lt;strong&gt;stack new&lt;/strong&gt; コマンドで直接プロジェクトテンプレートを簡単に指定できるため、自作テンプレート作りがはかどりそうです。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html</id><title type="text">ContT を使ってコードを綺麗にしよう！</title><updated>2018-06-26T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;Continuation (継続) について全く勉強したことが無いので &lt;a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html"&gt;Control.Monad.Cont&lt;/a&gt; で定義されている ContT とかいつ使うんだろうなーと思っていましたが、ついに利用機会がありました！！！&lt;/p&gt;
&lt;p&gt;僕が考えたんじゃなくて fumieval さんに相談して、教えてもらったんですけどね。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="問題のコード"&gt;問題のコード&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Yesod&lt;/strong&gt; の &lt;strong&gt;Handler&lt;/strong&gt; ではパラメータの取得するために &lt;a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupGetParam"&gt;lookupGetParam&lt;/a&gt; や &lt;a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupPostParam"&gt;lookupPostParam&lt;/a&gt; を利用すると思います。&lt;/p&gt;
&lt;p&gt;実際にはこんな感じでパラメータを取得していくつか処理を行います。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;deleteTestR ::&lt;/span&gt; &lt;span class="dt"&gt;Handler&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;deleteTestR &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  mParam &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lookupPostParam &lt;span class="st"&gt;&amp;quot;key&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;case&lt;/span&gt; mParam &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;    &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;パラメータが不正です。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;    &lt;span class="dt"&gt;Just&lt;/span&gt; param &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;      &lt;span class="kw"&gt;case&lt;/span&gt; textToSqlKey param &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;キーが見つかりませんでした。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; key &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;          mRecord &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; runDB &lt;span class="fu"&gt;$&lt;/span&gt; get key&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;          &lt;span class="kw"&gt;case&lt;/span&gt; mRecord &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;            &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;削除対象のデータが見つかりませんでした。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;            &lt;span class="dt"&gt;Just&lt;/span&gt; _  &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;success&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このコード、どう考えても嫌な感じですよね・・・。ネストやばいし。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;do&lt;/strong&gt; で書くと &lt;strong&gt;Maybe&lt;/strong&gt; 型なので値を返せないし、ベースに &lt;strong&gt;Handler&lt;/strong&gt; モナドがあるので &lt;strong&gt;Either&lt;/strong&gt; で置き換えるのも良くわかんないな・・・。と思って、結構放置してました。&lt;/p&gt;
&lt;h2 id="contt-を使ってリファクタリング"&gt;ContT を使ってリファクタリング！&lt;/h2&gt;
&lt;p&gt;先程のプログラムを &lt;a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html#t:ContT"&gt;ContT&lt;/a&gt; で置き換えるとこうなります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;deleteTestR ::&lt;/span&gt; &lt;span class="dt"&gt;Handler&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;deleteTestR &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;  mParam &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lookupPostParam &lt;span class="st"&gt;&amp;quot;key&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;  evalContT &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;    param &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mParam &lt;span class="fu"&gt;!?&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;パラメータが不正です。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;    key &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; textToSqlKey param &lt;span class="fu"&gt;!?&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;キーが見つかりませんでした。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;    mRecord &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lift &lt;span class="fu"&gt;$&lt;/span&gt; runDB &lt;span class="fu"&gt;$&lt;/span&gt; get key&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;    deletedBrand &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mRecord &lt;span class="fu"&gt;!?&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;削除対象のデータが見つかりませんでした。&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;    lift &lt;span class="fu"&gt;$&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;success&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;    &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="fu"&gt;!?&lt;/span&gt; e &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ContT&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; const &lt;span class="fu"&gt;$&lt;/span&gt; returnJson &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; e&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;    &lt;span class="dt"&gt;Just&lt;/span&gt; a  &lt;span class="fu"&gt;!?&lt;/span&gt; _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ContT&lt;/span&gt; (&lt;span class="fu"&gt;$&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感動しましたね。継続すごいな！って。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;継続勉強しよ。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/06-25-All-About-Strictness.html</id><title type="text">正格性のすべて (翻訳)</title><updated>2018-06-25T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/06-25-All-About-Strictness.html"/><summary type="html">&lt;p&gt;Original post: &lt;a href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness"&gt;ALL ABOUT STRICTNESS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Haskell は (もしかすると、評判のよろしくない？) 遅延 (&lt;em&gt;lazy&lt;/em&gt;) 言語です。遅延性の基本的なアイデアは「値は必要となったときにのみ計算される」という、たった一言で説明できるぐらい簡単なものです。しかし、この裏には様々なことが隠れています。特に、メモリと時間について効率的なコードを書こうとしたときに、必要不可欠なトピックがいくつもあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;弱頭部正規形 (WHNF) と 正規形 (NF)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seq&lt;/code&gt; と &lt;code&gt;deepseq&lt;/code&gt; の使い方 (と関連する概念)&lt;/li&gt;
&lt;li&gt;データ型の正格性注釈&lt;/li&gt;
&lt;li&gt;バンパターン&lt;/li&gt;
&lt;li&gt;遅延、スパイン(spine)-正格、値-正格などのデータ構造の正格性&lt;/li&gt;
&lt;li&gt;適切な補助関数の選択 (特に、fold 系)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この記事は効率的な &lt;a href="https://haskell-lang.org/library/conduit"&gt;conduit&lt;/a&gt; コードを書くためのいくつかの質問にインスパイアされたものであり、記事の最後でそれらについて本気で取り組んでみようと思います。ここで紹介する概念は汎用的なものであり、ストリーミングライブラリに限定されるものではありません。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ノート&lt;/strong&gt; この記事は現実とは逆に、遅延性を解決すべき問題として取り扱います。遅延性は有利にも不利にもなります。私たちの目標は遅延性の問題の大枠とその回避策を理解することなので、悪い点にのみ焦点を当てることにします。遅延性にはとても大きなメリットが数多くありますが、ここで取り上げることはしません。なぜなら、私の読者はコメントで遅延性の素晴らしさについて紹介している記事へのリンクをいくつも追加してくれるでしょうから :)&lt;/p&gt;
&lt;p&gt;翻訳者追記&lt;/p&gt;
&lt;p&gt;原文では、スパイン (spine) やスパイン正格 (spine-strict) という単語 (概念) については前提知識として扱っており、あまり丁寧に解説されていません。そのため、これらの用語に馴染みの無い方は先に &lt;a href="https://stackoverflow.com/questions/22249575/what-is-spine-strictness"&gt;What is spine strictness&lt;/a&gt; などを読んでおくと本記事の理解がより深まるかと思います。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="遅延性入門"&gt;遅延性入門&lt;/h2&gt;
&lt;p&gt;さて、私は先ほど&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;値は必要となった時にのみ計算される&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;と言いました。詳細を知るために正格言語であるC言語と比較してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode c"&gt;&lt;code class="sourceCode c"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="pp"&gt;#include &lt;/span&gt;&lt;span class="im"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="dt"&gt;int&lt;/span&gt; add(&lt;span class="dt"&gt;int&lt;/span&gt; x, &lt;span class="dt"&gt;int&lt;/span&gt; y) {&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="cf"&gt;return&lt;/span&gt; x + y;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;}&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;span class="dt"&gt;int&lt;/span&gt; main() {&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;  &lt;span class="dt"&gt;int&lt;/span&gt; five = add(&lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;  &lt;span class="dt"&gt;int&lt;/span&gt; seven = add(&lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;3&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;  printf(&lt;span class="st"&gt;&amp;quot;Five: %d&lt;/span&gt;&lt;span class="sc"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;, five);&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;  &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;私たちの関数 &lt;code&gt;add&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方の引数で&lt;em&gt;正格&lt;/em&gt;です。そして、結果もまた正格になります。つまり&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初めて &lt;code&gt;add&lt;/code&gt; が呼ばれる前に &lt;code&gt;1 + 1&lt;/code&gt; と &lt;code&gt;1 + 2&lt;/code&gt; の両方の結果を計算します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; と &lt;code&gt;3&lt;/code&gt; を引数として &lt;code&gt;add&lt;/code&gt; 関数を呼び出した結果 &lt;code&gt;5&lt;/code&gt; が得られます。それは変数 &lt;code&gt;five&lt;/code&gt; によって指し示されるメモリの値となります。&lt;/li&gt;
&lt;li&gt;同様に &lt;code&gt;1 + 2&lt;/code&gt;, &lt;code&gt;1 + 3&lt;/code&gt; を計算し &lt;code&gt;seven&lt;/code&gt; に &lt;code&gt;7&lt;/code&gt; が格納されます。&lt;/li&gt;
&lt;li&gt;完全に計算された &lt;code&gt;five&lt;/code&gt; の値で &lt;code&gt;printf&lt;/code&gt; を呼び出します。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、これと等価な Haskell コードと比較してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;      seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正格性解析 (&lt;em&gt;strictness analysis&lt;/em&gt;) と呼ばれる仕組みにより、説明よりも効率的な結果となることがありますが、意味的には以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 + 1&lt;/code&gt; や &lt;code&gt;1 + 2&lt;/code&gt; の計算をすぐに行うのではなく、コンパイラはこれらの計算のサンク (&lt;em&gt;thunk&lt;/em&gt;) (プロミス (&lt;em&gt;promise&lt;/em&gt;) として考えることができます) を生成し、&lt;code&gt;add&lt;/code&gt; 関数にサンクを渡します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt; 関数をすぐに呼び出すという例外を除けば、&lt;code&gt;five&lt;/code&gt; は &lt;code&gt;add&lt;/code&gt; 関数を &lt;code&gt;1 + 1&lt;/code&gt; と &lt;code&gt;1 + 2&lt;/code&gt; のサンクに適用するというサンクです。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seven&lt;/code&gt; に関しても同様に、&lt;code&gt;add&lt;/code&gt; 関数を異なる2つのサンクに適用するというサンクです。&lt;/li&gt;
&lt;li&gt;最終的に &lt;code&gt;five&lt;/code&gt; を表示しようとする際に実際の数を知る必要があります。このことを強制評価 (&lt;em&gt;forcing evaluation&lt;/em&gt;) と言い、あとで詳しく、いつ・どのように強制評価が起こるか説明しますが、今のところは &lt;code&gt;putStrLn&lt;/code&gt; が実行された時に起こると理解すれば十分です。&lt;code&gt;1 + 1&lt;/code&gt; と &lt;code&gt;1 + 2&lt;/code&gt; の強制評価を行う &lt;code&gt;five&lt;/code&gt; の強制評価が行われ、サンクが実際の数 (&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, 最終的に &lt;code&gt;5&lt;/code&gt;) に変換されます。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seven&lt;/code&gt; は一度も使われず、サンクとして残ったままとなりますが、このサンクを評価するための時間はかかっていません。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C の (正格) 評価と比較すると、使われることのない &lt;code&gt;seven&lt;/code&gt; の値を評価するという無意味な処理を行わないという恩恵があります。これにより、処理を3つスキップできます！現実的な場面では3つではなく、もっとひどいコストのかかる処理かもしれません。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;だけども&lt;/em&gt;、全てが素晴らしいものではありません。サンクはタダじゃないんです。我々はサンクのためにスペースを確保する必要があり、その確保と後にメモリ解放のために行われる GC を引き起こすコストの両方がかかります。たぶん一番大切なことは、式がサンク化されたものは、評価されたものよりもずっとコストがかかる可能性があるということです。(問題がより複雑になって) 混乱してしまわないように、データコストラクタのオーバーヘッドは一旦無視して、&lt;code&gt;five&lt;/code&gt; の2つの表現方法を比較してみましょう。C において &lt;code&gt;five&lt;/code&gt; は正確に1つのマシンワード*を消費します。それに対して Haskell の &lt;code&gt;five&lt;/code&gt; サンクはだいたい以下のようになります。&lt;/p&gt;
&lt;p&gt;* 64ビットのマシンを使っている場合 &lt;code&gt;int&lt;/code&gt; は32ビットなので、スペースの消費はより少なくなるでしょう。しかし、アライメントの問題やレジスタについて考え出すと話がややこしくなるので、ここでは1ワードとして扱うことにします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1つのマシンワードが “私はサンクです” と主張します&lt;/li&gt;
&lt;li&gt;サンクの中は &lt;code&gt;add&lt;/code&gt; 関数と &lt;code&gt;1 + 1&lt;/code&gt; と &lt;code&gt;1 + 2&lt;/code&gt; のサンク (それぞれ1つのマシンワード) へのポインタとなっています。そのため合計で3つのマシンワードです。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 + 1&lt;/code&gt; のサンクはサンクのための1つのマシンワードと &lt;code&gt;+&lt;/code&gt; 演算子と &lt;code&gt;1&lt;/code&gt; の値へのポインタです。(GHC は int 自身の余分なオーバーヘッドを避けるためにメモリの専用部分に小さな int の値を保持する最適化を行いますが、理論的にはそれぞれの余分なマシンワードが追加されます)。ここでもまた、少なくとも3つのマシンワードが必要となります。&lt;/li&gt;
&lt;li&gt;同じことが &lt;code&gt;1 + 2&lt;/code&gt; のサンクにも言えるので、3つのマシンワードとなります。&lt;/li&gt;
&lt;li&gt;最終的な合計は&lt;strong&gt;10マシンワード&lt;/strong&gt;となり、C のメモリ使用量と比較して10倍の差があります！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実際のところ、こんなに上手くはいきません。なぜなら、正格性解析によって “やぁ、ちょっと待って、これは後で使うからサンクを確保するよりも2つの数字を加算する方が絶対良いって、じゃあまたね！” という感じで最適化が行われるためです。しかし、遅延性やサンクが発生する可能性のある全ての場所を理解しておくことは、Haskell を書く上で非常に重要なことです。&lt;/p&gt;
&lt;h3 id="バン"&gt;バン!&lt;/h3&gt;
&lt;p&gt;さて、どうすれば Haskell の評価をより正格にできるのでしょうか。一番簡単なのはバンパターンを使う方法です。まずはコードを確認してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;add &lt;span class="fu"&gt;!&lt;/span&gt;x &lt;span class="fu"&gt;!&lt;/span&gt;y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このコードは正格な C のコードと全く同じように振る舞います。先ほどのコードとの違いは &lt;code&gt;add&lt;/code&gt; 関数の &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の前にバン (&lt;code&gt;!&lt;/code&gt;) があることです。これによって GHC は &lt;code&gt;add&lt;/code&gt; を評価する前に &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の値を評価しなければならないと判断します。同様に &lt;code&gt;five&lt;/code&gt; と &lt;code&gt;seven&lt;/code&gt; の前にも &lt;code&gt;!&lt;/code&gt; があるため、 GHC は &lt;code&gt;putStrLn&lt;/code&gt; を評価する前にこれらの値を評価します。&lt;/p&gt;
&lt;p&gt;Haskell には多くのものがありますが、バンパターンはただの &lt;code&gt;seq&lt;/code&gt; 関数を使ったシンタックスシュガーです。&lt;code&gt;seq&lt;/code&gt; 関数の型は以下の通りです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;seq&lt;span class="ot"&gt; ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この型シグネチャを見ると、&lt;code&gt;a&lt;/code&gt; の値を無視するような以下の実装にしたくなるでしょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;badseq ::&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;badseq a b &lt;span class="fu"&gt;=&lt;/span&gt; b&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;けれども、 &lt;code&gt;seq&lt;/code&gt; は GHC が提供しているプリミティブな操作を使って&lt;code&gt;b&lt;/code&gt; が評価されるときには、既に &lt;code&gt;a&lt;/code&gt; が評価されていることを保証します。ここで先ほどの &lt;code&gt;add&lt;/code&gt; 関数をバンパターンの代わりに &lt;code&gt;seq&lt;/code&gt; を使って書き換えてみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; part1 &lt;span class="fu"&gt;=&lt;/span&gt; seq x part2&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;      part2 &lt;span class="fu"&gt;=&lt;/span&gt; seq y answer&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;      answer &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; part1&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="co"&gt;-- Or more idiomatically&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="ot"&gt;`seq`&lt;/span&gt; y &lt;span class="ot"&gt;`seq`&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このコードは以下のような意味になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;part1&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; を評価した後に &lt;code&gt;part2&lt;/code&gt; の値を評価します&lt;/li&gt;
&lt;li&gt;&lt;code&gt;part2&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; を評価した後に &lt;code&gt;answer&lt;/code&gt; の値を評価します&lt;/li&gt;
&lt;li&gt;&lt;code&gt;answer&lt;/code&gt; はそのまま &lt;code&gt;x + y&lt;/code&gt; です&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もちろん、&lt;code&gt;let&lt;/code&gt; と &lt;code&gt;in&lt;/code&gt; を使ってこんなに長いコードを書くのは大変なので、多くのプログラマは最後の行のように &lt;code&gt;seq&lt;/code&gt; を中置記法で使います。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; &lt;code&gt;in part1&lt;/code&gt; の代わりに &lt;code&gt;in part2&lt;/code&gt; とした場合どうなるでしょうか？また &lt;code&gt;in answer&lt;/code&gt; ではどうでしょうか？&lt;/p&gt;
&lt;p&gt;バンパターンから &lt;code&gt;let&lt;/code&gt; を使う方法への変換はどんな場合でも可能です。先ほどの &lt;code&gt;main&lt;/code&gt; 関数は次のように書き換えても同じことです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;      seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;  five &lt;span class="ot"&gt;`seq`&lt;/span&gt; seven &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn (&lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のプログラムはバンパターンを使ったものと等しく、&lt;code&gt;seq&lt;/code&gt; の動作を理解するために非常に重要な例です。ですが、バンパターンのコードよりも少し読みづらくなってしまったと感じる読者もいると思います。なので、自分が読みやすい好きな方を使ってください。たぶん、ほとんどの人はバンパターンを使うでしょうけども。&lt;/p&gt;
&lt;h3 id="評価を追ってみよう"&gt;評価を追ってみよう&lt;/h3&gt;
&lt;p&gt;今まで、サンクの評価について私の説明が全てでした。これから、評価について、もっと直接的に観測するための方法について説明します。&lt;code&gt;Debug.Trace&lt;/code&gt; モジュールで定義されている &lt;code&gt;trace&lt;/code&gt; 関数は評価された時にメッセージを表示します。以下の2つのプログラムの出力を予想してみてください。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Debug.Trace&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; trace &lt;span class="st"&gt;&amp;quot;five&amp;quot;&lt;/span&gt; (add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;      seven &lt;span class="fu"&gt;=&lt;/span&gt; trace &lt;span class="st"&gt;&amp;quot;seven&amp;quot;&lt;/span&gt; (add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Debug.Trace&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;five &lt;span class="fu"&gt;=&lt;/span&gt; trace &lt;span class="st"&gt;&amp;quot;five&amp;quot;&lt;/span&gt; (add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;seven &lt;span class="fu"&gt;=&lt;/span&gt; trace &lt;span class="st"&gt;&amp;quot;seven&amp;quot;&lt;/span&gt; (add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;それぞれのプログラムで表示される内容は・・・&lt;/p&gt;
&lt;p&gt;もうわかりましたね。答えは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最初のプログラムは &lt;code&gt;five&lt;/code&gt; と &lt;code&gt;Five: 5&lt;/code&gt; の両方を表示します。&lt;code&gt;seven&lt;/code&gt; は式が評価されないため、表示されません。(出力のバッファリングによっては、これらの値の表示順序が入れ替わるという奇妙な現象が起きることがあります。)&lt;/li&gt;
&lt;li&gt;2つ目のプログラムは &lt;code&gt;five&lt;/code&gt; と &lt;code&gt;seven&lt;/code&gt; の両方を表示します。なぜなら、バンパターンによってこれらの評価が強制されるからです。しかし、この表示順についてはあなたが期待するものと異なっていたのではないでしょうか。現に、私のシステムでは &lt;code&gt;five&lt;/code&gt; が表示される前に &lt;code&gt;seven&lt;/code&gt; が表示されました。なぜなら、この場合において GHC は評価順を並び替えることができるからです。&lt;/li&gt;
&lt;li&gt;逆に &lt;code&gt;five `seq` seven `seq` putStrLn (&amp;quot;Five: &amp;quot; ++ show five)&lt;/code&gt; としていたら、表示される順序は &lt;code&gt;five&lt;/code&gt;, &lt;code&gt;seven&lt;/code&gt;, &lt;code&gt;&amp;quot;Five: 5&amp;quot;&lt;/code&gt; となっていたでしょう。これはバンパターンが単に &lt;code&gt;seq&lt;/code&gt; に変換されるという先ほどの説明でほんの少しだけ嘘をついたからです。しかし、 &lt;code&gt;x `seq` y&lt;/code&gt; という式は実際のところ、GHC からすれば &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のどちらを先に評価したとしても、式の評価が終わった時に &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方が評価されていることが保証されていれば良いのです。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とはいえ、あたなの式が本当に純粋であれば、&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の評価がどちらから行われるかということは観測できなかったはずです。純粋では無い &lt;code&gt;trace&lt;/code&gt; 関数を利用したからこそ、評価の順序を観測することができたんです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;質問&lt;/strong&gt; もし、全ての &lt;code&gt;add&lt;/code&gt; 関数に &lt;code&gt;!&lt;/code&gt; をつけたら結果はどう変わるでしょうか？ なぜ &lt;code&gt;!&lt;/code&gt; を付けるだけで出力に影響したり (しなかったり) するのでしょうか？&lt;/p&gt;
&lt;h3 id="ボトムの値"&gt;ボトムの値&lt;/h3&gt;
&lt;p&gt;今までの例もちゃんと動くので良いのですが、評価の順番を確認する方法として、よりスタンダードな方法があります。それはボトム、すなわち &lt;code&gt;undefined&lt;/code&gt; を使うことです。&lt;code&gt;undefined&lt;/code&gt; は、評価されたときに実行時例外を投げる点で特別です。 (他の特別な関数や値のように、&lt;code&gt;error&lt;/code&gt; 関数も同じ動きをします。) バンが無い場合は &lt;code&gt;seven&lt;/code&gt; が評価されないことを確認するために、以下の2つのプログラムを比較してみましょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;      seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) undefined &lt;span class="co"&gt;-- (1 + 3)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;add x y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) undefined &lt;span class="co"&gt;-- (1 + 3)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-13" data-line-number="13"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最初の例は問題なく実行することができます。これは &lt;code&gt;seven&lt;/code&gt; が評価されないからですね。しかし、2つ目の例では、&lt;code&gt;seven&lt;/code&gt; にバンパターンが付いています。ここで、GHC はこんなことをしています:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add (1 + 2) undefined&lt;/code&gt; と言う式を評価します。&lt;/li&gt;
&lt;li&gt;この式は &lt;code&gt;(1 + 2) + undefined&lt;/code&gt; に簡約されます。&lt;/li&gt;
&lt;li&gt;しかし、簡約した結果は値ではなく式なので、さらに評価が必要になります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; という演算子を評価するためには、2つの引数にサンクではなく実際の値が必要になります。このことは &lt;code&gt;+&lt;/code&gt; の引数がバンパターンとなっているという見方をしても良いでしょう。より正確には、「&lt;code&gt;+&lt;/code&gt; は2つの引数のどちらに対しても正格」と言います。&lt;/li&gt;
&lt;li&gt;GHC は &lt;code&gt;1 + 2&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; の評価順を自由に選択できます。ここでは &lt;code&gt;1 + 2&lt;/code&gt; を最初に評価することにしましょう。そうすると、2つの評価済みの値 (&lt;code&gt;1&lt;/code&gt; と &lt;code&gt;2&lt;/code&gt;) を &lt;code&gt;+&lt;/code&gt; に渡すので、&lt;code&gt;3&lt;/code&gt; が返ってきます。全て順調ですね。&lt;/li&gt;
&lt;li&gt;しかし、次に &lt;code&gt;undefined&lt;/code&gt; を評価しようとして、実行時例外が投げられます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;質問&lt;/strong&gt; 上の質問に戻りますが: &lt;code&gt;add&lt;/code&gt; 関数の内部にバンパターンを持たせたら、何か変わるでしょうか? 以下のプログラムの出力が何になるか考えてみてください:&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;&lt;span class="ot"&gt;add ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;add &lt;span class="fu"&gt;!&lt;/span&gt;x &lt;span class="fu"&gt;!&lt;/span&gt;y &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; five &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;      seven &lt;span class="fu"&gt;=&lt;/span&gt; add (&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) undefined &lt;span class="co"&gt;-- (1 + 3)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-13" data-line-number="13"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; show five&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この動作を正格な言語と比較するためには、実行時例外のようなものを持つ言語が必要ですね。Rust の panic を使うことにしましょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; add(x: &lt;span class="dt"&gt;isize&lt;/span&gt;, y: &lt;span class="dt"&gt;isize&lt;/span&gt;) -&amp;gt; &lt;span class="dt"&gt;isize&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;    &lt;span class="pp"&gt;println!&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;adding: {} and {}&amp;quot;&lt;/span&gt;, x, y);&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;    x + y&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; main() &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; five = add(&lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; seven = add(&lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="pp"&gt;panic!&lt;/span&gt;());&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;    &lt;span class="pp"&gt;println!&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Five: {}&amp;quot;&lt;/span&gt;, five);&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まず、Rust の名誉のために一言断っておくと、Rust は、このプログラムがどんなにバカげたことをしているのか、多くの警告を出してくれます。確かにそれはそうなんですが、これらの警告は無視して突っ走りましょう。このプログラムは、まず最初に &lt;code&gt;add(1 + 1, 1 + 2)&lt;/code&gt; という式を評価します (&lt;code&gt;adding: 2 and 3&lt;/code&gt; という出力で確認できます)。そして、2回目の &lt;code&gt;add&lt;/code&gt; 関数に入る前に、&lt;code&gt;1 + 2&lt;/code&gt; と &lt;code&gt;panic!()&lt;/code&gt; のどちらも評価する必要があります。前者はいいですが、後者ではパニックが発生し、そこでショートします。&lt;/p&gt;
&lt;p&gt;Haskell の遅延性を獲得したいのなら、簡単な方法があります。クロージャを使いましょう。クロージャは本質的にはサンクです。Rust の構文でクロージャを書くと、&lt;code&gt;|args| body&lt;/code&gt; のようになります。引数なしのクロージャを作ると、サンクのような振る舞いをします。こんな感じです:&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; add&amp;lt;X, Y&amp;gt;(x: X, y: Y) -&amp;gt; &lt;span class="dt"&gt;isize&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;    &lt;span class="kw"&gt;where&lt;/span&gt; X: &lt;span class="bu"&gt;FnOnce&lt;/span&gt;() -&amp;gt; &lt;span class="dt"&gt;isize&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;          Y: &lt;span class="bu"&gt;FnOnce&lt;/span&gt;() -&amp;gt; &lt;span class="dt"&gt;isize&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; x = x();&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; y = y();&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;    &lt;span class="pp"&gt;println!&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;adding: {} and {}&amp;quot;&lt;/span&gt;, x, y);&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;    x + y&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; main() &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; five = || add(|| &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;1&lt;/span&gt;, || &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; seven = || add(|| &lt;span class="dv"&gt;1&lt;/span&gt; + &lt;span class="dv"&gt;2&lt;/span&gt;, || &lt;span class="pp"&gt;panic!&lt;/span&gt;());&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;    &lt;span class="pp"&gt;println!&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Five: {}&amp;quot;&lt;/span&gt;, five());&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" data-line-number="15"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;繰り返しますが、Rust のコンパイラは使われていない &lt;code&gt;seven&lt;/code&gt; について文句を言ってきます。が、&lt;code&gt;seven&lt;/code&gt; のクロージャを使うことはないので、このプログラムを実行することはできます。&lt;/p&gt;
&lt;p&gt;まだ Rust についてあまり知らない? それなら、みんな大好き Javascript を使ってみましょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode javascript"&gt;&lt;code class="sourceCode javascript"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;function&lt;/span&gt; &lt;span class="at"&gt;add&lt;/span&gt;(x&lt;span class="op"&gt;,&lt;/span&gt; y) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="at"&gt;x&lt;/span&gt;() &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="at"&gt;y&lt;/span&gt;()&lt;span class="op"&gt;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;span class="kw"&gt;function&lt;/span&gt; &lt;span class="at"&gt;panic&lt;/span&gt;() &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;    &lt;span class="cf"&gt;throw&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Panic!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="kw"&gt;var&lt;/span&gt; five &lt;span class="op"&gt;=&lt;/span&gt; ignored &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="at"&gt;add&lt;/span&gt;(ignored &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; ignored &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;span class="op"&gt;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="kw"&gt;var&lt;/span&gt; seven &lt;span class="op"&gt;=&lt;/span&gt; ignored &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="at"&gt;add&lt;/span&gt;(ignored &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; panic)&lt;span class="op"&gt;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;&lt;span class="va"&gt;console&lt;/span&gt;.&lt;span class="at"&gt;log&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;Five: &amp;quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="at"&gt;five&lt;/span&gt;())&lt;span class="op"&gt;;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;よし、今までの話をまとめてみます:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Haskell の評価戦略はデフォルトで遅延評価です。&lt;/li&gt;
&lt;li&gt;バンパターンと &lt;code&gt;seq&lt;/code&gt; を使うことで、正格評価にすることができます。&lt;/li&gt;
&lt;li&gt;一方、正格な言語ではクロージャを使うことで遅延評価にすることができます。&lt;/li&gt;
&lt;li&gt;ボトム (&lt;code&gt;undefined&lt;/code&gt;) を関数の引数に渡して、目の前で爆発すれば、関数の引数が正格だとわかります。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trace&lt;/code&gt; 関数を使っても同じことを確認できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまでは全て順調ですね。先に進む前に、これらの概念を確実に理解しておいてください。前の章を読み直すのもいいかもしれません。&lt;/p&gt;
&lt;h2 id="平均"&gt;平均&lt;/h2&gt;
&lt;p&gt;まだ言及してないことがありました。「評価する」とか「値であることを強要する」というのは具体的にどういうことなのでしょう? この問題を考えるために、average 関数を実装してみましょう。&lt;code&gt;RunningTotal&lt;/code&gt; というデータ型を使って、平均値の合計と要素数を取得することにします。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;&lt;span class="ot"&gt;printAverage ::&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" data-line-number="7"&gt;printAverage (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" data-line-number="8"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; count &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; error &lt;span class="st"&gt;&amp;quot;Need at least one value!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" data-line-number="9"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="fu"&gt;=&lt;/span&gt; print (fromIntegral sum &lt;span class="fu"&gt;/&lt;/span&gt; fromIntegral&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" data-line-number="11"&gt;&lt;span class="co"&gt;-- | A fold would be nicer... we&amp;#39;ll see that later&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" data-line-number="12"&gt;&lt;span class="ot"&gt;printListAverage ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" data-line-number="13"&gt;printListAverage &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" data-line-number="14"&gt;  go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" data-line-number="15"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" data-line-number="16"&gt;    go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-17" data-line-number="17"&gt;    go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-18" data-line-number="18"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-19" data-line-number="19"&gt;       &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-20" data-line-number="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-21" data-line-number="21"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-22" data-line-number="22"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; printListAverage [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行時に統計を取って、メモリ使用量を見てみます:&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack ghc average.hs &amp;amp;&amp;amp; ./average +RTS -s&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なんということでしょう。メモリ使用量がぶっ飛んだことになっています!&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;[1 of 1] Compiling Main             ( average.hs, average.o )
Linking average ...
500000.5
     258,654,528 bytes allocated in the heap
     339,889,944 bytes copied during GC
      95,096,512 bytes maximum residency (9 sample(s))
       1,148,312 bytes maximum slop
             164 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;トータルで 258MB も確保していて、一度に 95MB も確保しています。ただの局所関数の再帰にしては、ばかみたいに多いですね。&lt;/p&gt;
&lt;h3 id="バン-1"&gt;バン!&lt;/h3&gt;
&lt;p&gt;あなたは今、「&lt;code&gt;seq&lt;/code&gt; とかバンパターンのようなものを使うべきじゃないの?」と考えていると思います。確かに、それも良いでしょう。実際、1つバンパターンを加えて &lt;code&gt;go&lt;/code&gt; の再帰に入る前に新しい &lt;code&gt;rt&lt;/code&gt; を強制評価すれば、この問題は簡単に解決できそうです。例えば、&lt;code&gt;{-# LANGUAGE BangPatterns #-}&lt;/code&gt; をファイルの先頭に追加して、&lt;code&gt;go&lt;/code&gt; をこんな風に定義したらどうでしょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;go &lt;span class="fu"&gt;!&lt;/span&gt;rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;しかし、こうしてもメモリ使用量は&lt;em&gt;全く&lt;/em&gt;変わりません。なぜこんなことになってしまうのでしょう。これを理解するためには、weak head normal form (弱頭部正規形) というものを理解する必要があります。&lt;/p&gt;
&lt;h3 id="弱頭部正規形"&gt;弱頭部正規形&lt;/h3&gt;
&lt;p&gt;まず最初に、このトピックに関して &lt;a href="https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form/6889335#6889335"&gt;Stack Overflow に素晴らしい回答があることを&lt;/a&gt;示しておきます。&lt;/p&gt;
&lt;p&gt;私たちは値であることを強制し、式を評価することについて話し合ってきましたが、それが実際に何を意味しているのかは全く明らかにしませんでした。まず簡単な例から始めましょう。このプログラムの出力はどうなるでしょうか?&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; undefined &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文字列を表示しようとしたときに &lt;code&gt;undefined&lt;/code&gt; が原因でエラーになるだろうと予測した方は正解です。このエラーは &lt;code&gt;putStrLn&lt;/code&gt; が引数に対して正格であり、また &lt;code&gt;&amp;quot;Hello World&amp;quot;&lt;/code&gt; を評価する前に &lt;code&gt;undefined&lt;/code&gt; を評価しようとするために起こります。では、少し違う例を試してみましょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; undefined &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;「評価する」という言葉を、「サンクがない状態の何かになるまで完全に評価する」という意味で取っている人は、今回も &lt;code&gt;undefined&lt;/code&gt; についてエラーを吐く、と答えるでしょう。しかし実際は、例外を吐かずにうまく “Hello World” と表示してくれます。一体どうなっているんでしょう?&lt;/p&gt;
&lt;p&gt;実は、&lt;code&gt;seq&lt;/code&gt; で強制評価について話しているときは、&lt;em&gt;弱頭部正規形 (weak head normal form) (WHNF)&lt;/em&gt; へ評価するという意味で話しています。ほとんどのデータ型において、これは 1つコンストラクタの層を引き剥がす、という意味になります。&lt;code&gt;Just undefined&lt;/code&gt; の場合、&lt;code&gt;Just&lt;/code&gt; というデータコンストラクタを引き剥がすだけで、その中の &lt;code&gt;undefined&lt;/code&gt; に触れることはありません。(すぐ下でこれに対処する別々の方法をお見せします。)&lt;/p&gt;
&lt;p&gt;標準データコンストラクタ*を扱う場合、&lt;code&gt;seq&lt;/code&gt; を利用するということは一番外側のコンストラクタでパターンマッチさせるようなものです。単相化させたいのなら、例えば、&lt;code&gt;seqMaybe :: Maybe a -&amp;gt; b -&amp;gt; b&lt;/code&gt; という関数を実装して、上の &lt;code&gt;main&lt;/code&gt; で使うことができます。やってみてください。答えは下にあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;説明はお待ちください。後で &lt;code&gt;newtype&lt;/code&gt; の話を読めば、この変なネーミングの意味を理解できるでしょう。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="ot"&gt;seqMaybe ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;seqMaybe &lt;span class="dt"&gt;Nothing&lt;/span&gt; b &lt;span class="fu"&gt;=&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;seqMaybe (&lt;span class="dt"&gt;Just&lt;/span&gt; _) b &lt;span class="fu"&gt;=&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-7" data-line-number="7"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; undefined &lt;span class="ot"&gt;`seqMaybe`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-8" data-line-number="8"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; undefined &lt;span class="ot"&gt;`seqMaybe`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Goodbye!&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;では、続けましょう。このプログラムは何を表示すると思いますか?&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb23-1" data-line-number="1"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" data-line-number="2"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; error &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" data-line-number="3"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; (\x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; undefined) &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;World&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" data-line-number="4"&gt;  putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; error &lt;span class="st"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Goodbye!&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;error `seq` ...&lt;/code&gt; が問題になると思うかもしれません。最終的に &lt;code&gt;error&lt;/code&gt; が例外を吐くんじゃないの? ってね。しかし、&lt;code&gt;error&lt;/code&gt; は関数です。&lt;code&gt;error&lt;/code&gt; が &lt;code&gt;String&lt;/code&gt; の値を引数に与えられるまで、例外が吐かれることも、ボトムの値が返されることもないのです。よって、これを評価してもエラーを生成することはありません。ルールとしては、引数よりも少ない値に適用された関数は、自動的に弱頭部正規形になります。&lt;/p&gt;
&lt;p&gt;同じようなロジックは、&lt;code&gt;(\x -&amp;gt; undefined)&lt;/code&gt; にも適用できます。これはラムダ式ですが、型としては全ての引数に値が適用されていない関数です。したがって、このラムダ式が評価されても例外を吐くことはありません。言い換えると、この式はすでに弱頭部正規形になっています。&lt;/p&gt;
&lt;p&gt;しかし、&lt;code&gt;error &amp;quot;foo&amp;quot;&lt;/code&gt; は引数が完全に適用された関数です。これはもう関数ではなく、値です。そして弱頭部正規形に評価しようとするときに、例外が爆発して顔面に飛んできます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; 次の式は、評価されたときに例外を投げるでしょうか?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(+) undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Just undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(error &amp;quot;foo&amp;quot; :: Int -&amp;gt; Double)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="average-関数を修正する"&gt;average 関数を修正する&lt;/h3&gt;
&lt;p&gt;弱頭部正規形を理解したところで、例に戻って最初のバンパターンが、なぜ何もしてくれなかったのか見てみましょう:&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb24-1" data-line-number="1"&gt;go &lt;span class="fu"&gt;!&lt;/span&gt;rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;弱頭部正規形では、強制評価はコンストラクタを剥がすことと同じです。これはさっきの節でもうやりましたね! 問題は、&lt;code&gt;RunningTotal&lt;/code&gt; データコンストラクタの中に含まれる値が評価されていないこと、それが原因でサンクが蓄積されていることです。これを解決する方法は2つあります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb25-1" data-line-number="1"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;sum &lt;span class="fu"&gt;!&lt;/span&gt;count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;バンを &lt;code&gt;RunningTotal&lt;/code&gt; に置くのはやめて、コンストラクタの&lt;em&gt;中&lt;/em&gt;の値に置いて、ループの度に強制的に評価させるようにしています。巨大なサンクの連鎖は無くなり、最大メモリ常駐量は 44kb にまで減少しています。(全体としては、まだ約 192mb 使用しています。これをどうにかするためには、今回の例とは異なる別の最適化を行う必要があります。なので、この値はこの例では全て無視することにします。) もう1つのアプローチは:&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb26-1" data-line-number="1"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;sum&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;+&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-4" data-line-number="4"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;count&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-5" data-line-number="5"&gt;      rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum&amp;#39; count&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-6" data-line-number="6"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このアプローチでは新しい &lt;code&gt;RunningTotal&lt;/code&gt; の値を作る&lt;em&gt;前&lt;/em&gt;に、新しい sum と count を強制評価します。私はこのバージョンの方がちょっと好きです。というのも、次の繰り返しで値を分解した時ではなく、正しい場所、つまり値を構築するときに評価を強制しているからです。&lt;/p&gt;
&lt;p&gt;この話のポイント: コンテナではなく、実際に評価する必要があるものを評価していることを確認すべし&lt;/p&gt;
&lt;h4 id="翻訳者追記"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;実行結果を比較してみました。&lt;/p&gt;
&lt;h5 id="section"&gt;1&lt;/h5&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb27-1" data-line-number="1"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="section-1"&gt;2&lt;/h5&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb28-1" data-line-number="1"&gt;go &lt;span class="fu"&gt;!&lt;/span&gt;rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="section-2"&gt;3&lt;/h5&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb29-1" data-line-number="1"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;sum &lt;span class="fu"&gt;!&lt;/span&gt;count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-4" data-line-number="4"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="section-3"&gt;4&lt;/h5&gt;
&lt;div class="sourceCode" id="cb30"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb30-1" data-line-number="1"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb30-2" data-line-number="2"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb30-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;sum&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="fu"&gt;+&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb30-4" data-line-number="4"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;count&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb30-5" data-line-number="5"&gt;      rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum&amp;#39; count&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb30-6" data-line-number="6"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="原文にはありませんがrunningtotal-の定義で正格性注釈をつけています"&gt;5 原文にはありませんが、&lt;code&gt;RunningTotal&lt;/code&gt; の定義で正格性注釈をつけています。&lt;/h5&gt;
&lt;div class="sourceCode" id="cb31"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb31-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-4" data-line-number="4"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-6" data-line-number="6"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-7" data-line-number="7"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-9" data-line-number="9"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="これも原文にはありませんがstrictdata-拡張を使っています"&gt;6 これも原文にはありませんが、&lt;code&gt;StrictData&lt;/code&gt; 拡張を使っています。&lt;/h5&gt;
&lt;div class="sourceCode" id="cb32"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb32-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE StrictData #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb32-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb32-3" data-line-number="3"&gt;go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb32-4" data-line-number="4"&gt;go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb32-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb32-6" data-line-number="6"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="deepseq-のセクションのものです"&gt;7 deepseq のセクションのものです&lt;/h5&gt;
&lt;div class="sourceCode" id="cb33"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb33-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb33-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb33-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb33-4" data-line-number="4"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb33-5" data-line-number="5"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;NFData&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb33-6" data-line-number="6"&gt;  rnf (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; count &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;col style="width: 12%" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;allocated in the heap&lt;/td&gt;
&lt;td&gt;258,654,520 bytes&lt;/td&gt;
&lt;td&gt;258,654,520 bytes&lt;/td&gt;
&lt;td&gt;192,102,712 bytes&lt;/td&gt;
&lt;td&gt;216,102,712 bytes&lt;/td&gt;
&lt;td&gt;176,102,712 bytes&lt;/td&gt;
&lt;td&gt;176,102,712 bytes&lt;/td&gt;
&lt;td&gt;256,135,480 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;copied during GC&lt;/td&gt;
&lt;td&gt;339,889,944 bytes&lt;/td&gt;
&lt;td&gt;339,889,944 bytes&lt;/td&gt;
&lt;td&gt;173,080 bytes&lt;/td&gt;
&lt;td&gt;142,896 bytes&lt;/td&gt;
&lt;td&gt;164,400 bytes&lt;/td&gt;
&lt;td&gt;164,400 bytes&lt;/td&gt;
&lt;td&gt;168,640 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;maximum residency&lt;/td&gt;
&lt;td&gt;95,096,512 bytes&lt;/td&gt;
&lt;td&gt;95,096,512 bytes&lt;/td&gt;
&lt;td&gt;44,384 bytes&lt;/td&gt;
&lt;td&gt;44,384 bytes&lt;/td&gt;
&lt;td&gt;44,384 bytes&lt;/td&gt;
&lt;td&gt;44,384 bytes&lt;/td&gt;
&lt;td&gt;44,384 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;maximum slop&lt;/td&gt;
&lt;td&gt;1,148,312 byte&lt;/td&gt;
&lt;td&gt;1,148,312 bytes&lt;/td&gt;
&lt;td&gt;25,248 bytes&lt;/td&gt;
&lt;td&gt;25,248 bytes&lt;/td&gt;
&lt;td&gt;25,248 bytes&lt;/td&gt;
&lt;td&gt;25,248 bytes&lt;/td&gt;
&lt;td&gt;25,248 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;total memory in use&lt;/td&gt;
&lt;td&gt;164 MB&lt;/td&gt;
&lt;td&gt;164 MB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="deepseq"&gt;deepseq&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;seq&lt;/code&gt; が弱頭部正規形にしか評価してくれないのはイライラしますよね。&lt;em&gt;正規形&lt;/em&gt; (NF) にまで完全に評価したいという状況はいくらでもあります。つまり、値の中の全てのサンクを評価したいということですね。言語レベルでこれを制御する方法はありませんが、半分標準の (GHC についてくるということ) ライブラリに &lt;code&gt;deepseq&lt;/code&gt; 関数があります。&lt;code&gt;deepseq&lt;/code&gt; は &lt;code&gt;NFData&lt;/code&gt; 型クラスの &lt;code&gt;rnf&lt;/code&gt; (&lt;strong&gt;r&lt;/strong&gt;educe a value to &lt;strong&gt;n&lt;/strong&gt;ormal &lt;strong&gt;f&lt;/strong&gt;orm) メソッドを使って定義されています。&lt;code&gt;rnf&lt;/code&gt; メソッドは値を正規形に簡約する方法を提供します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb34"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb34-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.DeepSeq&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-3" data-line-number="3"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-4" data-line-number="4"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-5" data-line-number="5"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-6" data-line-number="6"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;NFData&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-8" data-line-number="8"&gt;  rnf (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) &lt;span class="fu"&gt;=&lt;/span&gt; sum &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; count &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-10" data-line-number="10"&gt;&lt;span class="ot"&gt;printAverage ::&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-11" data-line-number="11"&gt;printAverage (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count)&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-12" data-line-number="12"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; count &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; error &lt;span class="st"&gt;&amp;quot;Need at least one value!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-13" data-line-number="13"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="fu"&gt;=&lt;/span&gt; print (fromIntegral sum &lt;span class="fu"&gt;/&lt;/span&gt; fromIntegral&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-15" data-line-number="15"&gt;&lt;span class="co"&gt;-- | A fold would be nicer... we&amp;#39;ll see that later&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-16" data-line-number="16"&gt;&lt;span class="ot"&gt;printListAverage ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-17" data-line-number="17"&gt;printListAverage &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-18" data-line-number="18"&gt;  go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-19" data-line-number="19"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-20" data-line-number="20"&gt;    go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-21" data-line-number="21"&gt;    go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-22" data-line-number="22"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-23" data-line-number="23"&gt;       &lt;span class="kw"&gt;in&lt;/span&gt; rt &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; go rt xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-25" data-line-number="25"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb34-26" data-line-number="26"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; printListAverage [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もう一度言いますが、このプログラムの最大メモリ常駐量は 44kb です。ここでは &lt;code&gt;rnf&lt;/code&gt; を含む　&lt;code&gt;NFData&lt;/code&gt; 型クラスのインスタンスを定義します。単純にデータコンストラクタ中の全ての値を &lt;code&gt;deepseq&lt;/code&gt; するという方法は、&lt;code&gt;NFData&lt;/code&gt; インスタンスを定義するときに良く用いられます。これは常套手段なので、実は &lt;code&gt;Generic&lt;/code&gt; 導出を使うだけで GHC は自動的にインスタンスを定義します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb35"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb35-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Generics&lt;/span&gt; (&lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.DeepSeq&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-5" data-line-number="5"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-6" data-line-number="6"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-7" data-line-number="7"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-8" data-line-number="8"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-9" data-line-number="9"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Generic&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb35-10" data-line-number="10"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;NFData&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;NFData&lt;/code&gt; 型クラスのインスタンスにすることの一番の魅力は、多くのデータ型に対する抽象化の能力です。(ここでやっているように) スペースリークを避けるだけではなく、値の中のサンクに例外が誤って含まれてしまうというようなことも防げます。例として、&lt;a href="https://haskell-lang.org/library/safe-exceptions"&gt;safe-exceptions library&lt;/a&gt; の &lt;a href="https://www.stackage.org/haddock/lts-9.3/safe-exceptions-0.1.6.0/Control-Exception-Safe.html#v:tryAnyDeep"&gt;tryAnyDeep&lt;/a&gt; 関数を見てみてください。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; &lt;code&gt;rnf&lt;/code&gt; と &lt;code&gt;seq&lt;/code&gt; を使って &lt;code&gt;deepseq&lt;/code&gt; を自分で定義してみてください。&lt;/p&gt;
&lt;h4 id="翻訳者追記-1"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;演習の解答例&lt;/p&gt;
&lt;div class="sourceCode" id="cb36"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb36-1" data-line-number="1"&gt;&lt;span class="ot"&gt;deepseq ::&lt;/span&gt; &lt;span class="dt"&gt;NFData&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb36-2" data-line-number="2"&gt;deepseq x y &lt;span class="fu"&gt;=&lt;/span&gt; rnf x &lt;span class="ot"&gt;`seq`&lt;/span&gt; y&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="正格なデータ"&gt;正格なデータ&lt;/h3&gt;
&lt;p&gt;これらのアプローチはうまくいきましたが、最適解ではありません。問題は &lt;code&gt;RunningTotal&lt;/code&gt; の定義に存在します。ここで私たちが考えているのは、&lt;code&gt;RunningTotal&lt;/code&gt; 型の値があるとき、実は2つの &lt;code&gt;Int&lt;/code&gt; が存在しているということです。しかし遅延性のせいで &lt;code&gt;RunningTotal&lt;/code&gt; の値には、2つの &lt;code&gt;Int&lt;/code&gt;、&lt;code&gt;Int&lt;/code&gt; に評価することができるサンク、もしくは例外を投げるサンクを持つことができる、という値を含むことができてしまいます。&lt;/p&gt;
&lt;p&gt;そのため、&lt;code&gt;RunningTotal&lt;/code&gt; の値に遅延性が入りこむ余地を無くしたいものですね。これは、データ型の定義に&lt;em&gt;正格性注釈&lt;/em&gt; (&lt;em&gt;strictness annotations&lt;/em&gt;) をつけることで実現できます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb37"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb37-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; sum ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-4" data-line-number="4"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Generic&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-7" data-line-number="7"&gt;&lt;span class="ot"&gt;printAverage ::&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-8" data-line-number="8"&gt;printAverage (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count)&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-9" data-line-number="9"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; count &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; error &lt;span class="st"&gt;&amp;quot;Need at least one value!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="fu"&gt;=&lt;/span&gt; print (fromIntegral sum &lt;span class="fu"&gt;/&lt;/span&gt; fromIntegral&lt;span class="ot"&gt; count ::&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-12" data-line-number="12"&gt;&lt;span class="co"&gt;-- | A fold would be nicer... we&amp;#39;ll see that later&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-13" data-line-number="13"&gt;&lt;span class="ot"&gt;printListAverage ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-14" data-line-number="14"&gt;printListAverage &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-15" data-line-number="15"&gt;  go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-16" data-line-number="16"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-17" data-line-number="17"&gt;    go rt [] &lt;span class="fu"&gt;=&lt;/span&gt; printAverage rt&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-18" data-line-number="18"&gt;    go (&lt;span class="dt"&gt;RunningTotal&lt;/span&gt; sum count) (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-19" data-line-number="19"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; rt &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RunningTotal&lt;/span&gt; (sum &lt;span class="fu"&gt;+&lt;/span&gt; x) (count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-20" data-line-number="20"&gt;       &lt;span class="kw"&gt;in&lt;/span&gt; go rt xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-22" data-line-number="22"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb37-23" data-line-number="23"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; printListAverage [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;RunningTotal&lt;/code&gt; の定義で &lt;code&gt;Int&lt;/code&gt; の前にバンを置いただけです。他に正格性や評価を指定するようなものはありません。しかし、これらのフィールドに正格性注釈を置くことで、簡単ですが重要なことを言うことができます:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;RunningTotal&lt;/code&gt; 型の値を評価するときは、必ずその中に含まれる2つの &lt;code&gt;Int&lt;/code&gt; も評価しなければならない&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;さきほど説明したように、2つ目の &lt;code&gt;go&lt;/code&gt; は コンストラクタを剥ぎ取ることで、&lt;code&gt;RunningTotal&lt;/code&gt; の値が強制評価されます。前回まではバンパターンを使う必要があった &lt;code&gt;sum&lt;/code&gt; と &lt;code&gt;count&lt;/code&gt; の強制評価が、ここでは自動化されています。&lt;/p&gt;
&lt;p&gt;これ以外のアドバンテージも1つあります。少し話からは脱線しますが、それでも言及しておく価値はあります。 &lt;code&gt;Int&lt;/code&gt; のような小さな値を扱うとき、GHC は正格なフィールドを自動的にアンボックス (&lt;em&gt;unbox&lt;/em&gt;) な型に変換します。これは、&lt;code&gt;RunningTotal&lt;/code&gt; の中で &lt;code&gt;Int&lt;/code&gt; へのポインタを持ち続けるよりも、&lt;code&gt;Int&lt;/code&gt; そのものを持つようになるという意味です。こうすることで、もっとメモリ使用量を減らすことができます。&lt;/p&gt;
&lt;p&gt;こういうすごく良い質問をしてくれるかもしれません: 「自分のデータのフィールドで正格性注釈を使うかべきどうか、どうやったらわかるの?」この回答は少し議論の余地があるかもしれませんが、私のアドバイスとして、ベストプラクティスはフィールドに対して遅延性を持たせたいとき以外は、正格にすることです。フィールドを正格にすることで、以下のようなメリットが得られます:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ここで私たちがやっているように、うっかりスペースリークを起こしてしまうのを避ける&lt;/li&gt;
&lt;li&gt;うっかりボトムの値を含んでしまうのを避ける&lt;/li&gt;
&lt;li&gt;レコード構文で値を生成するとき、正格なフィールドを忘れた時に GHC がエラーを出してくれる。正格ではないフィールドに対しては警告しか出してくれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="newtype-の興味深いケース"&gt;newtype の興味深いケース&lt;/h3&gt;
&lt;p&gt;よく似たデータ型を3つ定義してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb38"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb38-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb38-2" data-line-number="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Bar&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Bar&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb38-3" data-line-number="3"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Baz&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Baz&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ゲームをしましょう。以下のコードを &lt;code&gt;main&lt;/code&gt; 関数に置いたときの出力を推測してみてください。以下の説明を読む前に、それぞれのケースを頭の中で考えてくださいね。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;case undefined of { Foo _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case Foo undefined of { Foo _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case undefined of { Bar _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case Bar undefined of { Bar _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case undefined of { Baz _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case Baz undefined of { Baz _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ケース (1) は比較的単純ですね。データコンストラクタ (&lt;code&gt;Foo&lt;/code&gt;) を1層剥いで、ボトムの値を見つけます。なので、これは例外を投げます。これは (3) にも当てはまります。&lt;/p&gt;
&lt;p&gt;(2) は例外を投げません。&lt;code&gt;Foo&lt;/code&gt; データコンストラクタがあって、それはボトムの値を含んでいます。しかし、&lt;code&gt;Foo&lt;/code&gt; の中の &lt;code&gt;Int&lt;/code&gt; に正格性注釈がないので、&lt;code&gt;Foo&lt;/code&gt; を剥いでも &lt;code&gt;Int&lt;/code&gt; の強制評価は起こらず、例外が投げられることはありません。これとは対照的に、(4) では正格性注釈があるので、&lt;code&gt;Bar&lt;/code&gt; のケースでは例外が投げられます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newtype&lt;/code&gt; はどうでしょう? &lt;code&gt;newtype&lt;/code&gt; について知っていることといえば、実行時表現が無いということでしょうか。ということは、&lt;code&gt;Baz&lt;/code&gt; データコンストラクタがボトムの余分な層を隠すことは不可能です。つまり、&lt;code&gt;Baz undefined&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; を区別することはできません。こう考えると、ぱっと見 &lt;code&gt;Bar&lt;/code&gt; のようになりそうですが、おもしろいことに、そうではないんです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Baz&lt;/code&gt; コンストラクタを剥がすことが実行時の動作になんら影響がないことはわかりますよね? そもそもそこには存在していないんだから。よって、(5) の中のパターンマッチは何の意味もありません。これは &lt;code&gt;case undefined of { _ -&amp;gt; putStrLn &amp;quot;Still alive!&amp;quot; }&lt;/code&gt; と等しくなります。そして &lt;code&gt;undefined&lt;/code&gt; について調べることはない (データコンストラクタではなく、ワイルドカードパターンを使っている) ので、例外が投げられることはありません。&lt;/p&gt;
&lt;p&gt;同様に、ケース (6) でも &lt;code&gt;Baz&lt;/code&gt; コンストラクタを &lt;code&gt;undefined&lt;/code&gt; に適用していますが、実行時表現はないので、これもまた存在しません。なので、ここでも例外が投げられることはありません。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; &lt;code&gt;main = Baz undefined `seq` putStrLn &amp;quot;Still alive!&amp;quot;&lt;/code&gt; の出力はどうなるでしょうか? そうなるのはなぜでしょう?&lt;/p&gt;
&lt;h4 id="翻訳者追記-2"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;演習の解答例: エラーを吐く。&lt;code&gt;seq&lt;/code&gt; によって &lt;code&gt;Baz undefined&lt;/code&gt; 、つまり &lt;code&gt;undefined&lt;/code&gt; が評価されるため。&lt;/p&gt;
&lt;h3 id="便利な演算子と関数"&gt;便利な演算子と関数&lt;/h3&gt;
&lt;p&gt;すでにお気づきかもしれませんが、&lt;code&gt;seq&lt;/code&gt; と &lt;code&gt;deepseq&lt;/code&gt; をあらゆるところで使うのは不都合なことがあります。バンパターンも助けにはなりますが、強制評価を行う方法は他にもあります。おそらく、最も良くに使われているのは &lt;code&gt;$!&lt;/code&gt; 演算子でしょう。例えば、以下のように利用します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb39"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb39-1" data-line-number="1"&gt;&lt;span class="ot"&gt;mysum ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-2" data-line-number="2"&gt;mysum list0 &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-3" data-line-number="3"&gt;  go list0 &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-5" data-line-number="5"&gt;    go [] total &lt;span class="fu"&gt;=&lt;/span&gt; total&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-6" data-line-number="6"&gt;    go (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) total &lt;span class="fu"&gt;=&lt;/span&gt; go xs &lt;span class="fu"&gt;$!&lt;/span&gt; total &lt;span class="fu"&gt;+&lt;/span&gt; x&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb39-8" data-line-number="8"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; mysum [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上の例では、&lt;code&gt;go&lt;/code&gt; 関数の再帰に入る前に &lt;code&gt;total + x&lt;/code&gt; を強制評価しています。結果、スペースリークを防ぐことができます。(演習: 同じことを、バンパターンと &lt;code&gt;seq&lt;/code&gt; 関数を使ってやってみてください。)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$!!&lt;/code&gt; 演算子も同様ですが、&lt;code&gt;seq&lt;/code&gt; ではなく &lt;code&gt;deepseq&lt;/code&gt; を利用しています。そのため、この演算子を使うと正規形に評価されます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb40"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb40-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.DeepSeq&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-3" data-line-number="3"&gt;&lt;span class="ot"&gt;average ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-4" data-line-number="4"&gt;average list0 &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-5" data-line-number="5"&gt;  go list0 (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-7" data-line-number="7"&gt;    go [] (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; fromIntegral total &lt;span class="fu"&gt;/&lt;/span&gt; count&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-8" data-line-number="8"&gt;    go (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; go xs &lt;span class="fu"&gt;$!!&lt;/span&gt; (total &lt;span class="fu"&gt;+&lt;/span&gt; x, count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb40-10" data-line-number="10"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; average [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他にも、いい感じの補助関数に &lt;code&gt;force&lt;/code&gt; というものがあります。これは、対象の式が弱頭部正規形に評価されるとき、実際には正規形に評価します。例えば、上記の &lt;code&gt;go&lt;/code&gt; 関数はこのように書き換えることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb41"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb41-1" data-line-number="1"&gt;go [] (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; fromIntegral total &lt;span class="fu"&gt;/&lt;/span&gt; count&lt;/a&gt;
&lt;a class="sourceLine" id="cb41-2" data-line-number="2"&gt;go (x&lt;span class="fu"&gt;:&lt;/span&gt;xs) (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; go xs &lt;span class="fu"&gt;$!&lt;/span&gt; force (total &lt;span class="fu"&gt;+&lt;/span&gt; x, count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; これらの便利な関数と演算子を、&lt;code&gt;seq&lt;/code&gt; と &lt;code&gt;deepseq&lt;/code&gt; を使って自分で定義してみましょう。&lt;/p&gt;
&lt;h4 id="翻訳者追記-3"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;演習の解答例&lt;/p&gt;
&lt;div class="sourceCode" id="cb42"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb42-1" data-line-number="1"&gt;&lt;span class="ot"&gt;force ::&lt;/span&gt; (&lt;span class="dt"&gt;NFData&lt;/span&gt; a) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb42-2" data-line-number="2"&gt;force x &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="ot"&gt;`deepseq`&lt;/span&gt; x&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="データ構造"&gt;データ構造&lt;/h2&gt;
&lt;p&gt;はい、以上が一番複雑な部分でした。もしもそれら全てを理解していたら、残りは自然に理解できて、より深く理解するための用語を少し導入するだけになります。&lt;/p&gt;
&lt;p&gt;このプログラムの出力はどうなるでしょうか:&lt;/p&gt;
&lt;div class="sourceCode" id="cb43"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb43-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;List&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; a (&lt;span class="dt"&gt;List&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb43-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb43-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; undefined undefined &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;えー、これまでに紹介した原理を使うと、一番外側のコンストラクタがあるので、&lt;code&gt;Cons undefined undefined&lt;/code&gt; は既に弱頭部正規形になっています。なので、このプログラムは例外を吐くことなく “Hello World” と表示します。いいですね。さて、&lt;code&gt;Cons&lt;/code&gt; は &lt;code&gt;:&lt;/code&gt; データコンストラクタと等しいことを思い出してください。そうすると、上記の例はこうなります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb44"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb44-1" data-line-number="1"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; (undefined&lt;span class="fu"&gt;:&lt;/span&gt;undefined) &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ということは、リストは遅延データ構造だということですね。最初の要素はボトムで、残りの要素もボトムです。しかし全体としてはボトムではありません。少し違う例を試してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb45"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb45-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;List&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; a &lt;span class="fu"&gt;!&lt;/span&gt;(&lt;span class="dt"&gt;List&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb45-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb45-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; undefined undefined &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これは顔面で爆発します! 後続のリストが正格だからです。しかし、以下の例は大丈夫です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb46"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb46-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;List&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; a &lt;span class="fu"&gt;!&lt;/span&gt;(&lt;span class="dt"&gt;List&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb46-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb46-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; undefined (&lt;span class="dt"&gt;Cons&lt;/span&gt; undefined &lt;span class="dt"&gt;Nil&lt;/span&gt;) &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このリストの定義では、リストそのものについては詳細の全てを知る必要があります。しかし、値は undefined のままでもいいのです。これは&lt;em&gt;スパイン正格&lt;/em&gt; (&lt;em&gt;spine strict&lt;/em&gt;) と呼ばれています。対照的に、値に対して正格な&lt;em&gt;値正格&lt;/em&gt; (&lt;em&gt;value strict}&lt;/em&gt;) にすることも可能です。やってみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb47"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb47-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;List&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;a &lt;span class="fu"&gt;!&lt;/span&gt;(&lt;span class="dt"&gt;List&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb47-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb47-3" data-line-number="3"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; undefined (&lt;span class="dt"&gt;Cons&lt;/span&gt; undefined &lt;span class="dt"&gt;Nil&lt;/span&gt;) &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これは期待通り、顔面で爆発するでしょう。&lt;/p&gt;
&lt;p&gt;お分かりかもしれませんが、もう1つリストの定義が残っています。値に対して正格で、残りはそうではないものです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb48"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb48-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;List&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;a (&lt;span class="dt"&gt;List&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実際のところ、Haskell このパターンのデータ構造を知りません。よって名前もありません。(もしもこんなデータ構造があって名前があるのなら、教えてください。どんな使われ方をしているのか気になります。)&lt;/p&gt;
&lt;p&gt;なので、通常のリストは遅延リストです。他にもいくつかデータ型を見てみましょう。&lt;/p&gt;
&lt;h3 id="ベクター"&gt;ベクター&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Data.Vector&lt;/code&gt; の中のベクター (&lt;em&gt;ボックスベクター&lt;/em&gt; (&lt;em&gt;boxed vectors&lt;/em&gt;)とも) は、スパイン正格です。&lt;code&gt;import qualified Data.Vector as V&lt;/code&gt; でインポートしたとして、以下のプログラムの結果はどうなるでしょうか?&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;main = V.fromList [undefined] `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main = V.fromList (undefined:undefined) `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main = V.fromList undefined `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最初は成功します。ベクターは完全なスパインとして定義されるからです。そのため、ボトムを含んでいるかどうかは無関係です。2番目は失敗します。後続のリストのスパインが undefined だからです。最後の例も (当然) 失敗します。リスト全体が undefined だからです。&lt;/p&gt;
&lt;p&gt;さて、&lt;em&gt;アンボックスベクター&lt;/em&gt; (&lt;em&gt;unboxed vectors&lt;/em&gt;) についても見てみましょう。推論の都合上、GHC を少し手助けしてやる必要があります。なので、プログラムの先頭に以下のような &lt;code&gt;fromList&lt;/code&gt; が定義されているとしましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb49"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb49-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Vector.Unboxed&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;V&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb49-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb49-3" data-line-number="3"&gt;&lt;span class="ot"&gt;fromList ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;V.Vector&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb49-4" data-line-number="4"&gt;fromList &lt;span class="fu"&gt;=&lt;/span&gt; V.fromList&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この場合はどうなるでしょうか？&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;main = fromList [undefined] `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main = fromList (undefined:undefined) `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main = fromList undefined `seq` putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ご想像の通り、(2) と (3) はボックスベクターのときと同じ動きをします。しかし、(1) も例外を投げるようになります。これは、アンボックスベクターがスパイン正格なだけではなく、値に対しても正格だからです。storable vector と primitive vector も同じ振る舞いをします。&lt;/p&gt;
&lt;p&gt;残念ながら、私の知る限り、公開されているライブラリに正格なボックスベクターは存在しません。そのようなデータ型はスペースリーク対策に役立つと思うんですが (この記事を書くきっかけになった質問のように)。&lt;/p&gt;
&lt;h3 id="set-と-map"&gt;Set と Map&lt;/h3&gt;
&lt;p&gt;containers, unordered-containers パッケージの、Map から始まるモジュールには &lt;code&gt;Strict&lt;/code&gt; と &lt;code&gt;Lazy&lt;/code&gt; (例えば、&lt;code&gt;Data.HashMap.Strict&lt;/code&gt; と &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt;) が用意されているのに対して、Set から始まるモジュールには存在しないことに (&lt;code&gt;Data.IntSet&lt;/code&gt; など) 気がつくと思います 。これは、これら全てのコンテナがスパイン正格で、キーに対して正格でなければならないからです。集合は分離された値を持たず、キーだけ持っているので、値に対して正格でなければいけません。&lt;/p&gt;
&lt;p&gt;それに対してマップはキーと値の両方を持っています。Map.HashMap.Lazy のようなモジュールはスパイン正格ですが、値は遅延です。対して、Map.HashMap.Strict のようなモジュールはスパインと値の両方について正格です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; &lt;code&gt;Data.Sequence.Seq&lt;/code&gt; データ型を調べて、遅延、スパイン正格、値正格のいずれかに分類してみましょう。&lt;/p&gt;
&lt;h4 id="翻訳者追記-4"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;演習の解答例:&lt;/p&gt;
&lt;div class="sourceCode" id="cb50"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb50-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb50-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-11.2 --package containers&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb50-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb50-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Sequence&lt;/span&gt; (fromList)&lt;/a&gt;
&lt;a class="sourceLine" id="cb50-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb50-6" data-line-number="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; fromList [&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;,undefined,&lt;span class="dv"&gt;0&lt;/span&gt;,&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="ot"&gt;`seq`&lt;/span&gt; putStrLn &lt;span class="st"&gt;&amp;quot;Alive!&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これを実行すると &lt;code&gt;Alive!&lt;/code&gt; と表示されるのでスパイン正格。&lt;/p&gt;
&lt;h2 id="関数の引数"&gt;関数の引数&lt;/h2&gt;
&lt;p&gt;関数の引数にボトムの値が適用されたとき、結果がボトムになれば、関数はボトムが与えられた引数に対して正格であると言います。上の例で見たように、&lt;code&gt;Int&lt;/code&gt; に対して &lt;code&gt;+&lt;/code&gt; を適用する場合、 &lt;code&gt;undefined + x&lt;/code&gt; と &lt;code&gt;x + undefined&lt;/code&gt; の結果は両方ともボトムとなるため、&lt;code&gt;+&lt;/code&gt; はどちらの引数に対しても正格です。&lt;/p&gt;
&lt;p&gt;それに対して &lt;code&gt;const a b = a&lt;/code&gt; と定義される &lt;code&gt;const&lt;/code&gt; 関数は、最初の引数に対して正格で、2番目の引数に対しては非正格です。&lt;/p&gt;
&lt;p&gt;リストの &lt;code&gt;:&lt;/code&gt; データコンストラクタは、第1引数と第2引数に対して、どちらも非正格です。しかし、&lt;code&gt;data List a = Cons !a !(List a) | Nil&lt;/code&gt; という定義では、&lt;code&gt;Cons&lt;/code&gt; はどちらの引数に対しても正格になります。&lt;/p&gt;
&lt;h2 id="fold"&gt;Fold&lt;/h2&gt;
&lt;p&gt;遅延性を扱う上でつまづきやすいポイントは、fold です。もっとも悪名高い例は &lt;code&gt;foldl&lt;/code&gt; 関数でしょう。こいつは偽りの安心感をいざない、夢と希望をぶち壊してくれます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb51"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb51-1" data-line-number="1"&gt;&lt;span class="ot"&gt;mysum ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb51-2" data-line-number="2"&gt;mysum &lt;span class="fu"&gt;=&lt;/span&gt; foldl (&lt;span class="fu"&gt;+&lt;/span&gt;) &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb51-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb51-4" data-line-number="4"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb51-5" data-line-number="5"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; mysum [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻訳者追記 (上記プログラムの結果)&lt;/p&gt;
&lt;pre class="plain"&gt;&lt;code&gt;     169,311,296 bytes allocated in the heap
     230,806,408 bytes copied during GC
      53,397,048 bytes maximum residency (8 sample(s))
         903,624 bytes maximum slop
             106 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これは限りなく正解に近いですが、最大メモリ常駐量は 53mb にもなっています! 答えはチョンっとつけて正格な左畳み込み &lt;code&gt;foldl'&lt;/code&gt; 関数を使うことです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb53"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb53-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.List&lt;/span&gt; (foldl&amp;#39;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-3" data-line-number="3"&gt;&lt;span class="ot"&gt;mysum ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-4" data-line-number="4"&gt;mysum &lt;span class="fu"&gt;=&lt;/span&gt; foldl&amp;#39; (&lt;span class="fu"&gt;+&lt;/span&gt;) &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-6" data-line-number="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb53-7" data-line-number="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; mysum [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; はなんでこんな絶対におかしい関数 (&lt;code&gt;foldl&lt;/code&gt;) を提供しているのでしょうか?&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://www.fpcomplete.com/static/hysterical-raisins.jpg" alt="Hysterical Raisins" /&gt;&lt;figcaption&gt;Hysterical Raisins&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;ただ、ほとんど全ての正格であると称している関数は、実際のところ弱頭部正規形に対してのみ正格であることに留意しなければいけません。前の &lt;code&gt;average&lt;/code&gt; 関数の例を見てみると、まだスペースリークがあります:&lt;/p&gt;
&lt;div class="sourceCode" id="cb54"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb54-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.List&lt;/span&gt; (foldl&amp;#39;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-3" data-line-number="3"&gt;&lt;span class="ot"&gt;average ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-4" data-line-number="4"&gt;average &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-5" data-line-number="5"&gt;  divide &lt;span class="fu"&gt;.&lt;/span&gt; foldl&amp;#39; add (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-7" data-line-number="7"&gt;    divide (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; fromIntegral total &lt;span class="fu"&gt;/&lt;/span&gt; count&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-8" data-line-number="8"&gt;    add (total, count) x &lt;span class="fu"&gt;=&lt;/span&gt; (total &lt;span class="fu"&gt;+&lt;/span&gt; x, count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-10" data-line-number="10"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb54-11" data-line-number="11"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; average [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻訳者追記 (上記プログラムの結果)&lt;/p&gt;
&lt;pre class="plain"&gt;&lt;code&gt;     306,654,600 bytes allocated in the heap
     390,431,392 bytes copied during GC
      88,082,496 bytes maximum residency (10 sample(s))
       1,160,496 bytes maximum slop
             181 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;私のアドバイスは、正格なフィールドを持つ補助的なデータ型を使うことです。しかしあなたはそうしたくないかもしれませんし、正規形に評価するような &lt;code&gt;foldl'&lt;/code&gt; がないことにイライラしているかもしれません。そんなあなたに朗報です。&lt;code&gt;force&lt;/code&gt; を使うだけで、簡単に弱頭部正規形へ評価する fold を正規形へ評価する fold にアップグレードすることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb56"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb56-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.List&lt;/span&gt; (foldl&amp;#39;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.DeepSeq&lt;/span&gt; (force)&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-4" data-line-number="4"&gt;&lt;span class="ot"&gt;average ::&lt;/span&gt; [&lt;span class="dt"&gt;Int&lt;/span&gt;] &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-5" data-line-number="5"&gt;average &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-6" data-line-number="6"&gt;  divide &lt;span class="fu"&gt;.&lt;/span&gt; foldl&amp;#39; add (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-8" data-line-number="8"&gt;    divide (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; fromIntegral total &lt;span class="fu"&gt;/&lt;/span&gt; count&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-9" data-line-number="9"&gt;    add (total, count) x &lt;span class="fu"&gt;=&lt;/span&gt; force (total &lt;span class="fu"&gt;+&lt;/span&gt; x, count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-11" data-line-number="11"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb56-12" data-line-number="12"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; average [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;1000000&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻訳者追記 (上記プログラムの結果)&lt;/p&gt;
&lt;pre class="plain"&gt;&lt;code&gt;     240,102,848 bytes allocated in the heap
          54,552 bytes copied during GC
          44,384 bytes maximum residency (2 sample(s))
          21,152 bytes maximum slop
               1 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;腕のいい水道工事業者のように、&lt;code&gt;force&lt;/code&gt; はすぐにリークを止めてくれます!&lt;/p&gt;
&lt;h3 id="ストリーミングデータ"&gt;ストリーミングデータ&lt;/h3&gt;
&lt;p&gt;conduit のようなストリーミングデータライブラリの主張の1つに、メモリ使用量が定数オーダーになる、というものがあります。この主張を聞くと、スペースリークについて心配することなく、こいつとおさらばできるという印象を受けます。しかし、弱頭部正規形 vs 正規形の問題はここでも当てはまります。私の言い分を証明するために、conduit で average をひどいやり方で計算してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb58"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb58-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Conduit&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-3" data-line-number="3"&gt;&lt;span class="ot"&gt;average ::&lt;/span&gt; &lt;span class="dt"&gt;Monad&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ConduitM&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; o m &lt;span class="dt"&gt;Double&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-4" data-line-number="4"&gt;average &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-5" data-line-number="5"&gt;  divide &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; foldlC add (&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-7" data-line-number="7"&gt;    divide (total, count) &lt;span class="fu"&gt;=&lt;/span&gt; fromIntegral total &lt;span class="fu"&gt;/&lt;/span&gt; count&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-8" data-line-number="8"&gt;    add (total, count) x &lt;span class="fu"&gt;=&lt;/span&gt; (total &lt;span class="fu"&gt;+&lt;/span&gt; x, count &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-10" data-line-number="10"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb58-11" data-line-number="11"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; print &lt;span class="fu"&gt;$&lt;/span&gt; runConduitPure &lt;span class="fu"&gt;$&lt;/span&gt; enumFromToC &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;1000000&lt;/span&gt; &lt;span class="fu"&gt;.|&lt;/span&gt; average&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下のコマンドでメモリ使用量を確かめることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb59"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb59-1" data-line-number="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; stack &lt;span class="co"&gt;--resolver lts-9.3 ghc --package conduit-combinators -- Main.hs -O2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb59-2" data-line-number="2"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;./&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="fu"&gt;+&lt;/span&gt;&lt;span class="dt"&gt;RTS&lt;/span&gt; &lt;span class="fu"&gt;-&lt;/span&gt;s&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;翻訳者追記 (上記プログラムの結果)&lt;/p&gt;
&lt;pre class="plain"&gt;&lt;code&gt;     265,361,840 bytes allocated in the heap
     205,193,384 bytes copied during GC
      50,201,912 bytes maximum residency (8 sample(s))
         686,792 bytes maximum slop
              98 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt; 以下のものを使って、このプログラムを定数メモリ使用量で実行してみましょう。&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;force&lt;/code&gt; 関数&lt;/li&gt;
&lt;li&gt;バンパターン&lt;/li&gt;
&lt;li&gt;正格なフィールドを持つカスタムデータ型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="連鎖反応"&gt;連鎖反応&lt;/h2&gt;
&lt;p&gt;この超正格なプログラムをご覧ください。特別な値正格リストデータ型です。私はふんだんにバンパターンを散りばめ、至るところで &lt;code&gt;seq&lt;/code&gt; を呼び出しています。&lt;code&gt;$!&lt;/code&gt; も使ってます。メモリ使用量はどうなるでしょうか?&lt;/p&gt;
&lt;div class="sourceCode" id="cb61"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb61-1" data-line-number="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-2" data-line-number="2"&gt;&lt;span class="co"&gt;-- stack --resolver lts-9.3 script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-5" data-line-number="5"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;StrictList&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;a &lt;span class="fu"&gt;!&lt;/span&gt;(&lt;span class="dt"&gt;StrictList&lt;/span&gt; a) &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-7" data-line-number="7"&gt;&lt;span class="ot"&gt;strictMap ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;StrictList&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;StrictList&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-8" data-line-number="8"&gt;strictMap _ &lt;span class="dt"&gt;Nil&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-9" data-line-number="9"&gt;strictMap f (&lt;span class="dt"&gt;Cons&lt;/span&gt; a list) &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-10" data-line-number="10"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;b &lt;span class="fu"&gt;=&lt;/span&gt; f a&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-11" data-line-number="11"&gt;      &lt;span class="fu"&gt;!&lt;/span&gt;list&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; strictMap f list&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-12" data-line-number="12"&gt;   &lt;span class="kw"&gt;in&lt;/span&gt; b &lt;span class="ot"&gt;`seq`&lt;/span&gt; list&amp;#39; &lt;span class="ot"&gt;`seq`&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; b list&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-14" data-line-number="14"&gt;&lt;span class="ot"&gt;strictEnum ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;StrictList&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-15" data-line-number="15"&gt;strictEnum low high &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-16" data-line-number="16"&gt;  go low&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-17" data-line-number="17"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-18" data-line-number="18"&gt;    go &lt;span class="fu"&gt;!&lt;/span&gt;x&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-19" data-line-number="19"&gt;      &lt;span class="fu"&gt;|&lt;/span&gt; x &lt;span class="fu"&gt;==&lt;/span&gt; high &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; x &lt;span class="dt"&gt;Nil&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-20" data-line-number="20"&gt;      &lt;span class="fu"&gt;|&lt;/span&gt; otherwise &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Cons&lt;/span&gt; x (go &lt;span class="fu"&gt;$!&lt;/span&gt; x &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-22" data-line-number="22"&gt;&lt;span class="ot"&gt;double ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-23" data-line-number="23"&gt;double &lt;span class="fu"&gt;!&lt;/span&gt;x &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-25" data-line-number="25"&gt;&lt;span class="ot"&gt;evens ::&lt;/span&gt; &lt;span class="dt"&gt;StrictList&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-26" data-line-number="26"&gt;evens &lt;span class="fu"&gt;=&lt;/span&gt; strictMap double &lt;span class="fu"&gt;$!&lt;/span&gt; strictEnum &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;1000000&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-27" data-line-number="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-28" data-line-number="28"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-29" data-line-number="29"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-30" data-line-number="30"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; string &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-31" data-line-number="31"&gt;      string&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; evens &lt;span class="ot"&gt;`seq`&lt;/span&gt; string&lt;/a&gt;
&lt;a class="sourceLine" id="cb61-32" data-line-number="32"&gt;  putStrLn string&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;よーく見て、コードをよく読んで、予想してみてください。準備はいいですか? いきましょう。&lt;/p&gt;
&lt;p&gt;翻訳者追記 (上記プログラムの結果)&lt;/p&gt;
&lt;pre class="plain"&gt;&lt;code&gt;          51,912 bytes allocated in the heap
           3,408 bytes copied during GC
          44,504 bytes maximum residency (1 sample(s))
          25,128 bytes maximum slop
               2 MB total memory in use (0 MB lost due to fragmentation)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;メモリ利用量は 44kb です。「なんで!?」と叫びたくなるかもしれません。「100万回正格な &lt;code&gt;Int&lt;/code&gt; のリンクトリストを回しているじゃないか!」ってね。惜しい。このプログラムは &lt;code&gt;evens&lt;/code&gt; の値の評価を強制した直後に、死ぬほど評価を繰り返すでしょう。これは正しい。そして、&lt;code&gt;main&lt;/code&gt; の中の &lt;code&gt;string'&lt;/code&gt; という値の評価を強制した直後に &lt;code&gt;evens&lt;/code&gt; は評価されます。&lt;/p&gt;
&lt;p&gt;しかし、このプログラムはどちらも強制評価が起こることはありません! 注意深く見てみれば、プログラムの最後の行は &lt;code&gt;string&lt;/code&gt; という値を使っています。&lt;code&gt;string'&lt;/code&gt; も &lt;code&gt;evens&lt;/code&gt; も使うことはないんですね。プログラムを実行するとき、GHC は &lt;code&gt;main&lt;/code&gt; 関数によって指定された &lt;code&gt;IO&lt;/code&gt; アクションを実行することにのみ関心を持ちます。そして、その &lt;code&gt;main&lt;/code&gt; は &lt;code&gt;putStrLn string&lt;/code&gt; ということしか言っていないわけです。&lt;/p&gt;
&lt;p&gt;このことの理解は極めて重要です。プログラム中で &lt;code&gt;seq&lt;/code&gt; や &lt;code&gt;deepseq&lt;/code&gt; を使い、好きなだけ評価の連鎖を組み立てることができます。しかし結局は、&lt;code&gt;IO&lt;/code&gt; アクション経由で連鎖の最初に値を評価してやらないと、評価されないサンクが残ったままなのです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演習&lt;/strong&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;code&gt;putStrLn string&lt;/code&gt; を &lt;code&gt;putStrLn string'&lt;/code&gt; にして、メモリ使用量がどうなるか観察してください (終わったら戻してください)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt; のどこかにバンパターンを置くと、メモリ利用量がはね上がります。それはどこでしょう?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;putStrLn string&lt;/code&gt; の行のどこかに &lt;code&gt;seq&lt;/code&gt; を置くと、メモリ利用率が大きくなります。それはどこでしょう?&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="翻訳者追記-5"&gt;翻訳者追記&lt;/h4&gt;
&lt;p&gt;演習の解答例&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string'&lt;/code&gt; の前&lt;/li&gt;
&lt;li&gt;略&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="もっと先に"&gt;もっと先に&lt;/h2&gt;
&lt;p&gt;Sebastian Graf は&lt;a href="http://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html"&gt;このブログ記事を分析する&lt;/a&gt;というタイトルで、素晴らしいブログ記事を書いています。このブログ記事は、正格性のケース毎に GHC がどのように解析、最適化をしているのかというところまでもっと踏み込んだ解説をしています。作者である彼の言葉を引用します。&lt;/p&gt;
&lt;p&gt;「このブログ記事では、スペースリークを防ぐための、コンパイラと連携できるようなより局所的なアプローチを解説したいと思います」&lt;/p&gt;
&lt;p&gt;もしも興味が湧いたのなら、一読してみることをおすすめします。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html</id><title type="text">stack run コマンド</title><updated>2018-06-25T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;先日 stack の master ブランチに &lt;a href="https://github.com/commercialhaskell/stack/pull/3952"&gt;Introduce stack run command line option #3952&lt;/a&gt; がマージされました。とても便利なので紹介したいと思います。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stack run&lt;/strong&gt; コマンドについて簡単に説明するとこんな感じです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cabal run&lt;/strong&gt; の &lt;strong&gt;stack&lt;/strong&gt; バージョンです。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build &amp;amp;&amp;amp; stack exec foo&lt;/code&gt; の短縮形です。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; --version&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="ex"&gt;Version&lt;/span&gt; 1.8.0, Git revision 466da22ce21cddc20323fc2611cd2a2d3cc56ec6 (dirty) &lt;span class="kw"&gt;(&lt;/span&gt;&lt;span class="ex"&gt;5998&lt;/span&gt; commits&lt;span class="kw"&gt;)&lt;/span&gt; &lt;span class="ex"&gt;x86_64&lt;/span&gt; hpack-0.28.2&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;現在の &lt;strong&gt;stack&lt;/strong&gt; の最新バージョンは &lt;strong&gt;1.7.1&lt;/strong&gt; です。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="stack-run-コマンド"&gt;stack run コマンド&lt;/h2&gt;
&lt;p&gt;実際にプロジェクトを作って試してみましょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack new stack-run-test
$ cd stack-run-test&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初回は通常通りビルドが実行され、その後に someFunc が出力されます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack run
Building all executables for `stack-run-test&amp;#39; once. After a successful build of all of them, only specified executables

...

Registering library for stack-run-test-0.1.0.0..
someFunc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2回目以降はビルド結果がキャッシュされているので、ファイルを変更しなれければ再ビルドされることはありません。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack run
someFunc&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stack run&lt;/code&gt; コマンドは &lt;a href="https://github.com/commercialhaskell/stack/issues/233"&gt;Wishlist: stack run #233&lt;/a&gt; によって2015年6月に提案されているので3年越しの実装ということになります。この調子で色々と便利なコマンドが増えると良いですね。&lt;/p&gt;
&lt;p&gt;実行ファイル名の指定を省略できるのは、非常に便利なので僕も使っていこうと思います。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html</id><title type="text">rust-reversi やってみた</title><updated>2018-06-21T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;rust-reversi やってみた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-21" itemprop="datePublished"&gt;
        Jun 21, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Rust.html"&gt;Rust&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;現在，会社の同期と週一で Rust の勉強会をやっていまして，普段は &lt;a href="https://y-yu.github.io/trpl-2nd-pdf/book.pdf"&gt;The Rust Programming Language: 2nd Edition の日本語版&lt;/a&gt; を輪読しているのですが，3月ぐらいにあった &lt;a href="https://internship.cookpad.com/2018/spring/"&gt;Cookpad Spring 1day Internship 2018&lt;/a&gt; の Rust コースの資料が公開されたため，皆でハッカソンしてみました．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/KOBA789/rust-reversi"&gt;KOBA789/rust-reversi: Cookpad Spring 1day Internship 2018 Rust プログラミングコースで使用された講義資料 - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は実際にやってみてのメモ書きです． 主に躓いたとこのメモです．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，ぼくの Rust の経験値は上記の本を17章まで読んだだけで，ほとんど書いたことないですね(輪読は7章，自分で少し先を読んでいる)． あと，&lt;a href="https://github.com/matsubara0507/rust-reversi/tree/reversi-impl"&gt;回答はフォークしてあげてあります&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="躓いたところ"&gt;躓いたところ&lt;/h3&gt;
&lt;p&gt;めちゃくちゃしょーーーーもないところばっかです(笑)&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;固定長配列の map&lt;/li&gt;
&lt;li&gt;パターンマッチの変数&lt;/li&gt;
&lt;li&gt;index の x と y が逆&lt;/li&gt;
&lt;li&gt;既に置いてあるかの検査&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="何を作っているか"&gt;何を作っているか&lt;/h3&gt;
&lt;p&gt;そもそも課題は何かというと，オセロ(リバーシ)です． 試しに実行してみるとこんな感じ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
     Running `target/debug/reversi`
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | | |O|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 2 - 2 W
Turn: Black
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | |X|X|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 4 - 1 W
Turn: White
0) c3
1) c5
2) e3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部一から作れではなく，リポジトリをクローンして &lt;code&gt;src/coord.rs&lt;/code&gt; と &lt;code&gt;src/board.rs&lt;/code&gt; の &lt;code&gt;unimplemented!();&lt;/code&gt; となっている個所の実装を与えるだけ． ご丁寧なことにテストも用意してあるので，&lt;code&gt;cargo test&lt;/code&gt; を実行しまくってオールグリーンになれば出来上がり(たぶん)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，クライアントの同期が &lt;code&gt;unimplemented();&lt;/code&gt; に感動していたので，調子に乗って &lt;a href="https://matthew.brecknell.net/post/hole-driven-haskell/"&gt;Hole driven Programming&lt;/a&gt; について語ってしまった．&lt;/p&gt;
&lt;h3 id="関数が呼べない"&gt;0. 関数が呼べない&lt;/h3&gt;
&lt;p&gt;ゼロ引数関数は &lt;code&gt;xxx.method&lt;/code&gt; はダメで，&lt;code&gt;xxx.method()&lt;/code&gt; しなきゃいけないってのが何度もあった(笑) 普段は Haskell を書いているせいですね．&lt;/p&gt;
&lt;h3 id="固定長配列の-map"&gt;1. 固定長配列の map&lt;/h3&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, &lt;span class="kw"&gt;mut&lt;/span&gt; pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;    ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたときの `Move` を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="co"&gt;/// 戻り値の `Move` には8方向分の `get_flip` の結果が含まれる&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_move(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord) -&amp;gt; Move &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;    &lt;span class="pp"&gt;unimplemented!&lt;/span&gt;();&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とあり&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="kw"&gt;struct&lt;/span&gt; Move &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;    &lt;span class="kw"&gt;pub&lt;/span&gt; pos: Coord,&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;    flips: &lt;span class="op"&gt;[&lt;/span&gt;&lt;span class="dt"&gt;u8&lt;/span&gt;; &lt;span class="dv"&gt;8&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="kw"&gt;const&lt;/span&gt; DIRECTIONS: &lt;span class="op"&gt;[&lt;/span&gt;Coord; &lt;span class="dv"&gt;8&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt; = &lt;span class="op"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;), &lt;span class="co"&gt;//左上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;    Coord(&lt;span class="dv"&gt;0&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//真上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//右上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;),  &lt;span class="co"&gt;//真左&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;),   &lt;span class="co"&gt;//真右&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//左下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;    Coord(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),   &lt;span class="co"&gt;//真下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),   &lt;span class="co"&gt;//右下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;&lt;span class="op"&gt;]&lt;/span&gt;;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なので，&lt;code&gt;move.flips = DIRECTIONS.map (|dir| self.get_flip(piece, pos, dir))&lt;/code&gt; って具合にいけそうだと思ったのだ． しかし，悲しいことに組み込みでは &lt;strong&gt;固定長配列に対するこのような操作はないようだ&lt;/strong&gt;(間違っていたらゴメンナサイ…)． なので結局諦めて for 文を回した…&lt;/p&gt;
&lt;p&gt;何か良い方法があったら教えて欲しい.&lt;/p&gt;
&lt;h3 id="パターンマッチの変数"&gt;2. パターンマッチの変数&lt;/h3&gt;
&lt;p&gt;すごい間抜けな話です．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="co"&gt;///&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="co"&gt;/// * `piece` - 置く石の色&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="co"&gt;/// * `pos` - 石を置く位置&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;&lt;span class="co"&gt;/// * `dir` - ひっくり返せる石を探す方向。`DIRECTIONS` の要素のいずれかが渡される&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, &lt;span class="kw"&gt;mut&lt;/span&gt; pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; opponent = piece.opponent();&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="kw"&gt;mut&lt;/span&gt; cnt = &lt;span class="dv"&gt;0&lt;/span&gt;;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;loop&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" data-line-number="10"&gt;        pos += dir;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" data-line-number="11"&gt;        &lt;span class="kw"&gt;match&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;pos&lt;span class="op"&gt;]&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-12" data-line-number="12"&gt;            &lt;span class="cn"&gt;None&lt;/span&gt;           =&amp;gt; &lt;span class="kw"&gt;return&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-13" data-line-number="13"&gt;            &lt;span class="cn"&gt;Some&lt;/span&gt;(piece)    =&amp;gt; &lt;span class="kw"&gt;return&lt;/span&gt; cnt,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-14" data-line-number="14"&gt;            &lt;span class="cn"&gt;Some&lt;/span&gt;(opponent) =&amp;gt; cnt += &lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-15" data-line-number="15"&gt;        &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-16" data-line-number="16"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-17" data-line-number="17"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とか書いていたが，全然テストが通らない． それもそのはずで &lt;strong&gt;パターンマッチの中の変数は代入になる&lt;/strong&gt; だけで，&lt;code&gt;if self.matrix[target] == Some(piece) { ... }&lt;/code&gt; とは異なる． シャーディングぅぅぅぅぅとか思ったけど，きっと警告出てたよね…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: unreachable pattern
   --&amp;gt; src/board.rs:165:17
    |
165 |                 Some(opponent) =&amp;gt; cnt += 1,
    |                 ^^^^^^^^^^^^^^
    |
    = note: #[warn(unreachable_patterns)] on by default

warning: unused variable: `opponent`
   --&amp;gt; src/board.rs:158:13
    |
158 |         let opponent = piece.opponent();
    |             ^^^^^^^^ help: consider using `_opponent` instead
    |
    = note: #[warn(unused_variables)] on by default

warning: unused variable: `piece`
   --&amp;gt; src/board.rs:164:22
    |
164 |                 Some(piece)    =&amp;gt; return cnt,
    |                      ^^^^^ help: consider using `_piece` instead

warning: unused variable: `opponent`
   --&amp;gt; src/board.rs:165:22
    |
165 |                 Some(opponent) =&amp;gt; cnt += 1,
    |                      ^^^^^^^^ help: consider using `_opponent` instead&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出てたね…&lt;/p&gt;
&lt;h3 id="index-の-x-と-y-が逆"&gt;3. index の x と y が逆&lt;/h3&gt;
&lt;p&gt;普段二重配列とかやんないからさ…&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// ベクトルを表現する構造体&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="kw"&gt;struct&lt;/span&gt; Coord(&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="dt"&gt;i8&lt;/span&gt;, &lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="dt"&gt;i8&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="co"&gt;/// `[]` 演算子のオーバーロード&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="kw"&gt;impl&lt;/span&gt; Index&amp;lt;Coord&amp;gt; &lt;span class="kw"&gt;for&lt;/span&gt; Matrix &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;type&lt;/span&gt; Output = &lt;span class="dt"&gt;Option&lt;/span&gt;&amp;lt;Piece&amp;gt;;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;    &lt;span class="co"&gt;/// 第一引数に与えられた座標の状態を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;    &lt;span class="co"&gt;/// 座標が盤面の範囲外であった場合は None が返る。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;fn&lt;/span&gt; index(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, index: Coord) -&amp;gt; &amp;amp;&lt;span class="kw"&gt;Self&lt;/span&gt;::Output &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;        &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.is_in_range(index) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;            &amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;.&lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="op"&gt;[&lt;/span&gt;index.&lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;usize&lt;/span&gt;&lt;span class="op"&gt;][&lt;/span&gt;index.&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;usize&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;        &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;            &amp;amp;&lt;span class="cn"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;        &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" data-line-number="15"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" data-line-number="16"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とか最初書いていた． &lt;code&gt;Coord&lt;/code&gt; 型はひとつ目が X 座標でふたつ目が Y 座標． &lt;code&gt;&amp;amp;self.0[index.0 as usize][index.1 as usize]&lt;/code&gt; のところが逆ですね…&lt;/p&gt;
&lt;h3 id="既に置いてあるかの検査"&gt;4. 既に置いてあるかの検査&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;moves&lt;/code&gt; のテストが何故かとおらない． &lt;code&gt;moves&lt;/code&gt; は盤上の全ての合法手，“手” を表す &lt;code&gt;Move&lt;/code&gt; 型は手を打つ場所(&lt;code&gt;Coord&lt;/code&gt; 型)と各方向のひっくり返す数を持っている，を列挙する関数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---- board::tests::test_board_moves stdout ----
	thread &amp;#39;board::tests::test_board_moves&amp;#39; panicked at &amp;#39;assertion failed: `(left == right)`
  left: `6`,
 right: `37`&amp;#39;, src/board.rs:366:9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;めちゃくちゃ多い． テストを読んでイロイロと出力させてみたところ，既にピースが置いてある場合のチェックを忘れていた(バカ)．&lt;/p&gt;
&lt;h3 id="オールグリーン"&gt;オールグリーン&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cargo test
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
    Finished dev [unoptimized + debuginfo] target(s) in 1.27 secs
     Running target/debug/deps/reversi-ae2013b8997f878b

running 12 tests
test board::tests::test_board_count_mut ... ok
test board::tests::test_board_get_move ... ok
test board::tests::test_board_get_flip ... ok
test board::tests::test_board_do_move ... ok
test board::tests::test_do_flip ... ok
test board::tests::test_matrix_index ... ok
test board::tests::test_board_moves ... ok
test board::tests::test_matrix_index_mut ... ok
test board::tests::test_matrix_is_in_range ... ok
test board::tests::test_move_is_legal ... ok
test coord::tests::test_coord_add ... ok
test coord::tests::test_coord_add_assign ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="感想"&gt;感想&lt;/h2&gt;
&lt;p&gt;基本構文を覚えてないので，とりあえず雑に書いてビルドして怒られたら直す，的なことをしながら，静的検査さいこ～とか言いながらやってた(疲れてる)． おかげで &lt;code&gt;&amp;amp;&lt;/code&gt; とか &lt;code&gt;*&lt;/code&gt; を雑にあつかってて良くないですね． まぁ楽しかったからいいけど．&lt;/p&gt;
&lt;h2 id="おまけ"&gt;おまけ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;get_flip&lt;/code&gt; 関数のところ，関数型プログラマーらしく(?)再帰にして見た. 速度は変わるんかな？&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;    &lt;span class="kw"&gt;self&lt;/span&gt;.go_get_flip(piece, pos, dir).unwrap_or(&lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; go_get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;Option&lt;/span&gt;&amp;lt;&lt;span class="dt"&gt;u8&lt;/span&gt;&amp;gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; target = pos + dir;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;target&lt;span class="op"&gt;]&lt;/span&gt; == &lt;span class="cn"&gt;Some&lt;/span&gt;(piece.opponent()) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;        &lt;span class="kw"&gt;self&lt;/span&gt;.go_get_flip(piece, target, dir).map(|x| x + &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;    &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;target&lt;span class="op"&gt;]&lt;/span&gt; == &lt;span class="cn"&gt;Some&lt;/span&gt;(piece) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;        &lt;span class="cn"&gt;Some&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;    &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;        &lt;span class="cn"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;Haskell 版でも作ってみようかしらん．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html</id><title type="text">Earlang ＆ Elixir Fest 2018 に参加してきた</title><updated>2018-06-18T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Earlang ＆ Elixir Fest 2018 に参加してきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-18" itemprop="datePublished"&gt;
        Jun 18, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先日(6/16)，&lt;a href="https://elixir-fest.jp/"&gt;Earlang &amp;amp; Elixir Fest 2018&lt;/a&gt; に参加してきたので，そのメモ書きです． ちなみに，Elixir は普段たいして使ってないけど LT もしてきました．&lt;/p&gt;
&lt;h4 id="追記2018.06.21"&gt;追記(2018.06.21)&lt;/h4&gt;
&lt;p&gt;本稿公開後に公開してくださった発表スライドのリンクを追記しました．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;今年で2回目らしく，去年は Elixir の作者の &lt;a href="https://twitter.com/josevalim"&gt;Jose Valim&lt;/a&gt; 氏を呼んで Keynote してもらい，全体のセッション内容としては Elixir を導入し始めた・挑戦中という話がメインだったようだ． 今年はどっちかっていうとプロダクトに実践導入・運用してみてどうだったかという話がメインだそうだ． また，並行してハンズオンがあったらしいが，行ってないのでそっちは良く分からない． ハンズオンの資料は GitHub に公開してあるので，いずれやってみたい(同期とかとハンズオンしてみてもいいかも)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ohr486/ErlangElixirFestHandsOn"&gt;ohr486/ErlangElixirFestHandsOn - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あと &lt;a href="https://togetter.com/li/1238110"&gt;Togetter にまとめてみました&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="メモ"&gt;メモ&lt;/h2&gt;
&lt;p&gt;各企業での導入した話が多かったので簡単なメモばっかです．&lt;/p&gt;
&lt;h4 id="らくらく連絡網が-elixir-でリアルタイムメッセージング基盤を刷新した話"&gt;「らくらく連絡網」が Elixir でリアルタイムメッセージング基盤を刷新した話&lt;/h4&gt;
&lt;p&gt;(ネットワーク設定にバタバタしてたのでメモが少ない)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/rinosamakanata"&gt;rinosamakanata&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eole-repos.github.io/public/elixirfest/2018/elixirfest2018-eole-rinosamakanata.pdf"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;もともとは RoR らしい&lt;/li&gt;
&lt;li&gt;技術的課題
&lt;ul&gt;
&lt;li&gt;分散の問題&lt;/li&gt;
&lt;li&gt;長い目で見たときの保守・運用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;フロントエンドは Elm
&lt;ul&gt;
&lt;li&gt;「関数型良いよね」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;負荷テストのために不可掛けの Docker コンテナを作った&lt;/li&gt;
&lt;li&gt;Elixir のバージョンアップが多い(リリースしてから9回もあった)
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/asdf-vm/asdf-elixir"&gt;asdf&lt;/a&gt; で難なく&lt;/li&gt;
&lt;li&gt;Ruby や RoR よりぜんぜん簡単&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;実質的にメンテナンスフリー&lt;/li&gt;
&lt;li&gt;Erlang は書けなくても導入できる
&lt;ul&gt;
&lt;li&gt;ただし BEAM の知識はいる&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/happi/theBeamBook"&gt;The BEAM Book&lt;/a&gt; おすすめ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近 Ruby や Ruby のライブラリのバージョンアップで苦しんでいるのを見てたのでバージョンアップがシームレスなの羨ましい．&lt;/p&gt;
&lt;h4 id="初めてのerlangサーバ開発と運用"&gt;初めてのErlangサーバ開発と運用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mookjp"&gt;mookjp&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/mookjp/chu-metefalseerlangsahakai-fa-toyun-yong?slide=1"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Erlang をどう勉強したかや失敗談などの話&lt;/li&gt;
&lt;li&gt;Node.js から Erlang へ (たぶん)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://erlang.org/doc/man/observer.html"&gt;observer&lt;/a&gt; という Erlang プロセスの可視化ツールが便利&lt;/li&gt;
&lt;li&gt;Erlang サーバーをプロダクションに導入するときの設定
&lt;ul&gt;
&lt;li&gt;思想の記事ばっか！&lt;/li&gt;
&lt;li&gt;実際の設定に関する記事が少ない！！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不必要なプロセスやその監視プロセスが微妙に残ってじわじわ CPU 使用率が上がってしまった&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.erlang-in-anger.com/"&gt;Erlang in Anger&lt;/a&gt; を絶対に読む
&lt;ul&gt;
&lt;li&gt;運用に役立ちそうなことがたくさん書いてある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://erlang-slack.herokuapp.com/"&gt;Erlang の Slack ワークスペース&lt;/a&gt;がおススメ！
&lt;ul&gt;
&lt;li&gt;紹介した監視の VMStats もここで教えてもらった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思想の記事が多い話，なんとなく Haskell にも似たようなところがあって笑った&lt;/p&gt;
&lt;h4 id="keep-phoenix-app-productivity"&gt;Keep Phoenix App Productivity&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/kanmo_ak"&gt;kanmo_ak&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/kanmo/keep-phoenix-app-productivity?slide=1"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Phoenix Application 開発1年・運用1年してみた結果の話&lt;/li&gt;
&lt;li&gt;&lt;a href="https://elixirschool.com/en/lessons/advanced/umbrella-projects/"&gt;Umbrella&lt;/a&gt; によって Project を分割
&lt;ul&gt;
&lt;li&gt;肥大化してきた&lt;/li&gt;
&lt;li&gt;複数のサービスをひとつのリポジトリで別々に開発&lt;/li&gt;
&lt;li&gt;サービス間でコードを共有できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ひとつのファイルを書き換えるだけでコンパイル対象が膨大…
&lt;ul&gt;
&lt;li&gt;ファイル間の依存関係がひどいので切っていく&lt;/li&gt;
&lt;li&gt;マクロを変更するとやり直し&lt;/li&gt;
&lt;li&gt;構造体を変更するとやばい&lt;/li&gt;
&lt;li&gt;プロトコルも依存がある&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hexdocs.pm/mix/Mix.Tasks.Xref.html"&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; タスクが便利&lt;/li&gt;
&lt;li&gt;モジュール名を動的に組み立てて依存を無理やり切る黒魔術(使わない方がいい)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang プロセスだと remsh で起動中のプロセスに接続して調査できる&lt;/li&gt;
&lt;li&gt;Elixir バージョンアップは追いやすい
&lt;ul&gt;
&lt;li&gt;RoR に比べて(笑)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Type Spec を書いておくとドキュメントになる
&lt;ul&gt;
&lt;li&gt;Dializer は使ってない(時間が無かった)&lt;/li&gt;
&lt;li&gt;spec ないとつらいと感じたの私自身です&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;昔 Type Spec が書いてあったが間違ってるおかげで痛い目にあったので書いたやつを静的にチェックしたいですよね…&lt;/p&gt;
&lt;h4 id="from-python-to-elixir"&gt;from Python to Elixir&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kenichirow"&gt;kenichirow&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;Python から Elixir に移行
&lt;ul&gt;
&lt;li&gt;Python 2020 年問題(2系のサポートが終わる)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Phoenix は最初は使わないつもりだった
&lt;ul&gt;
&lt;li&gt;Django からだと暗黙的な何某が多い印象(マクロ)&lt;/li&gt;
&lt;li&gt;PubSub いらない&lt;/li&gt;
&lt;li&gt;なので自作 FW を作ってた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;突然 Phoenix 宣言
&lt;ul&gt;
&lt;li&gt;「お前 Dis れるほど Phoenix 知ってるのかよ」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ecto にはいくつかの問題&lt;/li&gt;
&lt;li&gt;なのでライブラリを作った &lt;a href="https://github.com/gumi/yacto"&gt;Yacto&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;DB分割・XAトランザクションなど&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各ゲームの基盤を Template にしていたがバージョン管理がつらいのでライブラリに&lt;/li&gt;
&lt;li&gt;Elixir のサポートチーム
&lt;ul&gt;
&lt;li&gt;ググる前に聞け&lt;/li&gt;
&lt;li&gt;最近しんどいので Stack Overflow Team を導入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語変えて解決した問題は少しだけ
&lt;ul&gt;
&lt;li&gt;ただ整備するきっかけにはなった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基盤チームカッコいい&lt;/p&gt;
&lt;h4 id="ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる"&gt;ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ne-sachirou"&gt;さっちゃん&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/ne_sachirou/sutetohurudeda-gui-mo-akusesufalsearusoft-realtimenagemusabawoeasynitukuru"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Phoenix でゲーム作って運用したはなし&lt;/li&gt;
&lt;li&gt;AWS + Kube + Phoenix&lt;/li&gt;
&lt;li&gt;Real time PvP がメインなのに RoR は大変&lt;/li&gt;
&lt;li&gt;どっちみちイロイロ知見が無いので新しい技術使っても苦労はするでしょ
&lt;ul&gt;
&lt;li&gt;Elixir の知見はある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hexdocs.pm/inner_cotton/readme.html"&gt;InnerCotton&lt;/a&gt; を作った&lt;/li&gt;
&lt;li&gt;FP は知ってた&lt;/li&gt;
&lt;li&gt;Channel と Redis で PvP&lt;/li&gt;
&lt;li&gt;ホットデプロイはあきらめた&lt;/li&gt;
&lt;li&gt;優先度付きキューを自作 &lt;a href="https://hex.pm/packages/pqueue2"&gt;queue2&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;既存のモノは間違ってるものが多かったので&lt;/li&gt;
&lt;li&gt;スタックになっているものもあった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hub.docker.com/r/nesachirou/elixir/"&gt;docker image&lt;/a&gt; を作った(Elixir と Erlang の両方が指定できる)&lt;/li&gt;
&lt;li&gt;Elixir の監視つらい&lt;/li&gt;
&lt;li&gt;もっと publish していこうぜ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;社内でやったことドンドン Publish できるのいいなぁ．&lt;/p&gt;
&lt;h4 id="channel先生-pubsubがしたいです"&gt;Channel先生…!! PubSubがしたいです…&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ohr486"&gt;ohrdev&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/ohr486/erlangelixirfest2018-ohr486-session"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;~Erlang in Anger~ PubSub in Channel&lt;/li&gt;
&lt;li&gt;「PubSub しない Phoenix はただの Rails だ」&lt;/li&gt;
&lt;li&gt;Phoenix Channel + PubSub&lt;/li&gt;
&lt;li&gt;PubSub は2種類ある
&lt;ul&gt;
&lt;li&gt;ローカル PubSub ・リモート PubSub&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「これカッコよくないっすか、見るたびにすごいぞくぞくする」&lt;/li&gt;
&lt;li&gt;PubSub バックエンドは選択できる&lt;/li&gt;
&lt;li&gt;どれだけ知っといた方がいいか？
&lt;ul&gt;
&lt;li&gt;基本は知らなくても&lt;/li&gt;
&lt;li&gt;新しい Adaptar を作る場合は知ってないといけない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PubSub 完全に理解した(嘘)&lt;/p&gt;
&lt;h4 id="antikythera-framework-an-elixir-framework-for-multiple-web-services"&gt;Antikythera Framework: An Elixir framework for multiple web services&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/skirino"&gt;skirino&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://skirino.github.io/slides/antikythera_framework.html#/"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;社内で作ったフレームワークの紹介 : &lt;a href="https://github.com/access-company/antikythera"&gt;antikythera&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Antikythera メカニズム
&lt;ul&gt;
&lt;li&gt;ギリシャ時代のオーパーツ&lt;/li&gt;
&lt;li&gt;なにかよくわからない&lt;/li&gt;
&lt;li&gt;星の動き？？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;複数のサービスをひとつのフレームワークで管理&lt;/li&gt;
&lt;li&gt;Gear : Webサービスの単位・他の Gear に依存しうる
&lt;ul&gt;
&lt;li&gt;instance より細かい単位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コア機能
&lt;ul&gt;
&lt;li&gt;リソースコントロール&lt;/li&gt;
&lt;li&gt;自動オペレーション(ホットデプロイなど)&lt;/li&gt;
&lt;li&gt;ログなどビルドインに&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Gear はマイクロサービスで疎結合だが管理は統一&lt;/li&gt;
&lt;li&gt;リソース管理は ErlangVM なので一長一短&lt;/li&gt;
&lt;li&gt;DB はどうするか？
&lt;ul&gt;
&lt;li&gt;DB は知らない(Gear にしない)&lt;/li&gt;
&lt;li&gt;ふつうに Ecto とかで&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;なぜ Erlang じゃないか？
&lt;ul&gt;
&lt;li&gt;mix が優秀&lt;/li&gt;
&lt;li&gt;mix compiler でフックできる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mix すごいのはよくわかる．&lt;/p&gt;
&lt;h4 id="任意のbeam系言語でプラグインを書ける安定したフレームワークの作りかた"&gt;任意のBEAM系言語でプラグインを書ける安定したフレームワークの作りかた&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/niku"&gt;niku&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://niku.name/2018/06/16/slide.html"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BEAM系プラグインを作る上でのノウハウ&lt;/li&gt;
&lt;li&gt;また PubSub の話ですいません&lt;/li&gt;
&lt;li&gt;フレームワークとプラグイン&lt;/li&gt;
&lt;li&gt;プラグイン機構を持つ FW には登場人物が3人
&lt;ul&gt;
&lt;li&gt;フレームワークとプラグインを使う人&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プラグインでエラーが起きたときフレームワークはどうするか&lt;/li&gt;
&lt;li&gt;「絵にかくとこんな感じ」&lt;/li&gt;
&lt;li&gt;Supervisor は他の言語ではあまりない
&lt;ul&gt;
&lt;li&gt;こいつのおかげで別粒度間のプロセス管理が楽&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ゆかいに学ぼうの Supervisor の章は良くできている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;絵に書くとこんな感じってのがじわじわ来る．&lt;/p&gt;
&lt;h4 id="erlang-事例紹介-メディアストリーム中継システム"&gt;Erlang 事例紹介: メディアストリーム中継システム&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/amutake"&gt;amutake&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://niconare.nicovideo.jp/watch/kn3115"&gt;発表スライドはコチラ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;ニコニコのスライド置き場あったんだ(笑)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ニコ生で使われる(予定)のシステムの話(Erlang 製)&lt;/li&gt;
&lt;li&gt;生放送の中継ツリー&lt;/li&gt;
&lt;li&gt;生放送に求められる性質&lt;/li&gt;
&lt;li&gt;ストリーム中継システム : sluicegate の作成
&lt;ul&gt;
&lt;li&gt;いつか OSS になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;学術的に研究されたアルゴリズム(独自ではなく)
&lt;ul&gt;
&lt;li&gt;HyParView&lt;/li&gt;
&lt;li&gt;Plumtree&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;簡単にできるけど無駄にメッセージパッシングすると遅くなる
&lt;ul&gt;
&lt;li&gt;軽い処理をメッセージパッシングするとだめ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang クラスタは組まない&lt;/li&gt;
&lt;li&gt;Plumtree の性質があれだった
&lt;ul&gt;
&lt;li&gt;なので自分たちで改造&lt;/li&gt;
&lt;li&gt;根幹なので定理証明(Coq で実装)
&lt;ul&gt;
&lt;li&gt;PPLにて発表した&lt;/li&gt;
&lt;li&gt;生放送ストリーム中継システムのCoqによる形式化と検証&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ぱぶさぶくん(検証ツール)&lt;/li&gt;
&lt;li&gt;水道局(可視化ツール)
&lt;ul&gt;
&lt;li&gt;水路という自作ライブラリを使っている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分散アルゴリズムを書きやすい&lt;/li&gt;
&lt;li&gt;調査しやすい
&lt;ul&gt;
&lt;li&gt;reduction の取得のしやすさは Erlang in Anger&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Coq のコードから Erlang に変換するものがある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんか研究の話聞いてるみたいで聞きやすかった(笑)&lt;/p&gt;
&lt;h3 id="lt"&gt;LT&lt;/h3&gt;
&lt;p&gt;自分も LT したので細かいメモは無い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NOC の話
&lt;ul&gt;
&lt;li&gt;朝にアクシデントがあったようで…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;個人で Elixir してきた話(日本一 Elixir 本を書いている)&lt;/li&gt;
&lt;li&gt;Elixir 完全に理解した(ちょっとできる人がいればいい)&lt;/li&gt;
&lt;li&gt;Elixir Programming with Type checking (自分)&lt;/li&gt;
&lt;li&gt;ElixirScript の話&lt;/li&gt;
&lt;li&gt;PubSub Redis
&lt;ul&gt;
&lt;li&gt;phoenix_pubusu_redis_z&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dialyzer のすすめ&lt;/li&gt;
&lt;li&gt;Erlang on ARM サーバー
&lt;ul&gt;
&lt;li&gt;未発表のもの&lt;/li&gt;
&lt;li&gt;秒間40まんリクエストをさばいてる&lt;/li&gt;
&lt;li&gt;ミドルウェアの世界に来い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやら MVP は「Elixirを2週間で完全に理解した」新卒の子．&lt;/p&gt;
&lt;h3 id="keynote"&gt;Keynote&lt;/h3&gt;
&lt;h4 id="共有からメッセージパッシングへ-erlangotpやelixirと歩んだこの10年"&gt;共有からメッセージパッシングへ: Erlang/OTPやElixirと歩んだこの10年&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/jj1bdx"&gt;力武健次&lt;/a&gt;氏&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jj1bdx/erlang-and-elixir-fest-2018-keynote?slide=1"&gt;発表資料はコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BIND ??? 脆弱性の多い DNS サーバーについて昔やってた
&lt;ul&gt;
&lt;li&gt;1000行マクロ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang に出会う
&lt;ul&gt;
&lt;li&gt;うるう秒の修正パッチを送る&lt;/li&gt;
&lt;li&gt;SSH のセキュリティの研究&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ICFP’11 の Erlang Workshop の実行委員長&lt;/li&gt;
&lt;li&gt;Erlang in Anger のサイン本もらった&lt;/li&gt;
&lt;li&gt;Elixir のロゴは商標登録されている&lt;/li&gt;
&lt;li&gt;Catalyze Changes
&lt;ul&gt;
&lt;li&gt;Erlang は読みにくい！&lt;/li&gt;
&lt;li&gt;レコードが難しい！&lt;/li&gt;
&lt;li&gt;ドキュメントがない！&lt;/li&gt;
&lt;li&gt;何とかっしようぜ！&lt;/li&gt;
&lt;li&gt;by Dave Tomas&lt;/li&gt;
&lt;li&gt;大変だった…(jose)&lt;/li&gt;
&lt;li&gt;有言実行しててElixir本を7冊も出版している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ruby コミュニティをちらほら見かけるようになった&lt;/li&gt;
&lt;li&gt;2018/2 大事件&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codesync.global/conferences/code-beam-sf-2018/"&gt;Code BEAM 2018&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Open Erlang 20周年&lt;/li&gt;
&lt;li&gt;BEAM コミュニティの融合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;共通してどこがおいしいのか&lt;/li&gt;
&lt;li&gt;Immutability ディープコピー 参照を使わない
&lt;ul&gt;
&lt;li&gt;自分が思う Erlang のすばらしさ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;従来は実態を共有(はやい？)&lt;/li&gt;
&lt;li&gt;「安全よりも効率」&lt;/li&gt;
&lt;li&gt;C++ の愚痴
&lt;ul&gt;
&lt;li&gt;参照なの？値なの？&lt;/li&gt;
&lt;li&gt;const の話が大変&lt;/li&gt;
&lt;li&gt;コンストラクタいつ動く？？&lt;/li&gt;
&lt;li&gt;shared_ptr と unique_ptr (参照カウンタと所有権)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;例外: ETSやプロセス辞書&lt;/li&gt;
&lt;li&gt;「効率より安全」
&lt;ul&gt;
&lt;li&gt;とても遅い&lt;/li&gt;
&lt;li&gt;型検査は無いけど非常に厳格&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Joe (Erlang の作者)「processes messgae and links が重要な部分(gen_server は後から)」
&lt;ul&gt;
&lt;li&gt;他はどうでもいい&lt;/li&gt;
&lt;li&gt;軽量並行プロセスとエラーハンドリング&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;綺麗に落とすのは大変
&lt;ul&gt;
&lt;li&gt;プロセスキューが詰まると終了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;link and monitor
&lt;ul&gt;
&lt;li&gt;昔のSDの自分の記事を読み返した&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;今後
&lt;ul&gt;
&lt;li&gt;基本理念 「ほどほどなのが一番良い」&lt;/li&gt;
&lt;li&gt;手を抜かずに高速化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Code BEAM で話題にあがったもの
&lt;ul&gt;
&lt;li&gt;組込み分野えの応用&lt;/li&gt;
&lt;li&gt;大規模クラスタ&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/josefs/Gradualizer"&gt;Gradual Type System&lt;/a&gt; (ツールの発表があった)&lt;/li&gt;
&lt;li&gt;Language Server Protcol&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;英語圏で発表しよう
&lt;ul&gt;
&lt;li&gt;Code BEAM 2018 は日本人一人&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クライアントの同期の子が，不変性のすばらしさの話を指して「Rust や Elixir を勉強したとに同じことを感じた！」と喜んでいた．&lt;/p&gt;
&lt;h2 id="自分の話"&gt;自分の話&lt;/h2&gt;
&lt;p&gt;Elchemy の紹介話をしてきました． スライドはこちら&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/ocbuQdsbw2EmG5" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;実は前日(6/15)に別の LT で Elchemy の Docker image を作る話をしてきた． その時のスライドはこちら．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/al30fSfPGB5HGN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;h2 id="section-4"&gt;&lt;/h2&gt;
&lt;p&gt;実は以下の記事でもっと詳しくまとめてあるので，プレゼンを見る必要は無いんです(笑)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"&gt;Elchemy 入門 : その１&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html"&gt;Elchemy 入門 : その２&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;来年はもっと型のハナシができるといいなぁ．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html</id><title type="text">Elchemy 入門 : その２</title><updated>2018-06-16T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Elchemy 入門 : その２&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-16" itemprop="datePublished"&gt;
        Jun 16, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elchemy.html"&gt;Elchemy&lt;/a&gt; &lt;a href="/tags/Elm.html"&gt;Elm&lt;/a&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;Elm から Elixir のトランスパイラ，&lt;a href="https://github.com/wende/elmchemy"&gt;Elchemy&lt;/a&gt; についてイロイロと調べたのでまとめていきます． &lt;a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"&gt;前回はコチラ&lt;/a&gt;． 今回は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-2-our-own-rpg-character-module-cedbf7da138d"&gt;Tutorial その２&lt;/a&gt;をやってみた&lt;/li&gt;
&lt;li&gt;Phoenix で ToDo アプリを作る&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の2本立てです． ちなみに，現在のバージョンは 0.7.4 です．&lt;/p&gt;
&lt;h2 id="tutorial-そのをやってみた"&gt;Tutorial その２をやってみた&lt;/h2&gt;
&lt;p&gt;Tutorial その２では Elchemy を利用した独自ライブラリを作成する． 以下の手順で行うそうだ．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;エイリアス型を定義&lt;/li&gt;
&lt;li&gt;ユニオン型を定義&lt;/li&gt;
&lt;li&gt;関数としてエイリアスやタグを用いる&lt;/li&gt;
&lt;li&gt;ユニオン型でのパターンマッチ&lt;/li&gt;
&lt;li&gt;関数として演算子を使う・独自の演算子を定義する&lt;/li&gt;
&lt;li&gt;別のモジュールから型やエイリアス型をインポートする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本的に Elm の書き方講座みたいなものなので，最悪っ困ったら Elm を勉強してください(丸投げ)． ちなみに，元記事の全てを細かく追従せず，ざっくりと掻い摘んで書き出している． なので細かくは元記事を読んでね．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;あと，&lt;a href="https://github.com/wende/elmchemy-article-example"&gt;このコードは全て作者さんが GitHub に挙げている&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="その前に"&gt;その前に&lt;/h3&gt;
&lt;p&gt;テストを書こう，ということでテストを Elixir で書いている． 今回の作成するライブラリはどうやら，ゲームか何かのキャラを制御する物らしい&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="co"&gt;# character_test.exs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;CharacterTest&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ExUnit&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;  test &lt;span class="st"&gt;&amp;quot;Character has name, last name and such&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;      gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;name &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;surname &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;gender &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;:male&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;  test &lt;span class="st"&gt;&amp;quot;Has stats&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;    stats &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="va"&gt;:strength&lt;/span&gt;, &lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="va"&gt;:vitality&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;    &lt;span class="kw"&gt;for&lt;/span&gt; s &lt;span class="op"&gt;&amp;lt;-&lt;/span&gt; stats &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;      assert is_integer(gordon&lt;span class="op"&gt;.&lt;/span&gt;stats[s]), &lt;span class="st"&gt;&amp;quot;No &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;s&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt; stat in &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;inspect gordon&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;    &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;    assert &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;stats&lt;span class="op"&gt;.&lt;/span&gt;vitality &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;  test &lt;span class="st"&gt;&amp;quot;Boosting visality boosts health&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;    { hp, packed_gordon_max } &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;health&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" data-line-number="29"&gt;    { _, weak_gordon_max }    &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;health&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" data-line-number="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-31" data-line-number="31"&gt;    assert packed_gordon_max &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; weak_gordon_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-32" data-line-number="32"&gt;    assert hp &lt;span class="op"&gt;==&lt;/span&gt; packed_gordon_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-33" data-line-number="33"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-34" data-line-number="34"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-35" data-line-number="35"&gt;  test &lt;span class="st"&gt;&amp;quot;Can equip weapon only if intelligence is enough&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-36" data-line-number="36"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-37" data-line-number="37"&gt;    weapon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Weapon&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Sci fi blaster thingy&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;9&lt;/span&gt; ,&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-38" data-line-number="38"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-39" data-line-number="39"&gt;    dumb_gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-40" data-line-number="40"&gt;    smart_gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-41" data-line-number="41"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-42" data-line-number="42"&gt;    assert {&lt;span class="va"&gt;:error&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Too dumb&amp;quot;&lt;/span&gt;} &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;equip(weapon, dumb_gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-43" data-line-number="43"&gt;    assert {&lt;span class="va"&gt;:ok&lt;/span&gt;, equipped_gordon} &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;equip(weapon, smart_gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-44" data-line-number="44"&gt;    assert equipped_gordon&lt;span class="op"&gt;.&lt;/span&gt;arm &lt;span class="op"&gt;==&lt;/span&gt; {weapon}&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-45" data-line-number="45"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-46" data-line-number="46"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="キャラクターを定義"&gt;キャラクターを定義&lt;/h3&gt;
&lt;h4 id="型エイリアス"&gt;1. 型エイリアス&lt;/h4&gt;
&lt;p&gt;関数型なのでまずはドメインモデルの型を定義する． テストより，&lt;code&gt;name&lt;/code&gt; &lt;code&gt;surname&lt;/code&gt; &lt;code&gt;gender&lt;/code&gt; をフィールドとして持っているのが分かるので次のような型を定義した．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Character exposing (..)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;何故エイリアスなのかというと，構造的サブタイピイングが出来るようにだと思う(たぶん)．&lt;/p&gt;
&lt;h4 id="ユニオン型"&gt;2. ユニオン型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Gender&lt;/code&gt; 型が無いので定義する． こっちは列挙型みたいなのが欲しいので、ユニオン型を用いる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type Gender
    = Male
    | Female
    | Other&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="関数としての型エイリアス"&gt;3. 関数としての型エイリアス&lt;/h4&gt;
&lt;p&gt;Elixir っぽい &lt;code&gt;new&lt;/code&gt; 関数を定義してやろう． Elm の場合，エイリアス型を定義すれば同名の値コンストラクタができるので，それをラップすればよい&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="キャラクターにステータスを持たせる"&gt;キャラクターにステータスを持たせる&lt;/h3&gt;
&lt;p&gt;キャラクターにいくつかのステータスを持たせよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    }

type alias Stats =
    { strength : Int
    , intelligence : Int
    , vitality : Int
    }

new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;health&lt;/code&gt; はどうやら HP みたいなものらしい(現在のHPと上限)．&lt;/p&gt;
&lt;h3 id="パターンマッチ"&gt;4. パターンマッチ&lt;/h3&gt;
&lt;p&gt;ステータスを更新する関数を定義しよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type Stat
    = Strength
    | Intelligence
    | Vitality

setStat : Stat -&amp;gt; Int -&amp;gt; Character -&amp;gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        Strength -&amp;gt;
            { character | stats = { stats | strength = value } }
        Intelligence -&amp;gt;
            { character | stats = { stats | intelligence = value } }
        Vitality -&amp;gt;
            { character | stats = { stats | vitality = value } }        &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;残念ながらこの &lt;code&gt;setStat&lt;/code&gt; は正しくない． テストを見ればわかるが &lt;code&gt;Vitality&lt;/code&gt; を更新した場合は &lt;code&gt;health&lt;/code&gt; も更新する必要がある．&lt;/p&gt;
&lt;h4 id="演算子"&gt;5. 演算子&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;health&lt;/code&gt; はタプル型だ． タプルの更新をいい感じにするために，カスタム演算子を定義してみよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;(&amp;lt;$) : (a, b) -&amp;gt; (a -&amp;gt; c) -&amp;gt; (c, b)
(&amp;lt;$) tuple f = Tuple.mapFirst f tuple

($&amp;gt;) : (a, b) -&amp;gt; (b -&amp;gt; c) -&amp;gt; (a, c)
($&amp;gt;) tuple f = Tuple.mapSecond f tuple&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを使って &lt;code&gt;setStat&lt;/code&gt; の &lt;code&gt;Vitality&lt;/code&gt; の部分を正しく修正する．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;setStat : Stat -&amp;gt; Int -&amp;gt; Character -&amp;gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        ...
        Vitality -&amp;gt;
            { character
                | stats = { stats | vitality = value }
                , health =
                    character.health
                      &amp;lt;$ (+) ((value - stats.vitality) * 10)
                      $&amp;gt; always (100 + 10 * value)
            }                &lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ウェポンを持たせる"&gt;ウェポンを持たせる&lt;/h3&gt;
&lt;h4 id="インポート"&gt;インポート&lt;/h4&gt;
&lt;p&gt;新しく &lt;code&gt;Weapon.elm&lt;/code&gt; ファイルを作り，新しいモジュール定義する．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Weapon exposing (..)

type alias Weapon =
    { name : String
    , level : Int
    , damage : Int
    }

new : String -&amp;gt; Int -&amp;gt; Int -&amp;gt; Weapon
new name level damage = Weapon name level damage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このモジュールをインポートして &lt;code&gt;Character&lt;/code&gt; 型を拡張しよう&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;import Weapon exposing (Weapon)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    , arm : Maybe Weapon
    }

new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)
      Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後に &lt;code&gt;equip&lt;/code&gt; 関数を作って完成． これで全てのテストが通るはずだ．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;equip : Weapon -&amp;gt; Character -&amp;gt; Result String Character
equip weapon character =
    if weapon.level &amp;lt; character.status.intelligence then
        Ok { character | arm = Just weapon }
    else
        Err &amp;quot;Too dumb&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「頭悪すぎ」ってひどい(笑)&lt;/p&gt;
&lt;h2 id="phoenix-で-todo-アプリを作る"&gt;Phoenix で ToDo アプリを作る&lt;/h2&gt;
&lt;p&gt;Elchemy が実際にどの程度有用かを感じるために，Elchemy + Elm + Phoenix で超簡易的な Todo アプリを作ってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app"&gt;MATSUBARA Nobutada / elchemy_todo_app · GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過去に &lt;a href="https://github.com/matsubara0507/patissier-test"&gt;Elm + Phoenix で社内ツールを作ったり&lt;/a&gt;，&lt;a href="https://matsubara0507.github.io/posts/2017-12-13-elm-and-haskell-for-elmer.html"&gt;Elm + Haskell で Todo アプリを書いてみたり&lt;/a&gt;したので，その辺りからコードや構成はパクッて来てます． GitLab に置いてるのは，モノは試しってやつ(笑)．&lt;/p&gt;
&lt;h3 id="phoenix-をインストール"&gt;Phoenix をインストール&lt;/h3&gt;
&lt;p&gt;Elchemy (および Elixir・Elm・npm) はインストールされているとする． &lt;a href="https://hexdocs.pm/phoenix/installation.html"&gt;Phoenix のサイト&lt;/a&gt;にある通りにやればよい．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix archive.install https://github.com/phoenixframework/archives/raw/master/phx_new.ez&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="project-を作成"&gt;Project を作成&lt;/h3&gt;
&lt;p&gt;こんな時のために &lt;code&gt;elchemy init&lt;/code&gt; というコマンドがある(？)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix phx.new elchemy_todo_app --no-ecto
$ cd elchemy_todo_app
$ elchemy init&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;elchemy new&lt;/code&gt; との違いは，&lt;code&gt;mix.exs&lt;/code&gt; の Elixir のバージョンが古いのと &lt;code&gt;.formatter.exs&lt;/code&gt; ぐらいかな？ 今回は DB をわざわざ使うのがめんどくさいので，ストレージっぽい GenServer を定義する(なので &lt;code&gt;--no-ecto&lt;/code&gt;)．&lt;/p&gt;
&lt;h3 id="crud-を作る"&gt;CRUD を作る&lt;/h3&gt;
&lt;p&gt;Phoenix に CRUD を追加するには，まず&lt;code&gt;router.ex&lt;/code&gt; にルーティングを足す.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Router&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:router&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;  pipeline &lt;span class="va"&gt;:api&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;    plug(&lt;span class="va"&gt;:accepts&lt;/span&gt;, [&lt;span class="st"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;  scope &lt;span class="st"&gt;&amp;quot;/api&amp;quot;&lt;/span&gt;, &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;    pipe_through(&lt;span class="va"&gt;:api&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;    resources(&lt;span class="st"&gt;&amp;quot;/todos&amp;quot;&lt;/span&gt;, &lt;span class="cn"&gt;TodoController&lt;/span&gt;, &lt;span class="va"&gt;only:&lt;/span&gt; [&lt;span class="va"&gt;:index&lt;/span&gt;, &lt;span class="va"&gt;:create&lt;/span&gt;, &lt;span class="va"&gt;:update&lt;/span&gt;, &lt;span class="va"&gt;:delete&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次にコントロラーを定義し，&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;TodoController&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;  &lt;span class="im"&gt;alias&lt;/span&gt; &lt;span class="cn"&gt;Models&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Todo&lt;/span&gt;, &lt;span class="va"&gt;as:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:controller&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; index(conn, _params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; create(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; update(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; delete(conn, %{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; id}), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;...&lt;/code&gt; の部分は後で埋める) そして View を定義する。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;TodoView&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:view&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; render(&lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; todos}), &lt;span class="kw"&gt;do&lt;/span&gt;: todos&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さてここから　Elchemy だ。 モデルを Elchemy で定義する. というかモデル以外はマクロ色が強過ぎてうまくいかなかった.&lt;/p&gt;
&lt;h3 id="elchemy-でモデルを"&gt;Elchemy でモデルを&lt;/h3&gt;
&lt;p&gt;まずは型を定義.&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Data.Todo exposing (..)
import Dict

type alias Todo =
    { id : String
    , title : String
    , done : Bool
    }

type alias Todos =
    Dict.Dict String Todo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここはフロント共有したいので別途切り出しておく. DBをサボるために GenServer なモデルを定義する.&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Models.Todo exposing (..)

import Data.Todo exposing (Todo, Todos)
import Dict
import Elchemy exposing (..)

{- ex
   use GenServer

   def start_link(init \\ %{ todos: %{}, cnt: 0 }), do: GenServer.start_link(__MODULE__, init, name: :todos)

   def init(state), do: {:ok, state}

   def handle_call(:get, _client, state), do: {:reply, state, state}

   def handle_cast({:set, new_state}, _state), do: {:noreply, new_state}

   def gen_(params) do
     %{
       id: params[&amp;quot;id&amp;quot;],
       title: params[&amp;quot;title&amp;quot;],
       done: params[&amp;quot;done&amp;quot;]
     }
   end
-}

type alias State =
    { todos : Todos
    , cnt : Int
    }

type Name
    = Todos

type Action
    = Get
    | Set State

gen : params -&amp;gt; Todo
gen = ffi &amp;quot;Models.Todo&amp;quot; &amp;quot;gen_&amp;quot;

getState : State
getState = call_ Todos Get

setState : State -&amp;gt; State
setState state = cast_ Todos (Set state) |&amp;gt; always state

call_ : Name -&amp;gt; Action -&amp;gt; a
call_ = ffi &amp;quot;GenServer&amp;quot; &amp;quot;call&amp;quot;

cast_ : Name -&amp;gt; Action -&amp;gt; a
cast_ = ffi &amp;quot;GenServer&amp;quot; &amp;quot;cast&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Todos&lt;/code&gt; と削除された &lt;code&gt;Todo&lt;/code&gt; も含めた総数を表した &lt;code&gt;Int&lt;/code&gt; を持った &lt;code&gt;State&lt;/code&gt; 型を状態として GenServer に保持して欲しい． 出力した Elixir コードにだけモジュールをインポートさせたり，うまく型付けできない関数を Elixir コードに張り付けるには，コメントアウト &lt;code&gt;{- ex ... -}&lt;/code&gt; 使う． この中に書いた Elixir コードはそのまま出力先に貼り付けられる(濫用厳禁！)．&lt;/p&gt;
&lt;p&gt;Elixir モジュールの関数を呼び出すには &lt;code&gt;Elchemy&lt;/code&gt; モジュールにある &lt;code&gt;ffi&lt;/code&gt; 関数を使う． ただし，&lt;code&gt;ffi&lt;/code&gt; 関数をファーストクラスには扱えない． 次のようなエラーが出る．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ffi inside function body is deprecated since Elchemy 0.3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Name&lt;/code&gt; 型や &lt;code&gt;Action&lt;/code&gt; 型は Elchemy が代数的データ型をアトムとタプルに変換することと，GenServer の使い方を知っていれば意図するところが分かるだろう． 逆にそれらを知っていなければ読みとれないと思う…&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;コントローラーから呼ばれるインターフェースは &lt;code&gt;getState&lt;/code&gt; と &lt;code&gt;setState&lt;/code&gt; を用いることで簡単に書けた．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;gets : List Todo
gets = Dict.values (.todos getState)

add : Todo -&amp;gt; List Todo
add todo =
    let
        { todos, cnt } = getState
        newId   = toString cnt
        newTodo = { todo | id = newId }
        state   = { todos = Dict.insert newId newTodo todos, cnt = cnt + 1 }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values

update : Todo -&amp;gt; List Todo
update todo =
    let
        { todos, cnt } = getState
        state = { todos = Dict.update todo.id (Maybe.map &amp;lt;| always todo) todos, cnt = cnt }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values

remove : String -&amp;gt; List Todo
remove todoId =
    let
        { todos, cnt } =
            getState
        state =
            { todos = Dict.remove todoId todos, cnt = cnt }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コントローラーの &lt;code&gt;...&lt;/code&gt; を書き換えてやれば完成だ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; index(conn, _params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gets()})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; create(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;add(&lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gen(params))})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; update(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;update(&lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gen(params))})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; delete(conn, %{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; id}), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;remove(id)})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" data-line-number="5"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに出力された Elixir コードは&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/data/todo.elchemy.ex"&gt;ココ&lt;/a&gt;と&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/models/todo.elchemy.ex"&gt;ココ&lt;/a&gt;です． 興味がある人は見てください．&lt;/p&gt;
&lt;h3 id="elm-brunch"&gt;Elm Brunch&lt;/h3&gt;
&lt;p&gt;Brunch 設定が難しかったので，本質的には Elchemy と関係ないけど残しておく．&lt;/p&gt;
&lt;p&gt;Phoenix 1.3 系ではトップレベルに &lt;code&gt;assets&lt;/code&gt; というディレクトリがあり，HTML/JS/CSS/画像 のような静的ファイルはここに置いておく． Brunch を使って複数の JS や CSS を合わせることが出来る． &lt;a href="https://github.com/madsflensted/elm-brunch"&gt;elm-brunch&lt;/a&gt; を使うことで Elm を JS にコンパイルしてくれる．&lt;/p&gt;
&lt;p&gt;branch-config に次のような設定を書き加えてあげる． Elm のフロントコードは &lt;code&gt;lib/web/elm&lt;/code&gt; に置いてある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode javascript"&gt;&lt;code class="sourceCode javascript"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="va"&gt;exports&lt;/span&gt;.&lt;span class="at"&gt;config&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;  &lt;span class="dt"&gt;paths&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;    &lt;span class="dt"&gt;watched&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;static&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;css&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;js&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;vendor&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../lib/web/elm&amp;quot;&lt;/span&gt;]&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;    &lt;span class="dt"&gt;public&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../priv/static&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-6" data-line-number="6"&gt;  &lt;span class="op"&gt;},&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-8" data-line-number="8"&gt;  &lt;span class="dt"&gt;plugins&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-9" data-line-number="9"&gt;    &lt;span class="dt"&gt;elmBrunch&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-10" data-line-number="10"&gt;      &lt;span class="dt"&gt;elmFolder&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../lib/web/elm&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-11" data-line-number="11"&gt;      &lt;span class="dt"&gt;mainModules&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;Main.elm&amp;quot;&lt;/span&gt;]&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-12" data-line-number="12"&gt;      &lt;span class="dt"&gt;outputFolder&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;vendor&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-13" data-line-number="13"&gt;    &lt;span class="op"&gt;},&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-14" data-line-number="14"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-15" data-line-number="15"&gt;  &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-16" data-line-number="16"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-17" data-line-number="17"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="フロント部分"&gt;フロント部分&lt;/h3&gt;
&lt;p&gt;ほんの少しだがコードを再利用できる． API クライアントは以下のようになる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module TodoAPI exposing (..)

import Data.Todo exposing (Todo)
import Http

getTodos : Http.Request (List Todo)
getTodos =
    Http.request
        { method =
            &amp;quot;GET&amp;quot;
        , headers =
            []
        , url =
            String.join &amp;quot;/&amp;quot;
                [ baseUrl
                , &amp;quot;todos&amp;quot;
                ]
        , body =
            Http.emptyBody
        , expect =
            Http.expectJson (list decodeTodo)
        , timeout =
            Nothing
        , withCredentials =
            False
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ホントはこの当たりも Elchemy を使って生成できるとよいのだが… もしかして &lt;a href="https://github.com/saschatimme/elm-phoenix"&gt;elm-phoenix&lt;/a&gt; なるものを使えばよかったのかな？ また，The Elm Architecture 部分は長いので割愛．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ホントは assets 回りが他にもたくさんあるが,本質的な部分はこれで完成． あとはモロモロインストールして &lt;code&gt;mix phx.server&lt;/code&gt; とすれば動作するはずだ．&lt;/p&gt;
&lt;h3 id="感想"&gt;感想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;うれしみ&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;静的検査は神&lt;/li&gt;
&lt;li&gt;フロントとコードを共有できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;つらみ&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Phoenix のいくつかは型付けできない
&lt;ul&gt;
&lt;li&gt;ルーティングの引数&lt;/li&gt;
&lt;li&gt;へテロリストのようなモノ&lt;/li&gt;
&lt;li&gt;結局ここで良く分からんエラーに…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンパイルが遅い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;今度は処理系の中身でも追ってみようかな．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html</id><title type="text">Elchemy 入門 : その１</title><updated>2018-06-15T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Elchemy 入門 : その１&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-15" itemprop="datePublished"&gt;
        Jun 15, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elchemy.html"&gt;Elchemy&lt;/a&gt; &lt;a href="/tags/Elm.html"&gt;Elm&lt;/a&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;Elm から Elixir のトランスパイラ，&lt;a href="https://github.com/wende/elmchemy"&gt;Elchemy&lt;/a&gt; についてイロイロと調べたのでまとめていきます． 今回は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wende/elchemy/blob/9184d758dc1d5d5d3209302f9742c11fe01aa92c/README.md"&gt;README&lt;/a&gt; の意訳&lt;/li&gt;
&lt;li&gt;Dockerイメージ作成&lt;/li&gt;
&lt;li&gt;Tutorial その１をやってみた&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の3本立てです． ちなみに，現在のバージョンは 0.7.4 です．&lt;/p&gt;
&lt;h2 id="readme-意訳"&gt;README 意訳&lt;/h2&gt;
&lt;p&gt;Elchemy は，Elixir の強力なエコシステムと Elm の型安全によって，より簡潔に高速に高品質で型安全なコードを記述するために作られた処理系です．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://elchemy-live.herokuapp.com"&gt;Elchemy のオンライン環境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wende.gitbooks.io/elchemy/content/"&gt;Elchemy の公式ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d"&gt;Elchemy のチュートリアル&lt;/a&gt; (今のところ Part1 と Part2 がある)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なにか質問がある場合は &lt;a href="https://github.com/wende/elchemy/labels/Q%26A"&gt;&lt;code&gt;Q&amp;amp;A&lt;/code&gt; ラベルを付けて Issue を書いて&lt;/a&gt;，だそうだ．&lt;/p&gt;
&lt;h3 id="features"&gt;Features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;型推論:&lt;/strong&gt; 強力な型推論によって型注釈を付けることはめったにない． コンパイラによって全て検査される．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簡単で型安全な呼び出し:&lt;/strong&gt; 余計なボイラープレートなしに Elixir/Erlang のプログラムを呼び出すことが出来る． Elixir の typespec に基づいて可能な限り徹底的に型安全の観点から全ての呼び出しを検査する．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Elm と Elixir のいいとこどり:&lt;/strong&gt; Elchemy は Elm の型安全性と強力な型推論，素晴らしい表現力を継承し，Elixir の Doc-test とツール群，そして BEAM プラットフォームを継承している．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ほとんどないランタイムエラー:&lt;/strong&gt; Elchemy の型システムは &lt;strong&gt;ほぼ全てのランタイムエラーを排除する&lt;/strong&gt; ． エッジケースが少なくなることで，Elchemy のコードそのものは安全になる． ランタイムエラーが発生した場合，おそらく Elixir のところが起こしているのだろう．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;美しくて可読性の高い出力:&lt;/strong&gt; 生成されたコードは慣習的で効率的で元のコードが無くとも読みやすく分析可能である．&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="faq"&gt;FAQ&lt;/h3&gt;
&lt;h4 id="どういう人にお勧めか"&gt;どういう人にお勧めか？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;型が好きな人&lt;/li&gt;
&lt;li&gt;実行時エラーよりコンパイルエラーの方が好みな人&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defp add(a, b), do: b + c&lt;/code&gt; より &lt;code&gt;add b c = b + c&lt;/code&gt; な書き方の方が好みな人&lt;/li&gt;
&lt;li&gt;カリー化が好きな人&lt;/li&gt;
&lt;li&gt;さっさと失敗させるより全て失敗しない方が賢いと思う人&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="どういう人にお勧めじゃないか"&gt;どういう人にお勧めじゃないか？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;もしあなたのプロジェクトが徹底的にテストされたライブラリに依存しておりかつ，あなたが 0 から始まるバージョンを嫌う場合&lt;/li&gt;
&lt;li&gt;モナドを学ぶことで口ひげが伸び視力が弱くなることを恐れる場合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="既にある-elixir-プロジェクトを置き換えるのは可能か"&gt;既にある Elixir プロジェクトを置き換えるのは可能か？&lt;/h4&gt;
&lt;p&gt;可能です． しかし，ナイスでダンディーなコンパイルツールは開発中です．&lt;/p&gt;
&lt;h4 id="上司に-elchemy-に現を抜かしていることがばれるだろうか"&gt;上司に Elchemy に現を抜かしていることがばれるだろうか？&lt;/h4&gt;
&lt;p&gt;Elchemy の出力はコードの可読性を第一級市民として扱っている． コードは適切にインデントされ，コメントは省略されず，できるだけ最適化されている(例えば，case 節は関数のオーバーロードになる)．&lt;/p&gt;
&lt;h4 id="elchemy-1.0.0-はまだ"&gt;Elchemy 1.0.0 はまだ？&lt;/h4&gt;
&lt;p&gt;終わったらね．&lt;/p&gt;
&lt;h4 id="コントリビュートしてもいい"&gt;コントリビュートしてもいい？&lt;/h4&gt;
&lt;p&gt;絶対にしてください．&lt;/p&gt;
&lt;h4 id="型はどのように表される"&gt;型はどのように表される？&lt;/h4&gt;
&lt;p&gt;Elchemy の全ての値コンストラクタはスネークケースのアトムとして表現され，コンストラクタの引数はタプルで表わされる． つまり，Elchemy で &lt;code&gt;MyType 42 &amp;quot;Forty two&amp;quot; Error&lt;/code&gt; という値は &lt;code&gt;{:my_type, 42, &amp;quot;Forty two&amp;quot;, :error}&lt;/code&gt; という Elixir の値となる．&lt;/p&gt;
&lt;p&gt;(Type constructor と書いてあるが正しくは Data constructor あるいは value constructor のはずで，Type application も間違いだと思われる)&lt;/p&gt;
&lt;h4 id="elm-の既存のライブラリを-elchemy-で使えるの"&gt;Elm の既存のライブラリを Elchemy で使えるの？&lt;/h4&gt;
&lt;p&gt;Native モジュールや Port，Elm ランタイムを使わない限りは，それらを安全にインポートして使うことが出来る．&lt;/p&gt;
&lt;h4 id="elixir-の既存のライブラリを-elchemy-で使えるの"&gt;Elixir の既存のライブラリを Elchemy で使えるの？&lt;/h4&gt;
&lt;p&gt;使える． 任意のモジュールの任意の関数を FFI 呼び出しすることが出来る． Elixir モジュール，Erlang モジュール，あるいはマクロであってしても自身の Elchemy コードに含むことが出来る． FFI 呼び出しは Elchemy 内で特別扱いされる． そして，&lt;code&gt;@spec&lt;/code&gt; に基づいた型の解析を行うテストが生成されるため，Elixir コードの型安全性を損なうことは無い． 可読性を向上させるためにも FFI 呼び出しは可能な限り避け，常にドキュメント化と &lt;code&gt;doctest&lt;/code&gt; をすることをお勧めする．&lt;/p&gt;
&lt;h4 id="テストのような-elixir-のマクロは使えるの"&gt;テストのような Elixir のマクロは使えるの？&lt;/h4&gt;
&lt;p&gt;残念ながら，&lt;code&gt;do...end&lt;/code&gt; ブロックのような任意のマクロを書くことはまだできない． 替わりとして，任意の関数に対して次のような Elixir のインラインコードを書くことが出来る．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;{- ex
  code_here
-}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし，それは最後の手段であり，乱用すべきではない．&lt;/p&gt;
&lt;h4 id="elchemy-の-.elm-ファイルをコンパイルするのに-elm-処理系をインストールする必要がある"&gt;Elchemy の &lt;code&gt;.elm&lt;/code&gt; ファイルをコンパイルするのに Elm 処理系をインストールする必要がある？&lt;/h4&gt;
&lt;p&gt;(なんとなく解答的に Elixir 処理系だけで完結できないの？という意味っぽい)&lt;/p&gt;
&lt;p&gt;あなたは Elm のようなコードを書いて Elixir のコードを生成したいのに， Elixir コードの生成を Elixir コードを書いて作りたいですか？&lt;/p&gt;
&lt;h4 id="elchemy-プロジェクト"&gt;Elchemy プロジェクト&lt;/h4&gt;
&lt;p&gt;作者はこの Elchemy プロジェクトそのものを可能な限り Elm で構築したいらしい． &lt;a href="https://github.com/wende/elchemy#maturity-of-the-project"&gt;README にはその達成度が書かれている&lt;/a&gt;． 処理系そのものは，ほとんど Elm になっているようだ(結果として世にも珍しい Elm で書かれたコンパイラが出来ている)． エフェクトや ErlangVM 回りが厳しいらしい．&lt;/p&gt;
&lt;h2 id="dockerイメージ作成"&gt;Dockerイメージ作成&lt;/h2&gt;
&lt;p&gt;ココからが本題．&lt;/p&gt;
&lt;p&gt;新しい言語を軽く試すのに最適なのはやはり Docker だ． Elchemy の Docker イメージは見当たらなかったので作った．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hub.docker.com/r/matsubara0507/elchemy"&gt;matsubara0507/elchemy - Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="できるまで"&gt;できるまで&lt;/h3&gt;
&lt;p&gt;本家の README を読むとわかるように Elchemy でビルドするのに必要なモノは以下の4つ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node (npm)&lt;/li&gt;
&lt;li&gt;Elixir (ErlangVM)&lt;/li&gt;
&lt;li&gt;Elm&lt;/li&gt;
&lt;li&gt;elm-github-install&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのうち，もっともめんどくさいのは Elixir もとい ErlangVM だと思う． なので base イメージを Elixir にし，ひとつずつ入れていった．&lt;/p&gt;
&lt;p&gt;base イメージにした &lt;a href="https://hub.docker.com/_/elixir/"&gt;Elixir の Docker イメージは公式のモノ&lt;/a&gt;を使う． &lt;a href="https://github.com/erlang/docker-erlang-otp/blob/99ab1e150c3708ce81bc08073cf5793ef67c6a1c/20/Dockerfile#L1"&gt;OSは Debian9 だ&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;Debian への Node のインストールには以下の記事を参考にした．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://atomiyama.com/linux/page/debian-9-2-node-npm/"&gt;debian9.2にNode.jsとnpmをインストールする｜atominux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;こんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode dockerfile"&gt;&lt;code class="sourceCode dockerfile"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; curl -sL https://deb.nodesource.com/setup_${NODE_VERSION} | bash - \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;  &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install -y nodejs \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;  &amp;amp;&amp;amp; apt-get clean \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;  &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;後は簡単で Elm，elm-github-install，Elchemy は npm からインストールできる． ただし，Elm と elm-github-install には &lt;code&gt;--unsafe-perm=true --allow-root&lt;/code&gt; という&lt;a href="https://github.com/gdotdesign/elm-github-install/issues/21#issuecomment-332827661"&gt;オプションを付けないといけない&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode dockerfile"&gt;&lt;code class="sourceCode dockerfile"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elm@${ELM_VERSION} --unsafe-perm=true --allow-root&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elm-github-install@${ELM_GITHUB_INSTALL_VERSION} --unsafe-perm=true --allow-root&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elchemy@${ELCHEMY_VERSION}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="auto-build"&gt;Auto Build&lt;/h3&gt;
&lt;p&gt;Elchemy のリリースを眺めてると想像より開発スピードが速かったので，Elchemy の更新を観測して自動ビルドしてくれる仕組みを作ることにした． シェル芸を駆使すればなんとかなりそうだったが，サクッと Haskell 芸をかまして CLI を作った．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/dockwright"&gt;matsubara0507/dockwright - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(船大工が &lt;code&gt;shipwright&lt;/code&gt; なので Dockerfile 大工ってことで &lt;code&gt;dockwright&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;以下のような設定を書いておくと &lt;code&gt;dockwright&lt;/code&gt; ってコマンドで GitHub の &lt;code&gt;release&lt;/code&gt; API を叩いてリリースタグを取ってきてくれる． それを Docker 内の環境変数としてテンプレートに書き込む．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="fu"&gt;env:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;elchemy_version:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;      &lt;span class="fu"&gt;repo:&lt;/span&gt;&lt;span class="at"&gt; wende/elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;      &lt;span class="fu"&gt;hook:&lt;/span&gt;&lt;span class="at"&gt; release&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あとは git diff で更新をみて更新があればコミットする(コミットさえすれば Docker Hub が自動ビルドしてくれる)． 定期実行は例の如く TravisCI で回す．&lt;/p&gt;
&lt;h2 id="tutorial-そのをやってみた"&gt;Tutorial その１をやってみた&lt;/h2&gt;
&lt;p&gt;以下の記事をやってみる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d"&gt;Elmchemy — Write type-safe Elixir code with Elm’s syntax — part 1 — Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まずは &lt;code&gt;article_example_elchemy&lt;/code&gt; というプロジェクトを作る． 記事内では &lt;code&gt;mix new&lt;/code&gt; をして &lt;code&gt;elchemy init&lt;/code&gt; をしろと書いてあるが，最新の Elchemy では &lt;code&gt;elchemy new&lt;/code&gt; をすることで一気にやってくれる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ elchemy new article_example_elchemy&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elchemy をコンパイルするためには，&lt;code&gt;mix.exs&lt;/code&gt; を次のように&lt;a href="https://wende.gitbooks.io/elchemy/content/INSTALLATION.html"&gt;書き換える必要がある&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;MyProject&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Mixfile&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Mix&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Project&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; project &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;    [&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;      &lt;span class="va"&gt;app:&lt;/span&gt; &lt;span class="va"&gt;:my_project&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;      &lt;span class="va"&gt;version:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;      &lt;span class="va"&gt;elixir:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;~&amp;gt; 1.5&amp;quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;      &lt;span class="va"&gt;start_permanent:&lt;/span&gt; &lt;span class="cn"&gt;Mix&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;env &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;:prod&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;      &lt;span class="va"&gt;deps:&lt;/span&gt; deps()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;    ] &lt;span class="op"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="cn"&gt;Code&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;eval_file(&lt;span class="st"&gt;&amp;quot;elchemy.exs&amp;quot;&lt;/span&gt;)&lt;span class="op"&gt;.&lt;/span&gt;init &lt;span class="co"&gt;# ココ!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;|&amp;gt; Code.eval_file(&amp;quot;elchemy.exs&amp;quot;).ini&lt;/code&gt; の部分を書き加えている．&lt;/p&gt;
&lt;h3 id="ディレクトリ構成"&gt;ディレクトリ構成&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;elchemy new&lt;/code&gt; した結果はこんな感じ(バージョンによっては違うかもしれない)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;projrct_name
  |- .elchemy.exs
  |- .formatter.exs
  |- .gitignore
  |- README.md
  |- config
  |   \- config.exs
  |- elm
  |   \- Hello.elm
  |- elm-package.json
  |- lib
  |   \- project_name.ex
  |- mix.exs
  \- test
      |- elchemy_test.exs
      |- project_name_test.exs
      \- test_helper.exs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.elchemy.exs&lt;/code&gt; は &lt;code&gt;mix&lt;/code&gt; コマンドを Elchemy で上書きするための &lt;code&gt;mix&lt;/code&gt; 設定ファイルで，残りは Elixir と Elm のプロジェクトファイルが混ざっている． ちなみに &lt;code&gt;.formatter.exs&lt;/code&gt; は Elixir 1.6 で追加された Elixir のフォーマッターの設定ファイルだ．&lt;/p&gt;
&lt;h3 id="関数を定義してみる"&gt;関数を定義してみる&lt;/h3&gt;
&lt;p&gt;試しに，総和を求める &lt;code&gt;sum&lt;/code&gt; 関数を書いてみる． &lt;code&gt;elm/Hello.elm&lt;/code&gt; に書き加えるとして，まずはユニットテストを &lt;code&gt;test\elchemy_test.exs&lt;/code&gt; に Elixir の文脈で書き加えてみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTest&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ExUnit&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  doctest &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;  test &lt;span class="st"&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;    assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;hello() &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;world!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;  test &lt;span class="st"&gt;&amp;quot;Sum of lists&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([&lt;span class="dv"&gt;2&lt;/span&gt;]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;-1&lt;/span&gt;, &lt;span class="dv"&gt;-2&lt;/span&gt;, &lt;span class="dv"&gt;-3&lt;/span&gt;]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" data-line-number="15"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次に &lt;code&gt;elm/Hello.elm&lt;/code&gt; に以下の関数を書き加える．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;sum : List a -&amp;gt; Int
sum list =
    case list of
        first :: rest -&amp;gt;
            first + sum rest

        [] -&amp;gt;
            0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とりあえずビルドしてみる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix test
warning: redefining module ElchemyInit (current version defined in memory)
  elchemy.exs:1

==&amp;gt; elchemy
Compiling 24 files (.ex)
warning: unused alias XMaybe
  lib/Elchemy/XRegex.elchemy.ex:28

warning: unused import Elchemy.XBasics
  lib/Elchemy/XChar.elchemy.ex:25

warning: unused import Elchemy.XBasics
  lib/Elchemy/XBitwise.elchemy.ex:6

warning: unused import Elchemy.Macros
  lib/Elchemy/Plugins/Ex_unit.elchemy.ex:7

warning: unused import Elchemy.Macros
  lib/Elchemy/Tests/Ex_unit_test.elchemy.ex:7

Generated elchemy app
==&amp;gt; article_example_elchemy
/usr/bin/elchemy
-- Copying Elixir native files --
-- Compiling Elm files --
----------
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The left argument of (+) is causing a type mismatch.

21|             first + sum rest
                ^^^^^
(+) is expecting the left argument to be a:

    number

But the left argument is:

    a

Hint: Your type annotation uses type variable `a` which means any type of value
can flow through. Your code is saying it CANNOT be anything though! Maybe change
your type annotation to be more specific? Maybe the code has a problem? More at:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&amp;gt;

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;いろいろ出ているが重要なのは &lt;code&gt;The left argument of (+) is causing a type mismatch.&lt;/code&gt; の部分． 型検査した結果，型が合わなかったのだ． 念のため型検査器の言い分を補足しておくと，&lt;code&gt;sum&lt;/code&gt; 関数の引数として &lt;code&gt;List a&lt;/code&gt; 型の値 &lt;code&gt;list&lt;/code&gt; の要素である &lt;code&gt;first&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; 型と推論されるが，加算 &lt;code&gt;(+)&lt;/code&gt; は &lt;code&gt;number&lt;/code&gt; 型じゃないといけない，ということだ(&lt;code&gt;number&lt;/code&gt; 型は加算や乗算が実装されている多相型)．&lt;/p&gt;
&lt;p&gt;言われた通りに変えてみよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;sum : List number -&amp;gt; Int
sum list = ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ビルドする．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix test
...
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The right side of (+) is causing a type mismatch.

21|             first + sum rest
                        ^^^^^^^^
(+) is expecting the right side to be a:

    number

But the right side is:

    Int

Hint: Your type annotation uses type variable `number` which means any type of
value can flow through. Your code is saying it CANNOT be anything though! Maybe
change your type annotation to be more specific? Maybe the code has a problem?
More at:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&amp;gt;

Hint: With operators like (+) I always check the left side first. If it seems
fine, I assume it is correct and check the right side. So the problem may be in
how the left and right arguments interact.

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;(+) is expecting the right side to be a&lt;/code&gt; というエラーメッセージに変わった． これは &lt;code&gt;sum&lt;/code&gt; 関数の返り値の型が &lt;code&gt;Int&lt;/code&gt; なので &lt;code&gt;sum rest&lt;/code&gt; の型は &lt;code&gt;Int&lt;/code&gt; と推論されたが，&lt;code&gt;first&lt;/code&gt; の型が &lt;code&gt;number&lt;/code&gt; なので &lt;code&gt;(+)&lt;/code&gt; 演算子の左右の型が合わない，ということだ． なので， &lt;code&gt;sum : List Int -&amp;gt; Int&lt;/code&gt; とすると無事ビルドが通る．&lt;/p&gt;
&lt;h3 id="変換された-elixir-コード"&gt;変換された Elixir コード&lt;/h3&gt;
&lt;p&gt;ちなみに，次のような Elixir コードに変換されている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;Hello&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;  &lt;span class="ot"&gt;@spec&lt;/span&gt; sum(list(integer)) :: integer&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;  curry sum&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; sum(list) &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; list &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;      [first &lt;span class="op"&gt;|&lt;/span&gt; rest] &lt;span class="op"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;        (first &lt;span class="op"&gt;+&lt;/span&gt; sum(rest))&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;      [] &lt;span class="op"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;        &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" data-line-number="14"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="doctest"&gt;doctest&lt;/h3&gt;
&lt;p&gt;また，次のように書くことで doctest も変換してくれる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;{-| Returns a sum of every integer int the function

    sum [1,2,3] == 6
    sum [10] == 10
    sum [] == 0

-}
sum : List Int -&amp;gt; Int
sum list = ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変換先はこうだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;  &lt;span class="ot"&gt;@doc &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="co"&gt;  Returns a sum of every integer int the function&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([1, 2, 3])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="co"&gt;      6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([10])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="co"&gt;      10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;&lt;span class="co"&gt;      0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;&lt;span class="co"&gt;  &lt;/span&gt;&lt;span class="ot"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-18" data-line-number="18"&gt;  &lt;span class="ot"&gt;@spec&lt;/span&gt; sum(list(integer)) :: integer&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-19" data-line-number="19"&gt;  curry sum&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-20" data-line-number="20"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; sum(list) &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-21" data-line-number="21"&gt;    &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;次はアプリケーションを作りたい．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html</id><title type="text">[linux][cygwin] unzipコマンドで "error:  invalid compressed data to inflate" というエラーメッセージがでたら？</title><updated>2018-06-06T01:11:48.468+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html"/><summary type="text">zipアーカイブの中に長さが0のファイルが含まれていると、unzipコマンドでは以下のようなエラーメッセージが表示されて、解凍することができません。アーカイブが壊れていなくてもエラーになります。
% unzip hoge.zip
  error:  invalid compressed data to inflate

このような場合には、-tzipオプションを指定して7zコマンドを実行することで、エラーを回避して解凍できます。パスワード保護されているzipアーカイブも問題なく解凍できました。

% 7z x -tzip hoge.zip


manページによると、以下のフォーマットがサポートされていて、デフォルトは7zとのこと。

The program supports 7z (that implements  LZMA  compression  algorithm),  
ZIP</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html</id><title type="text">Prelude を カスタムPrelude で置き換える</title><updated>2018-05-23T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;つい最近 haskell-jp で &lt;strong&gt;皆さんPreludeは何を使っていますか？&lt;/strong&gt; という話がありました。&lt;/p&gt;
&lt;p&gt;まとめるとだいたこんな感じです。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;カスタム Prelude パッケージ&lt;/th&gt;
&lt;th&gt;利用しているプロジェクト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;a href="https://github.com/nikita-volkov/base-prelude"&gt;base-prelude&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;a href="https://github.com/snoyberg/mono-traversable/tree/master/classy-prelude"&gt;classy-prelude&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/yesodweb/yesod"&gt;Yesod&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;a href="https://github.com/sdiehl/protolude"&gt;protolude&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/purescript/purescript"&gt;purescript&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;a href="https://github.com/serokell/universum"&gt;universum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/input-output-hk/cardano-sl"&gt;cardano-sl&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;a href="https://github.com/commercialhaskell/rio"&gt;rio&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href="https://github.com/commercialhaskell/stack"&gt;stack&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;カスタム Prelude を使うモチベーションは、自分のよく使う関数を Prelude に入れたいとか、&lt;strong&gt;fromJust&lt;/strong&gt; みたいな部分関数を排除したいなど、色々あります。&lt;/p&gt;
&lt;p&gt;実際にカスタム Prelude を使うためにはファイルの先頭に &lt;strong&gt;NoImplicitPrelude&lt;/strong&gt; 言語拡張とカスタムPreludeの &lt;strong&gt;import&lt;/strong&gt; 宣言を追加する必要があります。(具体例として &lt;strong&gt;rio&lt;/strong&gt; パッケージを利用します)&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE NoImplicitPrelude #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新しいファイルを作るたびに、ファイルの先頭に上記の宣言を書いても良いのですが、今回はこの作業なしにカスタム Prelude を使う方法をご紹介したいと思います。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="default-extensions-を利用する"&gt;default-extensions を利用する&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{-# LANGUAGE NoImplicitPrelude #-}&lt;/code&gt; を自動的に有効化させることは意外と簡単です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;package.yaml&lt;/strong&gt; や &lt;strong&gt;cabal&lt;/strong&gt; ファイルの &lt;strong&gt;default-extensions&lt;/strong&gt; に追加するだけです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="co"&gt;# package.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="fu"&gt;default-extensions:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; NoImplicitPrelude&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;# project.cabal
default-extensions: NoImplicitPrelude&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この場合、全てのファイルで自動的に &lt;strong&gt;NoImplicitPrelude&lt;/strong&gt; が有効になるため、カスタム Prelude の import 宣言のみが必要となります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;&lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まだ &lt;code&gt;import RIO&lt;/code&gt; が残っているので、こいつをなんとかしましょう。&lt;/p&gt;
&lt;h2 id="base-noprelude-パッケージ"&gt;base-noprelude パッケージ&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/9499?cversion=0&amp;amp;cnum_hist=8"&gt;Add -prelude-is flag&lt;/a&gt; というチケットで紹介されている方法を使えば、&lt;code&gt;import RIO&lt;/code&gt; を記述することなく、&lt;strong&gt;Prelude&lt;/strong&gt; のように利用できるようになります。&lt;/p&gt;
&lt;p&gt;このチケットによれば &lt;strong&gt;-prelude-is&lt;/strong&gt; というオプションを導入しようとしていたようですが、そんなことしなくても &lt;strong&gt;Prelude&lt;/strong&gt; を置き換えれるよ！という話です。&lt;/p&gt;
&lt;p&gt;具体的には &lt;a href="https://github.com/haskell-hvr/base-noprelude"&gt;base-noprelude&lt;/a&gt; パッケージを利用します。&lt;/p&gt;
&lt;h3 id="最小構成"&gt;最小構成&lt;/h3&gt;
&lt;p&gt;この方法もかなり簡単で、&lt;strong&gt;stack.yaml&lt;/strong&gt;, &lt;strong&gt;package.yaml&lt;/strong&gt;, &lt;strong&gt;src/Prelude.hs&lt;/strong&gt; をちょこっと書くだけで完成です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="co"&gt;# stack.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; nightly-2018-05-23&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; base-noprelude-4.11.1.0&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="co"&gt;# package.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; extended-prelude&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="fu"&gt;dependencies:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; base-noprelude&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; rio&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;&lt;span class="fu"&gt;library:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;  &lt;span class="fu"&gt;source-dirs:&lt;/span&gt;&lt;span class="at"&gt; src&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;other-modules:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; Prelude&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- src/Prelude.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Prelude&lt;/span&gt; (&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="確認"&gt;確認&lt;/h3&gt;
&lt;p&gt;ファイルに &lt;code&gt;import RIO&lt;/code&gt; を書かなくても本当に良いのか確かめてみます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="co"&gt;-- src/Sample.hs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Sample&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;f &lt;span class="fu"&gt;=&lt;/span&gt; tshow &lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然、通常の &lt;strong&gt;Prelude&lt;/strong&gt; には &lt;strong&gt;Text&lt;/strong&gt; も &lt;strong&gt;tshow&lt;/strong&gt; も無いので、&lt;code&gt;import RIO&lt;/code&gt; が有効になっていなければ、ビルドエラーになるはずです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ghci&lt;/strong&gt; で確認してみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt; stack repl&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; f&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="st"&gt;&amp;quot;\&amp;quot;a\&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t fromJust&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;Variable&lt;/span&gt; not &lt;span class="kw"&gt;in&lt;/span&gt; scope&lt;span class="fu"&gt;:&lt;/span&gt; fromJust&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;ghci&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t view&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;&lt;span class="ot"&gt;view ::&lt;/span&gt; &lt;span class="dt"&gt;MonadReader&lt;/span&gt; s m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Getting&lt;/span&gt; a s a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちゃんと動いてそうですね。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;実際にこの手法で開発を進めているわけではないので、もしかすると落とし穴があるかもしれませんが、思ったより使いやすくてびっくりしました。&lt;/p&gt;
&lt;p&gt;元の Prelude に戻すことも簡単だと思うので、興味があれば試してみて下さい。(結構前のチケットなので、周知の事実だったらすみません・・・。)&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html</id><title type="text">extensible-0.4.9 がリリースされました。</title><updated>2018-05-14T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;BIG MOON では、業務に必要なツールを自社開発しており、プログラミング言語に &lt;strong&gt;Haskell&lt;/strong&gt; を採用しています。実用的に利用し始めて3年ぐらい？です。&lt;/p&gt;
&lt;p&gt;僕らが &lt;strong&gt;Haskell&lt;/strong&gt; を利用していて一番困った点はレコードの取り扱いです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;異なる型のフィールドラベルに同じ名前を付けたい&lt;/li&gt;
&lt;li&gt;フィールド全体対して関数を適用したい&lt;/li&gt;
&lt;li&gt;フィールド多相な関数を定義したい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このような問題に対して &lt;a href="https://github.com/fumieval/extensible"&gt;extensible&lt;/a&gt; という、(当初は謎に包まれていた) パッケージの利用を検討し、実際に既存のシステムを &lt;strong&gt;extensible&lt;/strong&gt; で置き換えました。(当時アルバイトしていた &lt;a href="https://github.com/matsubara0507"&gt;matsubara0507&lt;/a&gt; さんが居なければ実現不可能だったと思います)&lt;/p&gt;
&lt;p&gt;今回、縁あって作者の &lt;a href="https://twitter.com/fumieval"&gt;fumieval&lt;/a&gt; さんと一緒に仕事できる機会に恵まれました。fumieval さんは簡単な質問でも、とても気さくに答えてくれます。&lt;/p&gt;
&lt;p&gt;僕達のノウハウはまだまだとても少ないですが、この素晴らしいパッケージを広く知って欲しいと思い、まだまだ作成途中ではありますが &lt;a href="https://wiki.hask.moe/"&gt;extensible 攻略Wiki&lt;/a&gt; という親しみやすい雰囲気で情報を発信していくことになりました。&lt;/p&gt;
&lt;p&gt;この wiki もまた &lt;strong&gt;Haskell&lt;/strong&gt; で作られており &lt;a href="https://github.com/fumieval/apus"&gt;apus&lt;/a&gt; という名前で公開されています。&lt;/p&gt;
&lt;p&gt;今回の extensible-0.4.9 の&lt;a href="https://github.com/fumieval/extensible/blob/master/CHANGELOG.md"&gt;アップデート&lt;/a&gt;は、攻略wiki のコンテンツを拡充していく中で出てきたアイデアや、関数などがいくつか追加されました。(matsubara0507 さんと弊社も色々と貢献できているはずです！)&lt;/p&gt;
&lt;p&gt;今回はその内容について簡単な例とともに解説を行いたいと思います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible"&gt;Hackage extensible-0.4.9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id="アップデート内容"&gt;アップデート内容&lt;/h2&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; :&amp;gt; String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;age&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="ot"&gt;person ::&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;person &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;name &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;age  &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;      &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以降の例では、上記の &lt;code&gt;Person&lt;/code&gt; 型と &lt;code&gt;person&lt;/code&gt; 変数が宣言されているものとします。&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;MonadIO のインスタンスを一般化しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ベースモナドとして &lt;strong&gt;ResourceT IO&lt;/strong&gt; などが使えるようになりました。&lt;/p&gt;
&lt;p&gt;今までは &lt;code&gt;Associate &amp;quot;IO&amp;quot; (ResourceT IO)&lt;/code&gt; のように書けませんでしたが、こんな感じのコードが書けるようになりました。また、&lt;a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:ResourceT"&gt;ResourceT IO&lt;/a&gt; 以外にも &lt;a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Control-Monad-IO-Class.html#t:MonadIO"&gt;MonadIO&lt;/a&gt; のインスタンスであれば何でも指定可能です。&lt;/p&gt;
&lt;p&gt;ここでは &lt;a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:MonadResource"&gt;MonadResource&lt;/a&gt; のインスタンスを自分で定義しましたが、次回リリース (0.4.10) でライブラリに追加される予定？です。(たぶん)&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;ExampleM&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Eff&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;IO&amp;quot; &amp;gt;: ResourceT IO ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; runResourceT &lt;span class="fu"&gt;.&lt;/span&gt; retractEff &lt;span class="fu"&gt;.&lt;/span&gt; runConduit &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;  bracketP (openFile &lt;span class="st"&gt;&amp;quot;data.csv&amp;quot;&lt;/span&gt; &lt;span class="dt"&gt;ReadMode&lt;/span&gt;) hClose &lt;span class="fu"&gt;$&lt;/span&gt; \handle &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;    (sourceHandle&lt;span class="ot"&gt; handle ::&lt;/span&gt; &lt;span class="dt"&gt;ConduitT&lt;/span&gt; i &lt;span class="dt"&gt;ByteString&lt;/span&gt; &lt;span class="dt"&gt;ExampleM&lt;/span&gt; ()) &lt;span class="fu"&gt;.|&lt;/span&gt; stdoutC&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Associate&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt; (&lt;span class="dt"&gt;ResourceT&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt;) xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;MonadResource&lt;/span&gt; (&lt;span class="dt"&gt;Eff&lt;/span&gt; xs) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;  liftResourceT &lt;span class="fu"&gt;=&lt;/span&gt; liftEff (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;IO&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ただ単に &lt;code&gt;csv&lt;/code&gt; ファイルを読み込んで表示するだけの例です。&lt;/p&gt;
&lt;pre class="csv"&gt;&lt;code&gt;-- data.csv
&amp;quot;bigmoon&amp;quot;, 10, &amp;quot;watch&amp;quot;
&amp;quot;wado&amp;quot;, 100, art
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; main&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;watch&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="st"&gt;&amp;quot;wado&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;100&lt;/span&gt;, art&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/MonadIO.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;新しい制約コンビネータ &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Dictionary.html#t:And"&gt;And&lt;/a&gt; を追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコンビネータを利用することで &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#t:Forall"&gt;Forall&lt;/a&gt; の制約を二つ以上指定することができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="dt"&gt;And&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; (k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; k &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下は拡張可能レコードの値が &lt;strong&gt;Show&lt;/strong&gt; かつ &lt;a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-Typeable.html"&gt;Typeable&lt;/a&gt; の両方を満たすという制約で &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hfoldMapFor"&gt;hfoldMapFor&lt;/a&gt; 関数を使う例です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;debug ::&lt;/span&gt; &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;ValueIs&lt;/span&gt; (&lt;span class="dt"&gt;And&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt;)) xs &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;debug &lt;span class="fu"&gt;=&lt;/span&gt; hfoldMapFor c (print &lt;span class="fu"&gt;.&lt;/span&gt; fork id typeOf &lt;span class="fu"&gt;.&lt;/span&gt; view _Wrapper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;    c &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; (&lt;span class="dt"&gt;ValueIs&lt;/span&gt; (&lt;span class="dt"&gt;And&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;    fork f g x &lt;span class="fu"&gt;=&lt;/span&gt; (f x, g x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例として定義した &lt;strong&gt;debug&lt;/strong&gt; 関数は与えられた拡張可能レコードの &lt;strong&gt;値&lt;/strong&gt; と &lt;strong&gt;型&lt;/strong&gt; を表示することができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; debug person&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;(&lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;,[&lt;span class="dt"&gt;Char&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;(&lt;span class="dv"&gt;10&lt;/span&gt;,&lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/And.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Field.html#v:stringAssocKey"&gt;stringAssocKey&lt;/a&gt; 関数を追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;stringAssocKey ::&lt;/span&gt; (&lt;span class="dt"&gt;IsString&lt;/span&gt; a, &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt; (&lt;span class="dt"&gt;AssocKey&lt;/span&gt; kv)) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数を使えば、拡張可能レコードのキーを文字列として取得することができます。&lt;/p&gt;
&lt;p&gt;例えば、拡張可能レコードのキーを全て集めてリストにして返す関数は以下のように作ることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;keys ::&lt;/span&gt; (&lt;span class="dt"&gt;IsString&lt;/span&gt; key, &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;) xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; proxy xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; [key]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;keys xs &lt;span class="fu"&gt;=&lt;/span&gt; henumerateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;)) xs ((&lt;span class="fu"&gt;:&lt;/span&gt;) &lt;span class="fu"&gt;.&lt;/span&gt; stringAssocKey) []&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-String.html#t:IsString"&gt;IsString&lt;/a&gt; のインスタンスであれば何でも良いので、&lt;strong&gt;String&lt;/strong&gt; に限らず &lt;strong&gt;Text&lt;/strong&gt;, &lt;strong&gt;ByteString&lt;/strong&gt; などを返すことができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; mapM_ putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; keys person&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;name&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;age&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; mapM_ Data.Text.IO.putStrLn &lt;span class="fu"&gt;$&lt;/span&gt; keys person&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;name&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;age&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/StringAssocKey.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/prettyprinter"&gt;prettyprinter&lt;/a&gt; パッケージの &lt;strong&gt;Pretty&lt;/strong&gt; のインスタンスを追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;prettyprinter パッケージについては&lt;a href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html"&gt;過去のブログ記事&lt;/a&gt;で少し紹介しているので、興味ある方はそちらをご確認ください。&lt;/p&gt;
&lt;p&gt;以下のような出力になるそうです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;[ name&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;DA&lt;/span&gt;&lt;span class="fu"&gt;-&lt;/span&gt;192H&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  weight&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="fl"&gt;260.0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;  price&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;120&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  featured&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;True&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;  description&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;High&lt;/span&gt;&lt;span class="fu"&gt;-&lt;/span&gt;quality (24bit 192kHz), lightweight portable &lt;span class="dt"&gt;DAC&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;  quantity&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;20&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;, name&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;HHP&lt;/span&gt;&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;150&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" data-line-number="8"&gt;  weight&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="fl"&gt;200.0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" data-line-number="9"&gt;  price&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;330&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" data-line-number="10"&gt;  featured&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" data-line-number="11"&gt;  description&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;Premium&lt;/span&gt; wooden headphone&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" data-line-number="12"&gt;  quantity&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;55&lt;/span&gt; ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;現状は &lt;code&gt;prettyprinter&lt;/code&gt; 側のバグ？で上手く表示されていないようですが、そのうち直ると思います。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; pretty person&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;{ name&lt;span class="fu"&gt;:&lt;/span&gt; bigmoon; age&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; pretty [person, person]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;[{ name&lt;span class="fu"&gt;:&lt;/span&gt; bigmoon; age&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; }, { name&lt;span class="fu"&gt;:&lt;/span&gt; bigmoon; age&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; }]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Pretty.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/th-lift"&gt;th-lift&lt;/a&gt; の &lt;strong&gt;Lift&lt;/strong&gt; のインスタンスを追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lift&lt;/strong&gt; のインスタンスになったので例えば、&lt;strong&gt;Data.Yaml.TH&lt;/strong&gt; モジュールの &lt;a href="https://www.stackage.org/haddock/lts-11.9/yaml-0.8.30/Data-Yaml-TH.html#v:decodeFile"&gt;decodeFile&lt;/a&gt; 関数を使ってコンパイル時に &lt;strong&gt;yaml&lt;/strong&gt; ファイルから一気に拡張可能レコードを作り上げることができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;config ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;config &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$$&lt;/span&gt;(Yaml.TH.decodeFile &lt;span class="st"&gt;&amp;quot;config.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行例:&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="co"&gt;# config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;span class="fu"&gt;age:&lt;/span&gt;&lt;span class="at"&gt; 10&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; config&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;name &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; age &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Lift.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndexFor"&gt;hmapWithIndexFor&lt;/a&gt; を追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndex"&gt;hmapWithIndex&lt;/a&gt; の制約付きバージョンです。&lt;/p&gt;
&lt;p&gt;例えば以下のようにして拡張可能レコードから &lt;strong&gt;aeson&lt;/strong&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-11.9/aeson-1.2.4.0/Data-Aeson.html#t:Value"&gt;Value&lt;/a&gt; をフィールドとして持つ拡張可能レコードに変換できます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toJSONRecord ::&lt;/span&gt; &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;ValueIs&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;) xs &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Const&amp;#39;&lt;/span&gt; &lt;span class="dt"&gt;Value&lt;/span&gt;) xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;toJSONRecord &lt;span class="fu"&gt;=&lt;/span&gt; hmapWithIndexFor c &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;    &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Const&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; toJSON &lt;span class="fu"&gt;.&lt;/span&gt; view _Wrapper&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt; c &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; (&lt;span class="dt"&gt;ValueIs&lt;/span&gt; &lt;span class="dt"&gt;ToJSON&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行例:&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; person&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;name &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; age &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; toJSONRecord person&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;name &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; age &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="fl"&gt;10.0&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/HmapWithIndexFor.hs"&gt;完全なコード&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Const-39-"&gt;Const’&lt;/a&gt; に Monoid のインスタンスを追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Wrapper"&gt;Wrapper&lt;/a&gt; に Either e のインスタンスを追加しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;extensible&lt;/strong&gt; パッケージは初見では全く使い方がわからないレベルで難しいですが、実際に使ってみると、今までリアルワールド Haskell っぽいコードだね。仕方ないね。と妥協していた部分がとても綺麗に書けるようになります。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.hask.moe/"&gt;extensible 攻略Wiki&lt;/a&gt; の内容はこれからもっと充実して行くので、気になる人はチェックしてみてください！&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html</id><title type="text">Haskell で型安全に YAML ファイルをビルド時に埋め込む</title><updated>2018-05-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Haskell で型安全に YAML ファイルをビルド時に埋め込む&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-05-13" itemprop="datePublished"&gt;
        May 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/haskell.html"&gt;haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;ザックリ言えば「&lt;a href="https://ryota-ka.hatenablog.com/entry/2018/02/14/103000"&gt;Template Haskell でコード中に JSON を埋め込んだりコンパイル時にファイルから型安全に読み込んだりする - ryota-ka’s blog&lt;/a&gt;」という記事の YAML 版です．&lt;/p&gt;
&lt;p&gt;ただし，ryota さんの記事では Template Haskell を解説しながら JSON を読み込む関数を定義していますが， YAML 版は &lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt; パッケージに同様の関数が既にあるので特に解説はしません． あくまでも Haskell の型システムとメタプログラミングを感じてもらえたらなぁと．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ソースコードは全てこの&lt;a href="https://github.com/matsubara0507/sample-yaml-th"&gt;リポジトリ&lt;/a&gt;にまとめてある．&lt;/p&gt;
&lt;h1 id="yaml-を埋め込む"&gt;YAML を埋め込む&lt;/h1&gt;
&lt;p&gt;次のような設定ファイルに関する型があったとします．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yaml パッケージで YAML にデコードするためには &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; の &lt;a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:FromJSON"&gt;&lt;code&gt;FromJSON&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスである必要がある． &lt;code&gt;FromJSON&lt;/code&gt; のインスタンスに凝ってもしょうがないので，今回は &lt;code&gt;Generics&lt;/code&gt; を使って適当に定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Generics&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Config&lt;/code&gt; 型のデフォルト値を YAML ファイルで記述したいとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="fu"&gt;languageExtensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これをコンパイル時に埋め込んでかつ型検査も行いたい． そのためには Template Haskell と yaml パッケージの &lt;a href="https://hackage.haskell.org/package/yaml-0.8.30/docs/Data-Yaml-TH.html#v:decodeFile"&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt;&lt;/a&gt; 関数を用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;decodeFile ::&lt;/span&gt; (&lt;span class="dt"&gt;Lift&lt;/span&gt; a, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; a) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; (&lt;span class="dt"&gt;TExp&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;TExp a&lt;/code&gt; 型というのは型付きの &lt;code&gt;Exp&lt;/code&gt; 型らしいが，ぼくはあまりよく分からないので割愛． 型を見ればわかるように，&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにもなってなきゃいけない． &lt;code&gt;DerivingLift&lt;/code&gt; 言語拡張を使えば簡単に定義できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveLift #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; import &lt;span class="dt"&gt;Language.Haskell.TH.Syntax&lt;/span&gt; &lt;span class="co"&gt;-- template-haskell package&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;, &lt;span class="dt"&gt;Lift&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使い方は簡単で，次のようにすればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="ot"&gt;defaultConfig ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;defaultConfig &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$$&lt;/span&gt;(decodeFile &lt;span class="st"&gt;&amp;quot;./template/.config.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点として，Template Haskell の制約より &lt;code&gt;Config&lt;/code&gt; 型の定義と &lt;code&gt;defaultConfig&lt;/code&gt; 関数の定義は別ファイルに分けなければいけない．&lt;/p&gt;
&lt;h2 id="試す"&gt;試す&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; defaultConfig
Config {columns = 80, languageExtensions = []}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;試しに間違えてみよう&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat template/.config.yaml
column: 80
languageExtensions: []
$ stack build
sample-yaml-th-0.1.0.0: build (lib)
Preprocessing library for sample-yaml-th-0.1.0.0..
Building library for sample-yaml-th-0.1.0.0..
[1 of 2] Compiling Sample.Config.Internal ( src\Sample\Config\Internal.hs, .stack work\dist\5c8418a7\build\Sample\Config\Internal.o )
[2 of 2] Compiling Sample.Config    ( src\Sample\Config.hs, .stack-work\dist\5c8418a7\build\Sample\Config.o )

C:\Users\hoge\haskell\sample-yaml-th\src\Sample\Config.hs:14:20: error:
    • Aeson exception:
Error in $: key &amp;quot;columns&amp;quot; not present
    • In the Template Haskell splice
        $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In the expression: $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In an equation for ‘defaultConfig’:
          defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |
14 | defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="おまけ-with-extensible"&gt;おまけ : with Extensible&lt;/h1&gt;
&lt;p&gt;さぁココからが本題！ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; という神パッケージを使ってリファクタリングをしてみよう！！&lt;/p&gt;
&lt;h2 id="問題点"&gt;問題点&lt;/h2&gt;
&lt;p&gt;大した問題ではないんだけど&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;ファイルを分けなければいけないのが悲しい&lt;/li&gt;
&lt;li&gt;YAML のキーがキャメルケース(&lt;code&gt;languageExtensions&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="extensible-パッケージ"&gt;extensible パッケージ&lt;/h2&gt;
&lt;p&gt;言わずもがな，拡張可能なレコードやバリアントを提供するパッケージだ． (詳しくは，最近急ピッチで充実されている&lt;a href="https://wiki.hask.moe/"&gt;攻略Wiki&lt;/a&gt;を読むといいんじゃないんかな？)&lt;/p&gt;
&lt;p&gt;例えば，さっきから使っている &lt;code&gt;Config&lt;/code&gt; 型を &lt;code&gt;extensible&lt;/code&gt; レコード型で書くと次のように書ける&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds     #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;地味にうれしいことに，extensible であれば関数名では許されないハイフンが含んだフィールド名も定義できるのだ．&lt;/p&gt;
&lt;h2 id="リファクタリング"&gt;リファクタリング&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt; を使うには &lt;code&gt;FromJSON&lt;/code&gt; 型クラスと &lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにしなければいけない． でも安心して欲しい． どちらも最新の extensible-0.4.9 では定義済みだ(そして extensible のレコードは &lt;code&gt;type&lt;/code&gt; 宣言なので追加でインスタンスを定義する必要は無い)．&lt;/p&gt;
&lt;p&gt;ただし，extensible-0.4.9 はまだ Stackage の LTS にも nightly にも追加されていないので &lt;code&gt;stack.yaml&lt;/code&gt; に追加する必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-11.9&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; extensible-0.4.9&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスは extensible で定義済みなので1つ目のファイルを分けるはクリアーだ． 実は2つもクリアーしている． 拡張可能レコードの &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスは &lt;code&gt;&amp;quot;path-format&amp;quot;&lt;/code&gt; のようなハイフンを含んだ文字列もそのまま扱ってくれる．&lt;/p&gt;
&lt;p&gt;以下が extensible 版の &lt;code&gt;Config&lt;/code&gt; 型に対応する YAML ファイルだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.extensible-config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;span class="fu"&gt;language-extensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに実行してみよう！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; Sample.Extensible.Config.defaultConfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="デフォルトで置き換える"&gt;デフォルトで置き換える&lt;/h2&gt;
&lt;p&gt;最後に簡単な実行ファイルを実装してみる． 設定ファイルのパスを与えると読みに行き，足りない部分は先ほどから埋め込んでるデフォルト値に置き換えて出力するモノだ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;quot;./template/.example.yaml&amp;quot;
columns: 100
$ stack exec -- pconfig &amp;quot;./template/.example.yaml&amp;quot;
columns @= 100 &amp;lt;: language-extensions @= [] &amp;lt;: nil
$ stack exec -- pconfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もちろんパスにファイルが無ければデフォルトのモノを出力するだけだ．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;さてどうすれば良いだろうか？ 例えば，&lt;code&gt;FromJSON&lt;/code&gt; 型クラスの &lt;code&gt;Meybe a&lt;/code&gt; 型のインスタンスはフィールドが無い場合に &lt;code&gt;Nothing&lt;/code&gt; を与えてくれるので， &lt;code&gt;Config&lt;/code&gt; 型の各フィールドを &lt;code&gt;Maybe&lt;/code&gt; でラップするというのはどうだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Maybe Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;フィールドが2つなら良いが多くなってきたら辛そうだ…&lt;/p&gt;
&lt;h3 id="必殺-nullable"&gt;必殺 Nullable&lt;/h3&gt;
&lt;p&gt;全てを &lt;code&gt;Meybe&lt;/code&gt; でラップする場合は &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使うと良いだろう(ないしは &lt;code&gt;RecordOf Maybe&lt;/code&gt;)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nullable h :* xs&lt;/code&gt; も既に &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスになっているのでそのまま YAML を読み込める． あとは次のようなデフォルト値と &lt;code&gt;Nullable&lt;/code&gt; を与えたら &lt;code&gt;Nothing&lt;/code&gt; の部分だけデフォルト値で置き換えた値を返す関数を実装してやればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;fromNullable ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; h) &lt;span class="fu"&gt;:*&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;fromNullable def &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  hmapWithIndex &lt;span class="fu"&gt;$&lt;/span&gt; \m x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; fromMaybe (hlookup m def) (getNullable x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;extensible ならこうやって全てのフィールドに対し走査する関数が使える．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;あとはこんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE NoImplicitPrelude #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO.Directory&lt;/span&gt;      (doesFileExist)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt;          &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" data-line-number="14"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" data-line-number="15"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" data-line-number="16"&gt;  path &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; listToMaybe &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-17" data-line-number="17"&gt;  config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readConfigWith defaultConfig path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-18" data-line-number="18"&gt;  hPutBuilder stdout &lt;span class="fu"&gt;$&lt;/span&gt; encodeUtf8Builder (tshow config)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-20" data-line-number="20"&gt;&lt;span class="ot"&gt;readConfigWith ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-21" data-line-number="21"&gt;readConfigWith def path &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-22" data-line-number="22"&gt;  file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readFileBinaryWith &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-23" data-line-number="23"&gt;  &lt;span class="kw"&gt;if&lt;/span&gt; Y.decodeEither file &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; &lt;span class="dt"&gt;Y.Null&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-24" data-line-number="24"&gt;    pure def&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-25" data-line-number="25"&gt;  &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-26" data-line-number="26"&gt;    config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either (error &lt;span class="fu"&gt;.&lt;/span&gt; show) pure &lt;span class="fu"&gt;$&lt;/span&gt; Y.decodeEither&amp;#39; file&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-27" data-line-number="27"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt; fromNullable def config&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-29" data-line-number="29"&gt;&lt;span class="ot"&gt;readFileBinaryWith ::&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-30" data-line-number="30"&gt;readFileBinaryWith def path &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-31" data-line-number="31"&gt;  doesFileExist path &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; bool (pure def) (readFileBinary path)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;いろいろとインポートするのがめんどくさくて &lt;code&gt;rio&lt;/code&gt; ライブラリを使っているが，あんまり気にしないで．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;ちなみに，&lt;a href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html"&gt;前回の記事&lt;/a&gt;に書いた &lt;a href="https://github.com/matsubara0507/taskpad"&gt;&lt;code&gt;taskpad&lt;/code&gt;&lt;/a&gt; にこの機能を追加してる．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html</id><title type="text">オレ的 Haskell で CLI を作る方法 2018</title><updated>2018-05-10T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;オレ的 Haskell で CLI を作る方法 2018&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-05-10" itemprop="datePublished"&gt;
        May 10, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;現在 &lt;a href="https://github.com/matsubara0507/taskpad"&gt;TaskPad&lt;/a&gt; という簡易的なタスク管理(編集)ツールを Haskell で作っていて，少し CLI を作るうえでのオレ的ノウハウが溜まったのでメモっとく．&lt;/p&gt;
&lt;h2 id="taskpad"&gt;TaskPad&lt;/h2&gt;
&lt;p&gt;先に，何を作ってるかを書いておく． まだ完成していないが，気持ちは次のような Yaml ファイルを編集して自身のタスク管理をしようかなと考えている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="fu"&gt;memo:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="fu"&gt;tasks:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;1:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;done:&lt;/span&gt;&lt;span class="at"&gt; true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;children:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;    &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;2:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;done:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;    &lt;span class="fu"&gt;children:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; world&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;span class="fu"&gt;date:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;#39;20180504&amp;#39;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;現状できている CLI は次のような感じ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ taskpad --help
taskpad - operate daily tasks

Usage: taskpad [-v|--verbose] [-d|--date DATE] COMMAND [--version]

Available options:
  -v,--verbose             Enable verbose mode: verbosity level &amp;quot;debug&amp;quot;
  -d,--date DATE           Task&amp;#39;s date
  --version                Show version
  -h,--help                Show this help text

Available commands:
  new                      Create a new task file. Note: if don&amp;#39;t use --date
                           option then use today&amp;#39;s date.
  add                      Add Task
  done                     Done Task
  tasks                    Show Tasks&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;taskpad new&lt;/code&gt; で Yaml ファイルを生成し，&lt;code&gt;taskpad add &amp;quot;hoge&amp;quot;&lt;/code&gt; “hoge” というタスクを追加し，&lt;code&gt;taskpad done 1&lt;/code&gt; で1番目のタスクを完了したことにし，&lt;code&gt;taskpad tasks&lt;/code&gt; でタスクの一覧を出力する．&lt;/p&gt;
&lt;h2 id="ノウハウ"&gt;ノウハウ？&lt;/h2&gt;
&lt;p&gt;たぶん他ではあんまり書いてない，いくつかのことを書いておく．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;optparse-applicative + extensible を使った CLI のオプションパーサー
&lt;ul&gt;
&lt;li&gt;特にサブコマンドをバリアントで表現しているのが面白い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;optparse-applicative でバージョンを表示&lt;/li&gt;
&lt;li&gt;バリアントと型クラスを用いた分岐&lt;/li&gt;
&lt;li&gt;rio + extensible で大域変数&lt;/li&gt;
&lt;li&gt;rio を用いてロギング&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オプションパーサーに &lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; を用いている． オプションパーサーには &lt;a href="https://hackage.haskell.org/package/optparse-simple"&gt;optparse-simple&lt;/a&gt; や &lt;a href="https://hackage.haskell.org/package/optparse-generic"&gt;optparse-generics&lt;/a&gt; など他にもいくつかあるが，サブコマンドのような多少込み入ったコトをしようとすると optparse-applicative が欲しくなる． &lt;a href="https://hackage.haskell.org/package/rio"&gt;rio&lt;/a&gt; ライブラリは，なんとなく最近使っている alt. Prelude ライブラリ(詳しくは&lt;a href="https://github.com/commercialhaskell/rio#readme"&gt;本家の README&lt;/a&gt; か&lt;a href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html"&gt;前の僕の記事&lt;/a&gt;を読んで)． &lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; は Haskell の残念なレコード構文や直和型の代わりに，拡張可能なレコード・バリアント型を提供してくれる面白いパッケージだ．&lt;/p&gt;
&lt;h3 id="import-と言語拡張"&gt;import と言語拡張&lt;/h3&gt;
&lt;p&gt;extensible はかなり言語拡張を用いる． 以降では，めんどくさいので &lt;code&gt;import&lt;/code&gt; も含め明示的に扱わない． 以下のコードが先頭にくっついてるとビルドはできるはずだ(たぶん，試してない)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds             #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE FlexibleContexts      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE MultiParamTypeClasses #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell       #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeApplications      #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeFamilies          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;RIO.Text&lt;/span&gt;          &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO.Time&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Functor.Identity&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" data-line-number="16"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Proxy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" data-line-number="17"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;GHC.TypeLits&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" data-line-number="18"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Options.Applicative&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="extensible-で-optparse-applicative"&gt;extensible で optparse-applicative&lt;/h3&gt;
&lt;p&gt;少しだけ &lt;code&gt;optparse-applicative&lt;/code&gt; について説明しておく． optparse-applicative は CLI オプションをパースして任意の型にマッピングしてくれる． 主に次のようにして用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; run &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; execParser opts&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;    opts &lt;span class="fu"&gt;=&lt;/span&gt; info (options &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; helper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;         &lt;span class="fu"&gt;$&lt;/span&gt; fullDesc&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;        &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; header &lt;span class="st"&gt;&amp;quot;taskpad - operate daily tasks&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;&lt;span class="ot"&gt;options ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;options &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:execParser"&gt;&lt;code&gt;execParser&lt;/code&gt;&lt;/a&gt; 関数は &lt;code&gt;ParserInfo a -&amp;gt; IO a&lt;/code&gt; という型を持つ． &lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:helper"&gt;&lt;code&gt;helper :: Parser (a -&amp;gt; a)&lt;/code&gt;&lt;/a&gt; は &lt;code&gt;--help&lt;/code&gt; オプションを与えてくれる関数だ． &lt;code&gt;info&lt;/code&gt; 関数と &lt;code&gt;fullDesc&lt;/code&gt; や &lt;code&gt;header&lt;/code&gt; により，&lt;code&gt;Parser a&lt;/code&gt; 型のパーサーに対し &lt;code&gt;--help&lt;/code&gt; で出力する情報を追加して &lt;code&gt;ParserInfo a&lt;/code&gt; 型に変換する．&lt;/p&gt;
&lt;h4 id="型の定義"&gt;型の定義&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;extensible&lt;/code&gt; で &lt;code&gt;optparse-applicative&lt;/code&gt; を使うとは即ち，任意の型，ここでいう &lt;code&gt;Options&lt;/code&gt; 型が拡張可能レコードや拡張可能バリアントであるというシチュエーションだ． 今回は &lt;code&gt;Options&lt;/code&gt; 型をまずは次のように定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;verbose&amp;quot; &amp;gt;: Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;subcmd&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" data-line-number="8"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;new&amp;quot;   &amp;gt;: ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" data-line-number="9"&gt;   , &lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-12" data-line-number="12"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-14" data-line-number="14"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SubCmd&lt;/code&gt; 型が拡張可能なバリアント型だ． ちなみに，Haskell のプリミティブな代数型データ構造で記述すると以下のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; verbose ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; date    ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;  ,&lt;span class="ot"&gt; subcmd  ::&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;New&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Add&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Done&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Tasks&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自分的に，extensible を使う利点は3つある．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;フィールド名と関数名の名前空間が別なので衝突が無い&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; 宣言によりレコードに対しいちいち型クラスのインスタンスを定義する必要が無い(既にあるものは)&lt;/li&gt;
&lt;li&gt;型レベルリストによってフィールド全体に対する走査を行える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逆にデメリットは，(2) にも関係するのだが，&lt;code&gt;type&lt;/code&gt; 宣言のためインスタンスの定義が衝突することがしばしばある(これはインスタンスのスコープをコントロールできないという Haskell 全体での問題でもある)．&lt;/p&gt;
&lt;h4 id="拡張可能レコードのパーサー"&gt;拡張可能レコードのパーサー&lt;/h4&gt;
&lt;p&gt;まずは拡張可能レコード(&lt;code&gt;Options&lt;/code&gt; 型)のパーサーを書いてみる． バリアント(&lt;code&gt;SubCmd&lt;/code&gt; 型)のは &lt;code&gt;undefined&lt;/code&gt; としておこう． 細かい &lt;code&gt;optparse-applicative&lt;/code&gt; の構文は割愛する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;options ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;options &lt;span class="fu"&gt;=&lt;/span&gt; hsequence&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;verbose &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; switch (long &lt;span class="st"&gt;&amp;quot;verbose&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; short &lt;span class="ch"&gt;&amp;#39;v&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Enable verbose mode: verbosity level \&amp;quot;debug\&amp;quot;&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date    &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; optional (strOption (long &lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; short &lt;span class="ch"&gt;&amp;#39;d&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; metavar &lt;span class="st"&gt;&amp;quot;DATE&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Task&amp;#39;s date&amp;quot;&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd  &lt;span class="fu"&gt;&amp;lt;@=&amp;gt;&lt;/span&gt; subcmdParser&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拡張可能レコードの値を構築するには &lt;code&gt;#fieldName @= fieldValue&lt;/code&gt; というの &lt;code&gt;&amp;lt;:&lt;/code&gt; で直列につないでいく(細かくは extensible の解説記事を読んで)． &lt;code&gt;&amp;lt;@=&amp;gt;&lt;/code&gt; 演算子はモナドなフィールドの値を持ち上げてくれるバージョンの &lt;code&gt;@=&lt;/code&gt; 演算子だ． &lt;code&gt;$&lt;/code&gt; の右側は，正確には違うが，次の型のようなイメージとなる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ch"&gt;&amp;#39;[ Parser (&amp;quot;verbose&amp;quot; &amp;gt;: Bool)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt; , &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;    &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt; , &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;subcmd&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt; ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Haskeller っであれば，後はリスト型で言う &lt;code&gt;sequence&lt;/code&gt; できれば良さそうとわかるだろう． その型レベルリスト版が &lt;code&gt;hsequence&lt;/code&gt; だ．&lt;/p&gt;
&lt;h4 id="拡張可能バリアントのパーサー"&gt;拡張可能バリアントのパーサー&lt;/h4&gt;
&lt;p&gt;さて，今回の自分的なメインディッシュだ． 仮に通常の直和型であれば次のように書くだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; subparser&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt;   (pure &lt;span class="dt"&gt;New&lt;/span&gt; &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt;   (&lt;span class="dt"&gt;Add&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; strArgument (metavar &lt;span class="st"&gt;&amp;quot;TEXT&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;  (&lt;span class="dt"&gt;Done&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; argument auto (metavar &lt;span class="st"&gt;&amp;quot;ID&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; command &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; (pure &lt;span class="dt"&gt;Tasks&lt;/span&gt; &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;&lt;span class="ot"&gt;withInfo ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;withInfo opts &lt;span class="fu"&gt;=&lt;/span&gt; info (helper &lt;span class="fu"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; opts) &lt;span class="fu"&gt;.&lt;/span&gt; progDesc&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この程度のサブコマンドならそこまで複雑じゃなく書けた． しかし悲しいことに，例えば &lt;code&gt;command &amp;quot;tasks&amp;quot;&lt;/code&gt; の行が無くてもビルドは通る． 即ち，&lt;strong&gt;直和型に対し網羅性を型検査で保証することが出来ない&lt;/strong&gt;．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;対して extensible のバリアントならどうだろうか． 理想的にはバリアントと同じフィールドを持つレコードの各要素が &lt;code&gt;ParserInfo a&lt;/code&gt; であるような値から自動で導出してくれると良い． つまり次のように扱いたい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;subcmdParser ::&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; &lt;span class="dt"&gt;SubCmd&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;subcmdParser &lt;span class="fu"&gt;=&lt;/span&gt; variantFrom&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;new   &lt;span class="fu"&gt;@=&lt;/span&gt; (pure () &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Create a new task file. Note: if don&amp;#39;t use --date option then use today&amp;#39;s date.&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;add   &lt;span class="fu"&gt;@=&lt;/span&gt; (strArgument (metavar &lt;span class="st"&gt;&amp;quot;TEXT&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Task contents&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Add Task&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;done  &lt;span class="fu"&gt;@=&lt;/span&gt; (argument auto (metavar &lt;span class="st"&gt;&amp;quot;ID&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Done task from id&amp;quot;&lt;/span&gt;) &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Done Task&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;tasks &lt;span class="fu"&gt;@=&lt;/span&gt; (pure () &lt;span class="ot"&gt;`withInfo`&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Show Tasks&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="ot"&gt;variantFrom ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="dt"&gt;Variant&lt;/span&gt; xs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;variantFrom &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Wrapper&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Repr&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;  _Wrapper &lt;span class="fu"&gt;=&lt;/span&gt; id&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;@=&lt;/code&gt; と &lt;code&gt;&amp;lt;:&lt;/code&gt; で構築したレコードが &lt;code&gt;Record = RecordOf Identity&lt;/code&gt; ではなく，&lt;code&gt;RecordOf h&lt;/code&gt; であるためには &lt;code&gt;h&lt;/code&gt; が &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Wrapper.html#t:Wrapper"&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスである必要がある(というかインスタンスでありさえすれば良い)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;さてキモは &lt;code&gt;variantFrom&lt;/code&gt; だ． 通常の直和型版の &lt;code&gt;subcmdParser&lt;/code&gt; 関数を見ればわかるように，&lt;code&gt;command&lt;/code&gt; 関数で作成した値をモノイドで畳み込めばいいので，お察しの通り(??) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#v:hfoldMap"&gt;&lt;code&gt;hfoldMap&lt;/code&gt;&lt;/a&gt; を使う． ついでに &lt;code&gt;command&lt;/code&gt; の一引数目に渡すサブコマンドの文字列はフィールド名から取得するようにしよう． この場合，インデックスと &lt;code&gt;KnownSymbol&lt;/code&gt; 制約を渡す必要があるので &lt;code&gt;hfoldMap&lt;/code&gt; の代わりに &lt;code&gt;hfoldMapWithIndexFor&lt;/code&gt; 関数を使う．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;variantFrom ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="dt"&gt;Forall&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;) xs &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; &lt;span class="dt"&gt;ParserInfo&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (&lt;span class="dt"&gt;Variant&lt;/span&gt; xs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;variantFrom &lt;span class="fu"&gt;=&lt;/span&gt; subparser &lt;span class="fu"&gt;.&lt;/span&gt; subcmdVariant&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" data-line-number="5"&gt;    subcmdVariant &lt;span class="fu"&gt;=&lt;/span&gt; hfoldMapWithIndexFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; (&lt;span class="dt"&gt;KeyIs&lt;/span&gt; &lt;span class="dt"&gt;KnownSymbol&lt;/span&gt;)) &lt;span class="fu"&gt;$&lt;/span&gt; \m x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" data-line-number="6"&gt;      &lt;span class="kw"&gt;let&lt;/span&gt; k &lt;span class="fu"&gt;=&lt;/span&gt; symbolVal (proxyAssocKey m)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" data-line-number="7"&gt;      &lt;span class="kw"&gt;in&lt;/span&gt; command k ((&lt;span class="dt"&gt;EmbedAt&lt;/span&gt; m &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; pure) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getField x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;結果として，&lt;strong&gt;extensible のバリアント版は網羅性を型検査によって検証できるようになった！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="バージョンの表示"&gt;バージョンの表示&lt;/h3&gt;
&lt;p&gt;バージョンの表示は他のコマンドと違い，コマンドが間違って(例えばサブコマンドが無い)いても &lt;code&gt;--version&lt;/code&gt; という引数さえあれば優先的にバージョンを表示する必要がある． そのようなオプションを追加する場合には &lt;a href="http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative.html#v:infoOption"&gt;&lt;code&gt;infoOption&lt;/code&gt;&lt;/a&gt; 関数を使う．&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Paths_taskpad&lt;/span&gt;       &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Meta&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Version&lt;/span&gt;        (&lt;span class="dt"&gt;Version&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Version&lt;/span&gt;        &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Development.GitRev&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" data-line-number="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" data-line-number="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; run &lt;span class="fu"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; execParser opts&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" data-line-number="9"&gt;    opts &lt;span class="fu"&gt;=&lt;/span&gt; info (options &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; version Meta.version &lt;span class="fu"&gt;&amp;lt;**&amp;gt;&lt;/span&gt; helper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" data-line-number="10"&gt;         &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" data-line-number="12"&gt;&lt;span class="ot"&gt;version ::&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Parser&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-13" data-line-number="13"&gt;version v &lt;span class="fu"&gt;=&lt;/span&gt; infoOption (showVersion v)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; long &lt;span class="st"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; help &lt;span class="st"&gt;&amp;quot;Show version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-17" data-line-number="17"&gt;&lt;span class="ot"&gt;showVersion ::&lt;/span&gt; &lt;span class="dt"&gt;Version&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-18" data-line-number="18"&gt;showVersion v &lt;span class="fu"&gt;=&lt;/span&gt; unwords&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-19" data-line-number="19"&gt;  [ &lt;span class="st"&gt;&amp;quot;Version&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-20" data-line-number="20"&gt;  , Version.showVersion v &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-21" data-line-number="21"&gt;  , &lt;span class="st"&gt;&amp;quot;Git revision&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-22" data-line-number="22"&gt;  , &lt;span class="fu"&gt;$&lt;/span&gt;(gitHash)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-23" data-line-number="23"&gt;  , &lt;span class="st"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(gitCommitCount) &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="st"&gt;&amp;quot; commits)&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-24" data-line-number="24"&gt;  ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;**&amp;gt;&lt;/code&gt; 演算子はただの &lt;code&gt;flip (&amp;lt;*&amp;gt;)&lt;/code&gt; だ． ちなみに，&lt;code&gt;version&lt;/code&gt; と &lt;code&gt;helper&lt;/code&gt; の適用順を入れ替えると &lt;code&gt;--help&lt;/code&gt; の表示がほんの少しだけ変わる．&lt;/p&gt;
&lt;h3 id="バリアントと型クラス"&gt;バリアントと型クラス&lt;/h3&gt;
&lt;p&gt;こっからは &lt;code&gt;run :: Options -&amp;gt; IO ()&lt;/code&gt; 関数を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;  matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;    undefined &lt;span class="co"&gt;-- ???&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;    (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getTodaysDate&lt;/code&gt; 関数は自身で定義しているとする． &lt;code&gt;--date&lt;/code&gt; オプションを指定しなかった場合には今日の日付を取得する． 問題はサブコマンドの分岐だ．&lt;/p&gt;
&lt;p&gt;バリアントの分岐には &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; 関数を用いる． &lt;code&gt;matchField&lt;/code&gt; 関数の型は &lt;code&gt;RecordOf (Match h r) xs -&amp;gt; VariantOf h xs -&amp;gt; r&lt;/code&gt; となる． 一引数目のレコードと二引数目のバリアントの &lt;code&gt;xs&lt;/code&gt; が等しいということから共通のフィールドを期待しているのが分かるだろう． レコード側の各フィールドに，各バリアントに対するフィールドの値を受け取り &lt;code&gt;r&lt;/code&gt; 型の返り値の関数を記述するといった具合だ(この部分が &lt;code&gt;Match h r&lt;/code&gt; に集約されている)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;今回は，このレコードの構築に型クラスを用いる． 以下のような型クラスを定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  run&amp;#39; ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実装は置いておいて，インスタンスを与えてみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;add&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;  run&amp;#39; _ _ _ &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 関数の &lt;code&gt;matchField&lt;/code&gt; 関数の引数は次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;  matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;    (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m date &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;    (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Proxy @ Run&lt;/code&gt; の &lt;code&gt;@&lt;/code&gt; の部分は &lt;code&gt;TypeApplications&lt;/code&gt; 拡張のモノだ． フィールドの値は &lt;code&gt;Identity x&lt;/code&gt; 型として来るので &lt;code&gt;runIdentity&lt;/code&gt; 関数を用いて剥がし，&lt;code&gt;run' m date&lt;/code&gt; へと適用する． もちろんサブコマンドのインスタンスを書き忘れていた場合は，ちゃんと型検査に引っかかる！&lt;/p&gt;
&lt;h3 id="rio-で大域変数"&gt;rio で大域変数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; で大域変数を扱うには &lt;code&gt;RIO env&lt;/code&gt; モナドを用いる． 適当なアプリケーションモナドを定義してやろう． 今回はひとつしか大域変数が無いのであんまりメリットを感じないかもしれないが…&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;TaskPad&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" data-line-number="3"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" data-line-number="4"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot; &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-5" data-line-number="5"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; 関数も書き直してやる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;MonadUnliftIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;  date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date   &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;         &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;  runRIO env &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" data-line-number="7"&gt;    matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" data-line-number="8"&gt;      (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" data-line-number="9"&gt;      (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" data-line-number="11"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; kv &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-12" data-line-number="12"&gt;&lt;span class="ot"&gt;  run&amp;#39; ::&lt;/span&gt; proxy kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;AssocValue&lt;/span&gt; kv &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TaskPad&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに &lt;code&gt;new&lt;/code&gt; サブコマンドを書いてみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;  run&amp;#39; _ _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;    date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; asks (view &lt;span class="fu"&gt;#&lt;/span&gt;date)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;    writeMemo &lt;span class="fu"&gt;$&lt;/span&gt; mkMemo date&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mkMemo&lt;/code&gt; や &lt;code&gt;writeMemo&lt;/code&gt; については次のように定義している． &lt;code&gt;Memo&lt;/code&gt; 型も拡張可能レコードだ． 最近の extensible のアップデートで拡張可能レコードが &lt;code&gt;ToJson&lt;/code&gt; 型クラスと &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスになったので，Yaml への変換は特にインスタンスを書くことなく行えるようになった．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot;  &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;tasks&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="dt"&gt;Task&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;memo&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; [&lt;span class="dt"&gt;Text&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" data-line-number="7"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" data-line-number="9"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Task&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; (&lt;span class="dt"&gt;TaskFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;children&amp;quot; &amp;gt;: [SubTask]])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" data-line-number="10"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;SubTask&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; &lt;span class="dt"&gt;TaskFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" data-line-number="12"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;TaskFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" data-line-number="13"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;name&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" data-line-number="14"&gt;   , &lt;span class="st"&gt;&amp;quot;done&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" data-line-number="15"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-17" data-line-number="17"&gt;&lt;span class="ot"&gt;mkMemo ::&lt;/span&gt; &lt;span class="dt"&gt;Date&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-18" data-line-number="18"&gt;mkMemo date&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-19" data-line-number="19"&gt;    &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date  &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-20" data-line-number="20"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;tasks &lt;span class="fu"&gt;@=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-21" data-line-number="21"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;memo  &lt;span class="fu"&gt;@=&lt;/span&gt; mempty&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-22" data-line-number="22"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-23" data-line-number="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-24" data-line-number="24"&gt;&lt;span class="ot"&gt;writeMemo ::&lt;/span&gt; &lt;span class="dt"&gt;MonadIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Memo&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-25" data-line-number="25"&gt;writeMemo memo &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-26" data-line-number="26"&gt;  writeFileBinary (Text.unpack &lt;span class="fu"&gt;$&lt;/span&gt; memo &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;.yaml&amp;quot;&lt;/span&gt;) (Y.encode memo)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="rio-でロギング"&gt;rio でロギング&lt;/h3&gt;
&lt;p&gt;ロギングは実用アプリケーションの重要な要素だろう． &lt;code&gt;rio&lt;/code&gt; であればまぁまぁ簡単に書ける．&lt;/p&gt;
&lt;p&gt;まずは &lt;code&gt;Env&lt;/code&gt; にロギング用の関数を足してやる． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogFunc"&gt;&lt;code&gt;LogFunc&lt;/code&gt;&lt;/a&gt; 型や &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:HasLogFunc"&gt;&lt;code&gt;HasLogFunc&lt;/code&gt;&lt;/a&gt; 型クラスは &lt;code&gt;rio&lt;/code&gt; ライブラリに定義されているものだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;date&amp;quot;   &amp;gt;: Date&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;logger&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;LogFunc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-6" data-line-number="6"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-7" data-line-number="7"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens (view &lt;span class="fu"&gt;#&lt;/span&gt;logger) (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x &lt;span class="fu"&gt;&amp;amp;&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="ot"&gt;`set`&lt;/span&gt; y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実はこれだけで &lt;code&gt;TaskPad&lt;/code&gt; モナド(すなわち &lt;code&gt;RIO Env&lt;/code&gt; モナド)の中で自由にロギング関数を呼べるようになる． 試しに &lt;code&gt;new&lt;/code&gt; サブコマンドにロギングを足してみよう． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logInfo"&gt;&lt;code&gt;logInfo&lt;/code&gt;&lt;/a&gt; 関数がロギング関数のひとつだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;new&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;  run&amp;#39; _ _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;    date &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; asks (view &lt;span class="fu"&gt;#&lt;/span&gt;date)&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;    writeMemo &lt;span class="fu"&gt;$&lt;/span&gt; mkMemo date&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;    logInfo (display &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;create new task&amp;#39;s file: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; date &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あとは &lt;code&gt;run&lt;/code&gt; 関数を書き換えよう(&lt;code&gt;Env&lt;/code&gt; 型の中身が変わったので)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb23-1" data-line-number="1"&gt;&lt;span class="ot"&gt;run ::&lt;/span&gt; &lt;span class="dt"&gt;MonadUnliftIO&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Options&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" data-line-number="2"&gt;run opts &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" data-line-number="3"&gt;  date    &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; maybe getTodaysDate pure &lt;span class="fu"&gt;$&lt;/span&gt; opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" data-line-number="4"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;verbose)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-5" data-line-number="5"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \logger &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;date   &lt;span class="fu"&gt;@=&lt;/span&gt; date&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-7" data-line-number="7"&gt;           &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="fu"&gt;@=&lt;/span&gt; logger&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-8" data-line-number="8"&gt;           &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-9" data-line-number="9"&gt;    runRIO env &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-10" data-line-number="10"&gt;      matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-11" data-line-number="11"&gt;        (htabulateFor (&lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="fu"&gt;@&lt;/span&gt; &lt;span class="dt"&gt;Run&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; \m &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; run&amp;#39; m &lt;span class="fu"&gt;.&lt;/span&gt; runIdentity))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-12" data-line-number="12"&gt;        (opts &lt;span class="fu"&gt;^.&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;subcmd)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LogFunc&lt;/code&gt; 型の値を得るには &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:withLogFunc"&gt;&lt;code&gt;withLogFunc&lt;/code&gt;&lt;/a&gt; 関数を用いるのが良いだろう． &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#t:LogOptions"&gt;&lt;code&gt;LogOptions&lt;/code&gt;&lt;/a&gt; 型の値(ここでいう &lt;code&gt;logOpts&lt;/code&gt;)を生成する &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logOptionsHandle"&gt;&lt;code&gt;logOptionsHandle&lt;/code&gt;&lt;/a&gt; 関数の二引数目に &lt;code&gt;True&lt;/code&gt; を与えることでログがデバッグ仕様になる(そういえば &lt;code&gt;Options&lt;/code&gt; 型には &lt;code&gt;--verbose&lt;/code&gt; オプションがあった)． ちなみに，デバッグ仕様のときにだけ表示するロギング関数として &lt;a href="https://hackage.haskell.org/package/rio-0.1.2.0/docs/RIO.html#v:logDebug"&gt;&lt;code&gt;logDebug&lt;/code&gt;&lt;/a&gt; 関数がある．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;早く完成させるぞ&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html</id><title type="text">Stack 1.7.1 がリリースされました。</title><updated>2018-05-04T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;4月28日に Stack version 1.7.1 が&lt;a href="https://github.com/commercialhaskell/stack/blob/v1.7.1/ChangeLog.md#v171"&gt;リリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;更新は以下のコマンドですぐに終わります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack upgrade
...

$ stack --version
Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h2 id="リリースノート"&gt;リリースノート&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aarch64 (64ビットARM) で初めて stack が利用できるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;stack のダウンロードリンクが &lt;code&gt;https://www.stackage.org/stack/&lt;/code&gt; から &lt;code&gt;https://get.haskellstack.org/stable/&lt;/code&gt; に変わりました。&lt;/p&gt;
&lt;p&gt;各種バイナリへのリンクは &lt;code&gt;https://get.haskellstack.org/stable/&amp;lt;PLATFORM&amp;gt;.&amp;lt;EXTENSION&amp;gt;&lt;/code&gt; という形式になるようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHC 8.2.2 への対応が困難なため、静的にリンクされた Alpile Linux 向け stack は利用できなくなりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2387"&gt;Official support for Alpine Linux #2387&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/14739"&gt;Cannot compile ghc 8.2.1 or 8.2.2 on armv7l architectures&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GHC 8.2.2 から CentOS 6 の 32-bit Linux GMP4 はサポートされなくなりました。そのため stack も利用できなくなりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3613"&gt;linux64-gmp4 variant for GHC 8.2.2 #3613&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9a23b91bd1ba4d120a77c9982e85079f825ebf06&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;実際の&lt;a href="https://github.com/commercialhaskell/stack/blob/9a23b91bd1ba4d120a77c9982e85079f825ebf06/etc/scripts/get-stack.sh#L224"&gt;コード&lt;/a&gt;を見てみるとまだ使えそうな気がしますが、stack 1.7.1 からは&lt;a href="https://github.com/commercialhaskell/stack/releases/download/v1.7.1/stack-1.7.1-linux-i386-gmp4.tar.gz"&gt;リンク切れ&lt;/a&gt;になります。(stack v1.6.5 とかであれば&lt;a href="https://github.com/commercialhaskell/stack/releases/download/v1.6.5/stack-1.6.5-linux-i386-gmp4.tar.gz"&gt;ダウンロード可能&lt;/a&gt;です。)&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;  &lt;span class="kw"&gt;else&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;    &lt;span class="ex"&gt;install_dependencies&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="va"&gt;$1&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt; in&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;      &lt;span class="st"&gt;&amp;quot;6&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;        &lt;span class="ex"&gt;print_bindist_notice&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;libgmp4&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;        &lt;span class="ex"&gt;install_32bit_gmp4_linked_binary&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;        &lt;span class="kw"&gt;;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;      *&lt;span class="kw"&gt;)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;        &lt;span class="ex"&gt;print_bindist_notice&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;        &lt;span class="ex"&gt;install_32bit_standard_binary&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;        &lt;span class="kw"&gt;;;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;esac&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;fi&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="大きな変更"&gt;大きな変更&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cabal のバージョンを 2.0 から 2.2 にアップグレードしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3878"&gt;Switch to Cabal 2.2 (prerelease) #3878&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="変更点"&gt;変更点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GCC を利用する Linux ディストリビューションで、デフォルトで PIE が有効になっている場合、&lt;code&gt;stack setup&lt;/code&gt; コマンドは異なる GHC 設定オプションを利用しなくなりました。ghc-8.0.2 から GHC は自分自身で検出できるようになり、Stack’s attempted workaround for older versions caused more problems than it solved.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3636"&gt;Setup fails with ‘No information found for ghc-8.2.2’ for OS key ‘linux64-ncurses6-nopie’ #3636&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3715"&gt;setup: improvements to selecting bindists on Linux #3715&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/fpco/stackage-content/pull/34"&gt;stack-setup-2: nopie fixes for Arch, Gentoo, and Void Linux #34&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;いまいち良くわかってないですが、&lt;a href="https://github.com/commercialhaskell/stack/pull/3715/files#diff-4968f87e674615592e572f2ec593e5b0L558"&gt;コードの差分&lt;/a&gt;を見ると &lt;code&gt;noPie&lt;/code&gt; に関する部分が全部削除されてるので、その辺りを GHC が上手く処理するようになったんでしょう・・・。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack new&lt;/code&gt; コマンドは、プロジェクトテンプレートに stack.yaml ファイルが含まれる場合に、初期化処理を行わないようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3888"&gt;Initialize a new project only when no stack.yaml #3888&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今まで通り &lt;code&gt;stack.yaml&lt;/code&gt; が含まれている場合でも初期化させたい場合は&lt;code&gt;forceOverwrite initOpts&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; になれば良いので、&lt;code&gt;--force&lt;/code&gt; フラグをつければ良さそうですね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode diff"&gt;&lt;code class="sourceCode diff"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="st"&gt;-        initProject IsNewCmd dir initOpts globalResolver&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="va"&gt;+        exists &amp;lt;- doesFileExist $ dir &amp;lt;/&amp;gt; stackDotYaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="va"&gt;+        when (forceOverwrite initOpts || not exists) $&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="va"&gt;+            initProject IsNewCmd dir initOpts globalResolver&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="その他の改良点"&gt;その他の改良点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack に新たなサブコマンド &lt;code&gt;ls&lt;/code&gt; が導入されました。このコマンドによってローカル及びリモートのスナップショットを確認することができます。詳細は &lt;code&gt;stack ls snapshots --help&lt;/code&gt; コマンドでご確認ください。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/1614"&gt;A new stack show command and missing informative commands #1614&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3252"&gt;Introduce new sub command ls #3252&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;過去の&lt;a href="../2017/12-20-stack-ls-command.html"&gt;ブログ記事&lt;/a&gt;で紹介しているので気になる方はご参照ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;list-dependencies&lt;/code&gt; コマンドが廃止されます。同等の機能は &lt;code&gt;ls dependencies&lt;/code&gt; コマンドで引き続き提供されます。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3669"&gt;Stack list-dependencies : Bring it under the new ls umbrella command #3669&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3706"&gt;Port &lt;code&gt;list-dependencies&lt;/code&gt; under the new ls sub command #3706&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;v1.7.1 ではまだ利用できますが、以下のように &lt;code&gt;DEPRECATED&lt;/code&gt; メッセージが表示されます。一応 v1.8 で削除される予定です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;stack&lt;/span&gt; list-dependencies&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ex"&gt;DEPRECATED&lt;/span&gt;: Use ls dependencies instead. Will be removed in next major version.&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ex"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全ての HTTP リクエストヘッダに User-Agent が追加されるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3628"&gt;Specify User-Agent to get over my company’s firewall #3628&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3682/"&gt;Specify User-Agent on every HTTP request (#3628) #3682&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;今までは &lt;code&gt;User-Agent&lt;/code&gt; が付いていなかったみたいですが、&lt;code&gt;The Haskell Stack&lt;/code&gt; が全てのHTTPリクエストに対して付与されるようになったみたいです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode diff"&gt;&lt;code class="sourceCode diff"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="va"&gt;+setUserAgent :: Request -&amp;gt; Request&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="va"&gt;+setUserAgent = setRequestHeader &amp;quot;User-Agent&amp;quot; [&amp;quot;The Haskell Stack&amp;quot;]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack setup&lt;/code&gt; コマンドは互換性のある GHC をインストールするために、任意の OS キーによるインストールを試すようになりました (これは OS キーをどれか1つだけチェックするよりも良い方法です)。この変更は Linux の各ディストリビューションで libinfo 5/6, ncurses 5/6, gmp 4/5 の異なった組み合わせに起因するものです。今後の GHC リリースを見据えて、セットアップに関する YAML メタデータをシンプルに保つことができます。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3521"&gt;Check for ncurses6 before checking for tinfo6 #3521&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3715"&gt;setup: improvements to selecting bindists on Linux #3715&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ビルドプログレスバーが現在ビルドしているパッケージ名を表示するようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3763"&gt;Report currently building packages along with “Progress:” label #3763&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;変更前の表示結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Progress: 3/74&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更後の表示結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Progress: 3/74; [Cabal-2.0.1.1|basement-0.0.4|old-time-1.1.0.3|simple-sendfile-0.2.26|stm-2.4.4.1|stringsearch-0.3.6.6]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack setup --verbose&lt;/code&gt; の出力に GHC 設定処理のログを含めるようにしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3716"&gt;“stack setup –verbose” should also cause verbose output of GHC configure process if possible #3716&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3712"&gt;Never ending “Configuring GHC…” #3712&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3740"&gt;Log GHC configure output on &lt;code&gt;stack -v setup&lt;/code&gt; #3740&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;変更前は以下のように &lt;code&gt;Configuring GHC ...&lt;/code&gt; で何も表示されていなかったようです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build --verbose
...

2017-12-27 00:30:23.869257: [debug] Run process: /home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2.temp/ghc-8.0.2/configure --prefix=/home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2/
@(System/Process/Log.hs:37:3)
Configuring GHC ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変更後は、こんな感じのログが続いて表示されるようになったようです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;...
018-01-03 10:49:29.280793: [debug] Run process within /home/kp/.stack/programs/x86_64-linux/ghc-7.10.3.temp/ghc-7.10.3/: /usr/bin/make install
@(subs/rio/src/RIO/Process.hs:191:3)
2018-01-03 10:49:29.304283: [info] /usr/bin/make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.737966: [info] &amp;quot;rm&amp;quot; -f utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.739872: [info] echo &amp;quot;module Version where&amp;quot;                    &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.741026: [info] echo &amp;quot;version, targetOS, targetARCH :: String&amp;quot; &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.742170: [info] echo &amp;quot;version    = \&amp;quot;7.10.3\&amp;quot;&amp;quot;      &amp;gt;&amp;gt; utils/ghc-pkg/dist-install/build/Version.hs&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ファイルパスまたは git 参照から &lt;code&gt;extra-dep&lt;/code&gt; が見つからなかった時のエラーメッセージが改善されました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3806"&gt;Confusing error message when a cabal file for an extra-dep can’t be found #3806&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3808"&gt;When a cabal file can’t be found, warn that extra-deps could be the problem too #3808&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;こんな感じでエラーメッセージが改善されたようです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png" target="_blank"&gt;&lt;img src="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows 環境では Nix インテグレーションがサポートされていないため、明示的にフラグを有効にした場合でも常に無効になるように変更しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3600"&gt;Nix doesn’t work on Windows #3600&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3833"&gt;Disable nix on windows (#3600) #3833&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack build&lt;/code&gt; に &lt;code&gt;--keep-tmp-files&lt;/code&gt; フラグを追加しました。デバッグ目的のため一時的に作成したファイルやディレクトリを削除せずに残しておくことができます。このフラグは同等の機能を持つ ghc オプションと同時に使うと良いでしょう。例: &lt;code&gt;stack build --keep-tmp-files --ghc-options=-keep-tmp-files&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3857"&gt;How to keep temporary files on build failures? #3857&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3858"&gt;stack build: Add –keep-tmp-files flag. Fixes #3857 #3858&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;build&lt;/code&gt; セクションに指定することもできるようです。(デフォルト値は &lt;code&gt;False&lt;/code&gt;)&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;build:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;library-profiling:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;executable-profiling:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;copy-bins:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="fu"&gt;prefetch:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;  &lt;span class="fu"&gt;keep-going:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;  &lt;span class="fu"&gt;keep-tmp-files:&lt;/span&gt;&lt;span class="at"&gt; false&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;スナップショットのパーズ例外時のエラーメッセージを改善しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3879"&gt;Improved error messages for snapshot parse exceptions #3879&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack unpack&lt;/code&gt; コマンドに &lt;code&gt;--to /target/directory&lt;/code&gt; オプションが追加されました。パッケージの展開先を指定できるようになります。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3904"&gt;Possibility to specify a base path to unpack a package #3904&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3947"&gt;Add –to option to the unpack command to specify destination #3947&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack hoogle&lt;/code&gt; コマンドに &lt;code&gt;--server&lt;/code&gt; オプションが追加されました。ローカルのポート8080番で Hoogle サーバーが起動します。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2310"&gt;Add &lt;code&gt;stack hoogle --server&lt;/code&gt; command #2310&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3941"&gt;Introduce Hoogle server command line option #3941&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack hoogle --server&lt;/code&gt; は &lt;code&gt;stack hoogle -- server --local --port 8080&lt;/code&gt; の省略形です。&lt;/p&gt;
&lt;h3 id="リリースノートに載ってない変更"&gt;リリースノートに載ってない変更&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extra-deps&lt;/code&gt; で &lt;code&gt;github&lt;/code&gt; という短縮形が使えるようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3873"&gt;Allow github shorthand for extra-deps #3873&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3890"&gt;Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下のように書くことができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; commercialhaskell/rio&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 09654f9fcbdcd96d0f5102796b32fdac5da7260e&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;commit&lt;/code&gt; は短縮して記述することもできます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;span class="at"&gt; commercialhaskell/rio&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;09654&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/mitchellwrosen/stack/blob/9489cf7d12c54ea40ab043e199d7850d2502e140/src/test/Stack/Types/BuildPlanSpec.hs"&gt;BuildPlanSpec.hs&lt;/a&gt; にテストがいくつか載っていいるので、そこを見れば利用可能な形式がわかります。&lt;/p&gt;
&lt;h3 id="バグフィックス"&gt;バグフィックス&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました。この修正により、スクリプト実行時に – +RTS … -RTS を渡せるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3658"&gt;Error when using RTS options with the Stack script interpreter #3658&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3668"&gt;Put file arguments first when stack is run as script interpreter #3658 #3668&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack 設定ファイルで year パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2275"&gt;stack new – AesonException #2275&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3701"&gt;Fix use of and document year template parameter #3701&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3663"&gt;Benchmarks are run in parallel #3663&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3666"&gt;Never run benchmarks concurrently, always output to console #3663 #3666&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack ghci で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3776"&gt;Add rio package as a dep of stack #3776&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3779"&gt;With ghci, allow multiple packages to use the same module #3776 #3779&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack ghci で base の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、base を置き換えているコードも同様に読み込めるようになります。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3589"&gt;stack ghci at global level missing base #3589&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5"&gt;196bdbae986ddf887f92999b26129085a8ed0be5&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/99950cfae2e014f76abbebd51869e5cae5f00a6a"&gt;99950cfae2e014f76abbebd51869e5cae5f00a6a&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="./02-21-stack165.html"&gt;v.1.6.5&lt;/a&gt; の時に紹介したので、そちらをご確認ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack ghci&lt;/code&gt; コマンドで autogen ファイルのパスを適切に扱えるようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3791"&gt;Adjust &lt;code&gt;-i&lt;/code&gt; paths used by ghci to point to autogen / etc files generated by newer Cabal #3791&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3795"&gt;Use per-component build directories for ghci with Cabal&amp;gt;=2.0 #3791 #3795&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;stack はサブディレクトリを含むパッケージを常に再コンパイルしていました。現在は修正され、サブディレクトリを再コンパイルする必要がある時だけ行うようになりました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3899"&gt;hakyll dependency on nightly is not cached #3899&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3955"&gt;Don’t recompile in presence of sublibraries #3955&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;特に &lt;code&gt;Hakyll&lt;/code&gt; や &lt;code&gt;Pandoc&lt;/code&gt; (依存しているライブラリも同様に影響を受ける) を使う場合に踏み抜く可能性があるため、影響を受けている人はアップグレード推奨です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get-stack.sh&lt;/code&gt; インストールスクリプトにおいて Debian/Fedora/CentOS の依存関係のインストールをドキュメントの手動で行う場合と一致するように修正しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/commit/9dfff2760b659c84605028002cd6500cdb52c823#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;9dfff2760b659c84605028002cd6500cdb52c823&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2"&gt;Manual Download&lt;/a&gt; の内容と同様の処理になりました。(&lt;code&gt;git&lt;/code&gt; と &lt;code&gt;gnupg&lt;/code&gt; が追加されました)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Nix を利用する場合に gmp で Cabal-simple をコンパイルするように修正しました。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/2944"&gt;Nix: stack should compile setup-Simple-Cabal with libgmp #2944&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3971"&gt;#2944: Compile Cabal-simple with gmp when using Nix #3971&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;stack ghci&lt;/code&gt; コマンドの stack 処理は ghci で置き換えられました。これによりシグナルハンドリングの動作が改善されます。特に Ctrl-C のハンドリングが改善されます。そのため、生成されたファイルは終了後に残ります。このパスはファイルコンテンツのハッシュにより決まり、システムの一時的なディレクトリに保存されます。そのため、必要に応じて綺麗にしましょう。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="border narrow"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
issue
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/issues/3821"&gt;stack repl exits on ctrl+c with error &lt;stdin&gt;: hGetChar: hardware fault (Input/output error) #3821&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
PR
&lt;/th&gt;
&lt;td&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href="https://github.com/commercialhaskell/stack/pull/3869"&gt;Fix stack ghci ctrl c 3821 #3869&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
commit
&lt;/th&gt;
&lt;td&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;stack repl&lt;/code&gt; を実行すると、実際にはこんな感じでディレクトリとファイルが作られます。&lt;code&gt;ba125cb0&lt;/code&gt; や &lt;code&gt;e4ed4429&lt;/code&gt; というファイル名はファイルのコンテンツハッシュによって決まるそうです。(&lt;code&gt;tmp&lt;/code&gt; というディレクトリ名は環境によって異なります)&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;tree&lt;/span&gt; /tmp/haskell-stack-ghci/&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ex"&gt;/tmp/haskell-stack-ghci/&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;├── &lt;span class="ex"&gt;ba125cb0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;│   └── &lt;span class="ex"&gt;cabal_macros.h&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;└── &lt;span class="ex"&gt;e4ed4429&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;    └── &lt;span class="ex"&gt;ghci-script&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;&lt;span class="ex"&gt;2&lt;/span&gt; directories, 2 files&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="changelog-オリジナル"&gt;Changelog (オリジナル)&lt;/h2&gt;
&lt;h3 id="release-notes"&gt;Release notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;aarch64 (64-bit ARM) bindists are now available for the first time.&lt;/li&gt;
&lt;li&gt;Statically linked Linux bindists are no longer available, due to difficulty with GHC 8.2.2 on Alpine Linux.&lt;/li&gt;
&lt;li&gt;32-bit Linux GMP4 bindists for CentOS 6 are no longer available, since GHC 8.2.2 is no longer being built for that platform.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="major-changes"&gt;Major changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Upgrade from Cabal 2.0 to Cabal 2.2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="behavior-changes"&gt;Behavior changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack setup&lt;/code&gt; no longer uses different GHC configure options on Linux distributions that use GCC with PIE enabled by default. GHC detects this itself since ghc-8.0.2, and Stack’s attempted workaround for older versions caused more problems than it solved.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack new&lt;/code&gt; no longer initializes a project if the project template contains a stack.yaml file.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="other-enhancements"&gt;Other enhancements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A new sub command &lt;code&gt;ls&lt;/code&gt; has been introduced to stack to view local and remote snapshots present in the system. Use &lt;code&gt;stack ls snapshots --help&lt;/code&gt; to get more details about it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list-dependencies&lt;/code&gt; has been deprecated. The functionality has to accessed through the new &lt;code&gt;ls dependencies&lt;/code&gt; interface. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3669"&gt;#3669&lt;/a&gt; for details.&lt;/li&gt;
&lt;li&gt;Specify User-Agent HTTP request header on every HTTP request. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3628"&gt;#3628&lt;/a&gt; for details.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack setup&lt;/code&gt; looks for GHC bindists and installations by any OS key that is compatible (rather than only checking a single one). This is relevant on Linux where different distributions may have different combinations of libtinfo 5/6, ncurses 5/6, and gmp 4/5, and will allow simpifying the setup-info metadata YAML for future GHC releases.&lt;/li&gt;
&lt;li&gt;The build progress bar reports names of packages currently building.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack setup --verbose&lt;/code&gt; causes verbose output of GHC configure process. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3716"&gt;#3716&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Improve the error message when an &lt;code&gt;extra-dep&lt;/code&gt; from a path or git reference can’t be found See &lt;a href="https://github.com/commercialhaskell/stack/pull/3808"&gt;#3808&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nix integration is now disabled on windows even if explicitly enabled, since it isn’t supported. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3600"&gt;#3600&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; now supports a new flag &lt;code&gt;--keep-tmp-files&lt;/code&gt; to retain intermediate files and directories for the purpose of debugging. It is best used with ghc’s equivalent flag, i.e. &lt;code&gt;stack build --keep-tmp-files --ghc-options=-keep-tmp-files&lt;/code&gt;. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3857"&gt;#3857&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Improved error messages for snapshot parse exceptions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack unpack&lt;/code&gt; now supports a &lt;code&gt;--to /target/directory&lt;/code&gt; option to specify where to unpack the package into&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack hoogle&lt;/code&gt; now supports a new flag &lt;code&gt;--server&lt;/code&gt; that launches local Hoogle server on port 8080. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2310"&gt;#2310&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bug-fixes"&gt;Bug fixes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The script interpreter’s implicit file arguments are now passed before other arguments. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3658"&gt;#3658&lt;/a&gt;. In particular, this makes it possible to pass &lt;code&gt;-- +RTS ... -RTS&lt;/code&gt; to specify RTS arguments used when running the script.&lt;/li&gt;
&lt;li&gt;Don’t ignore the template &lt;code&gt;year&lt;/code&gt; parameter in config files, and clarify the surrounding documentation. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2275"&gt;#2275&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3663"&gt;#3663&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now allows loading multiple packages with the same module name, as long as they have the same filepath. See &lt;a href="https://github.com/commercialhaskell/stack/pull/3776"&gt;#3776&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; no longer always adds a dependency on &lt;code&gt;base&lt;/code&gt;. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for &lt;code&gt;base&lt;/code&gt;. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment"&gt;#3589&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now uses correct paths for autogen files with &lt;a href="https://github.com/commercialhaskell/stack/issues/3791"&gt;#3791&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;When a package contained sublibraries, stack was always recompiling the package. This has been fixed now, no recompilation is being done because of sublibraries. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3899"&gt;#3899&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;get-stack.sh&lt;/code&gt; install script now matches manual instructions when it comes to Debian/Fedora/CentOS install dependencies.&lt;/li&gt;
&lt;li&gt;Compile Cabal-simple with gmp when using Nix. See &lt;a href="https://github.com/commercialhaskell/stack/issues/2944"&gt;#2944&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now replaces the stack process with ghci. This improves signal handling behavior. In particular, handling of Ctrl-C. To make this possible, the generated files are now left behind after exit. The paths are based on hashing file contents, and it’s stored in the system temporary directory, so this shouldn’t result in too much garbage. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3821"&gt;#3821&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html</id><title type="text">[cygwin] cygwinセットアップ・環境構築手順メモ</title><updated>2018-04-27T13:16:22.723+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html"/><summary type="text">

主に自分向けの防備録です。windows10上で確認。インストーラーはここからDLする。





&lt;&lt;設定&gt;&gt;

ssh-agentの重複起動を防ぐ


ユーザーのアカウント名、ホームディレクトリの変更



/etc/passwdを編集する（最新バージョンでは自動生成されない？）
Cygwinを移動したら/etc/passwdの再生成を
巨大ドメインに参加している PC での /etc/passwd, /etc/group ファイルのつくりかた 

ssh-agentのために秘密鍵セットアップ



~/.ssh/


※group/otherの権限を削除する必要がある

% chmod 700 ~/.ssh 


less, lv, manコマンド終了時に画面をクリアしない

[linux][cygwin] less, manの終了直前の画面をクリアしないで端末上に残す方法 
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html</id><title type="text">rio ライブラリを試す その１</title><updated>2018-04-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-13-try-rio-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;rio ライブラリを試す その１&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-13" itemprop="datePublished"&gt;
        Apr 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先日，alt. &lt;code&gt;Prelude&lt;/code&gt; を目指している &lt;a href="https://hackage.haskell.org/package/rio"&gt;&lt;code&gt;rio&lt;/code&gt;&lt;/a&gt; ライブラリの ver.0.1 がリリースされました． 自作している CLI ツールを試しに &lt;code&gt;rio&lt;/code&gt; で置き換えようかとしてまして，自分の整理のためにまとめてみようと思います．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ただし，&lt;code&gt;rio&lt;/code&gt; 作者ではないし，全部をちゃんと追っていないので間違っているかも． 間違っている場合は&lt;a href="https://github.com/matsubara0507/source-gh-pages"&gt;このリポジトリに Issue&lt;/a&gt; するか &lt;a href="https://www.reddit.com/r/haskell_jp"&gt;Reddit&lt;/a&gt; でコメントでもしてください m(_ _ )m&lt;/p&gt;
&lt;h1 id="readme-でひとめぐり"&gt;README でひとめぐり&lt;/h1&gt;
&lt;p&gt;もともとはビルドツール Stack を作成するために考えたデザインパターンをまとめたものっぽい．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad"&gt;The RIO Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリの README にはライブラリのゴール・目的の他に(彼らにとっての)ベストプラクティスが書いてある(&lt;code&gt;rio&lt;/code&gt; 自体がそれに則って作られてる)． ここには翻訳というより，README の各項目の要約を記述する．&lt;/p&gt;
&lt;h2 id="goal"&gt;Goal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; ライブラリのゴール(目的)は以下の3つ．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;よく設計された信頼できるライブラリのコレクション&lt;/li&gt;
&lt;li&gt;より優れた Prelude の代替え&lt;/li&gt;
&lt;li&gt;高品質な Haskell コードを書くためのベストプラクティス&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(1)により &lt;code&gt;text&lt;/code&gt; や &lt;code&gt;bytesyring&lt;/code&gt; のような，ほとんど &lt;code&gt;base&lt;/code&gt; のようなパッケージを &lt;code&gt;dependencies&lt;/code&gt; に列挙する必要が無くなる． (3)は大域変数(&lt;code&gt;Reader&lt;/code&gt; モナド)やロガーのような実用モナド回りのベストプラクティスが目玉かな(他にもあるけど)．&lt;/p&gt;
&lt;h2 id="標準ライブラリ"&gt;標準ライブラリ&lt;/h2&gt;
&lt;p&gt;いくつかのパッケージを「標準」ライブラリとして再エクスポートしている． &lt;code&gt;rio&lt;/code&gt; の&lt;a href="https://github.com/commercialhaskell/rio/blob/311549f5a7c29abf6fc25e3ba7ec5ab6647e2d96/rio/package.yaml#L14"&gt;依存関係&lt;/a&gt;を見る限り，次のパッケージを再エクスポートしているようだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bytestring&lt;/li&gt;
&lt;li&gt;containers&lt;/li&gt;
&lt;li&gt;deepseq&lt;/li&gt;
&lt;li&gt;directory&lt;/li&gt;
&lt;li&gt;exceptions&lt;/li&gt;
&lt;li&gt;filepath&lt;/li&gt;
&lt;li&gt;hashable&lt;/li&gt;
&lt;li&gt;lens(microlens)&lt;/li&gt;
&lt;li&gt;process&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;time&lt;/li&gt;
&lt;li&gt;unliftio&lt;/li&gt;
&lt;li&gt;unordered-containers&lt;/li&gt;
&lt;li&gt;vector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もちろん，元のパッケージの全ての関数や型を再エクスポートしているのではなく，取捨選択して再エクスポートしている． また，後述する &lt;code&gt;Prelude&lt;/code&gt; の代わりである &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールに含まれるものもあれば，&lt;code&gt;RIO.XXX&lt;/code&gt; として別のモジュールとして提供されているものもある．&lt;/p&gt;
&lt;h3 id="lens"&gt;Lens&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lens&lt;/code&gt; の場合，申し訳程度の関数しか再エクスポートされていない． 基本的に &lt;code&gt;set&lt;/code&gt;・&lt;code&gt;sets&lt;/code&gt;・&lt;code&gt;over&lt;/code&gt;・&lt;code&gt;to&lt;/code&gt; だけだ． 演算子は参照の &lt;code&gt;(.^)&lt;/code&gt; しかない． 今後どうなるか分からないが，現状 &lt;code&gt;(.~)&lt;/code&gt; や &lt;code&gt;(%~)&lt;/code&gt; は無いので替わりに関数を中置演算子にして使うしか無さそうだ．&lt;/p&gt;
&lt;h2 id="prelude-の代替え"&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替え&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Prelude&lt;/code&gt; の代替えとして &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html"&gt;&lt;code&gt;RIO&lt;/code&gt;&lt;/a&gt; モジュールというのがある． README には部分関数や遅延 I/O のような，よく問題になるものを削除していると書いてある． また，&lt;code&gt;Data.Maybe&lt;/code&gt; や &lt;code&gt;Control.Arrow&lt;/code&gt; のような良く使う &lt;code&gt;base&lt;/code&gt; ライブラリのモジュールが再エクスポートされていたり，&lt;code&gt;mapLeft&lt;/code&gt; や &lt;code&gt;whenM&lt;/code&gt; のような良く使いそうなのに &lt;code&gt;base&lt;/code&gt; には無い関数が&lt;a href="https://github.com/commercialhaskell/rio/blob/e8c4cba69599aecd9f91c4398aea47ab4eadbb07/rio/src/RIO/Prelude/Extra.hs"&gt;定義されている&lt;/a&gt;． 正直，この辺りがすごい便利．&lt;/p&gt;
&lt;h2 id="ベストプラクティス"&gt;ベストプラクティス&lt;/h2&gt;
&lt;p&gt;ココからが長い + 意見の分かれるところ． 結構 &lt;code&gt;TODO&lt;/code&gt; と書いてあるところも多いので彼らの中でもまとまってないのかな？？&lt;/p&gt;
&lt;h3 id="インポートプラクティス"&gt;インポートプラクティス&lt;/h3&gt;
&lt;p&gt;以下をやってほしいらしい&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt; 言語拡張をオン&lt;/li&gt;
&lt;li&gt;全てのモジュールに &lt;code&gt;import RIO&lt;/code&gt; を追加 (すごいめんどい)&lt;/li&gt;
&lt;li&gt;必要に応じて &lt;code&gt;RIO.XXX&lt;/code&gt; モジュールを &lt;code&gt;qualified&lt;/code&gt; を使ってインポート
&lt;ul&gt;
&lt;li&gt;適切な &lt;code&gt;qualified&lt;/code&gt; の付け方は各モジュールの Haddock の冒頭に書いてある&lt;/li&gt;
&lt;li&gt;例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-ByteString.html"&gt;&lt;code&gt;import qualified RIO.ByteString as B&lt;/code&gt;&lt;/a&gt; とか&lt;/li&gt;
&lt;li&gt;ドキュメントに &lt;code&gt;qualified&lt;/code&gt; が書いてない場合は &lt;code&gt;qualified&lt;/code&gt; しなくていいのかな？？(例えば &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO-Directory.html"&gt;&lt;code&gt;RIO.Directory&lt;/code&gt;&lt;/a&gt; とか)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;中置演算子は &lt;code&gt;qualified&lt;/code&gt; しなくていい(他のモジュールと衝突しない限りは)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="言語拡張"&gt;言語拡張&lt;/h3&gt;
&lt;p&gt;「言語拡張を使わないプロジェクトなんて，最近じゃほとんどないよね」とか書いてある． 以下の観点を基にデフォルトで利用しても良さそうな言語拡張を選定したそうだ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コミュニティで受け入れられている&lt;/li&gt;
&lt;li&gt;コードを壊すようなことが &lt;strong&gt;ほとんど&lt;/strong&gt; ない&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般的に&lt;/strong&gt; 安全だと考えられている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;割と断言していないのが面白い(笑) 推奨する言語拡張はこちら&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AutoDeriveTypeable
BangPatterns
BinaryLiterals
ConstraintKinds
DataKinds
DefaultSignatures
DeriveDataTypeable
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveTraversable
DoAndIfThenElse
EmptyDataDecls
ExistentialQuantification
FlexibleContexts
FlexibleInstances
FunctionalDependencies
GADTs
GeneralizedNewtypeDeriving
InstanceSigs
KindSignatures
LambdaCase
MultiParamTypeClasses
MultiWayIf
NamedFieldPuns
NoImplicitPrelude
OverloadedStrings
PartialTypeSignatures
PatternGuards
PolyKinds
RankNTypes
RecordWildCards
ScopedTypeVariables
StandaloneDeriving
TupleSections
TypeFamilies
TypeSynonymInstances
ViewPatterns&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RecordWildCards&lt;/code&gt; と &lt;code&gt;OverloadedStrings&lt;/code&gt; は議論の余地あり的なことが書いてある(詳しくはもとの README を見て)．&lt;/p&gt;
&lt;h3 id="ghcオプション"&gt;GHCオプション&lt;/h3&gt;
&lt;p&gt;以下を使いなさいとのコト．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Wall
-Wcompat
-Wincomplete-record-updates
-Wincomplete-uni-patterns
-Wredundant-constraints&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どういう形で指定してもいいけど，&lt;code&gt;package.yaml&lt;/code&gt; で書くと楽だし，後述するテンプレートにも書く予定だそうだ． あと，プロダクションコードなら &lt;code&gt;-Werror&lt;/code&gt; をオンにして，最後には確認した方が良いとも書いてある(CIとかでチェックしたいよね)．&lt;/p&gt;
&lt;h3 id="monads"&gt;Monads&lt;/h3&gt;
&lt;p&gt;まってました！ モナドです． 実用的なプロジェクトを考えるとき，必要になってくるのが大域変数・ロガー・例外・IO だと思うので，気になるのはこの辺りだよね．&lt;/p&gt;
&lt;p&gt;全体としての推奨事項は以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; を使いたいときは &lt;code&gt;RIO&lt;/code&gt; モナドを使いなさい．
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドは &lt;code&gt;ReaderT env IO&lt;/code&gt; と同じだけど，&lt;code&gt;rio&lt;/code&gt; には &lt;code&gt;RIO&lt;/code&gt; モナドに対する補助関数が含まれるのでぜひ使って．&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RIO&lt;/code&gt; モナドで &lt;code&gt;env&lt;/code&gt; の参照関数を書くときは，具体的な型に対する参照関数を書かずに，型クラスを用いた多相的な関数を書くべき(詳しくは後述)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Has&lt;/code&gt; スタイルの型クラスを使えば lens を利用することが出来るよ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;いくつかの良い &lt;code&gt;mtl&lt;/code&gt; スタイルの型クラスも利用する必要は出てくるはず
&lt;ul&gt;
&lt;li&gt;ただし，推奨しているのは &lt;code&gt;MonadReader&lt;/code&gt; &lt;code&gt;MonadIO&lt;/code&gt; &lt;code&gt;MonadUnliftIO&lt;/code&gt; &lt;code&gt;PrimMonad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MonadReader&lt;/code&gt; + &lt;code&gt;Has&lt;/code&gt; の方が &lt;code&gt;MonadLogger&lt;/code&gt; のように新しい型クラスを作るより優れていると思う&lt;/li&gt;
&lt;li&gt;特に &lt;code&gt;MonadBase&lt;/code&gt; &lt;code&gt;MonadBaseControl&lt;/code&gt; &lt;code&gt;MonadMask&lt;/code&gt; &lt;code&gt;MonadCatch&lt;/code&gt; は避けるべき&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="大域変数"&gt;大域変数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;env&lt;/code&gt; 回りについて． &lt;code&gt;Has&lt;/code&gt; スタイル(パターン)というのがあって，それ自体はこの&lt;a href="https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae"&gt;ページ&lt;/a&gt;が参考になるのかな？ &lt;code&gt;env&lt;/code&gt; から何らかの値を参照する場合には&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;のような関数は &lt;strong&gt;やめて&lt;/strong&gt; ，次のように書くのを推奨している．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="ot"&gt;  configL ::&lt;/span&gt; &lt;span class="dt"&gt;Lens&amp;#39;&lt;/span&gt; env &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="co"&gt;-- more on this in a moment&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;myFunction ::&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; env &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; env &lt;span class="dt"&gt;Foo&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで，&lt;code&gt;env&lt;/code&gt; は次のようなレコードを想定しており&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすることで，&lt;code&gt;env&lt;/code&gt; に複数の大域変数を持たせても，うまく機能させることが出来る． また，次のように &lt;code&gt;Env&lt;/code&gt; と &lt;code&gt;Config&lt;/code&gt; それぞれでインスタンスを定義することで，それぞれで利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasConfig&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;  configL &lt;span class="fu"&gt;=&lt;/span&gt; lens envConfig (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envConfig &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ロガー"&gt;ロガー&lt;/h4&gt;
&lt;p&gt;ロガーも同様に &lt;code&gt;Has&lt;/code&gt; スタイルを推奨している． &lt;code&gt;env&lt;/code&gt; にログを出力するための関数(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:LogFunc"&gt;&lt;code&gt;LogFunc&lt;/code&gt;&lt;/a&gt; 型のもの)を持たせる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="ot"&gt; envLogFunc ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;LogFunc&lt;/span&gt;,&lt;span class="ot"&gt; envConfig ::&lt;/span&gt; &lt;span class="fu"&gt;!&lt;/span&gt;&lt;span class="dt"&gt;Config&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これの &lt;code&gt;Has&lt;/code&gt; スタイル型クラスは &lt;code&gt;RIO&lt;/code&gt; モジュールに&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#t:HasLogFunc"&gt;定義してある&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens envLogFunc (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x { envLogFunc &lt;span class="fu"&gt;=&lt;/span&gt; y })&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;LogFunc&lt;/code&gt; 型の値を渡すには &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:withLogFunc"&gt;&lt;code&gt;withLogFunc&lt;/code&gt;&lt;/a&gt; 関数を用いるようだ(&lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:mkLogFunc"&gt;&lt;code&gt;mkLogFunc&lt;/code&gt;&lt;/a&gt; 関数もあるがアドバンスドと書いてある．)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;  envConfig &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getConfig&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \envLogFunc &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runRIO &lt;span class="dt"&gt;Env&lt;/span&gt;{&lt;span class="fu"&gt;..&lt;/span&gt;} action&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="ot"&gt;action ::&lt;/span&gt; &lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;action &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="例外"&gt;例外&lt;/h4&gt;
&lt;p&gt;例外をどのように表現すべきかは結構議論されており，今のところの基本的アイデアは以下の通り．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lookup&lt;/code&gt; のような単純に失敗する関数(部分関数になり得る？)の場合は &lt;code&gt;Maybe&lt;/code&gt; や &lt;code&gt;Either&lt;/code&gt; を返そう&lt;/li&gt;
&lt;li&gt;それらを使いたくない場合(大域脱出とか？)は例外を使って
&lt;ul&gt;
&lt;li&gt;純粋なコード(IOではなく)の場合は &lt;code&gt;MonadThrow&lt;/code&gt; 制約を使う&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IO&lt;/code&gt; の場合は &lt;code&gt;thorowIO&lt;/code&gt; を介した実行時例外を使う(&lt;code&gt;RIO&lt;/code&gt; モナドも同じ)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「IOアクションがどのように失敗するかを正確に把握できないことにより，不安と不満を感じるかもしれない．しかし，その痛みを受け入れて共存し内在化して，&lt;code&gt;tryAny&lt;/code&gt; を用いて移動してください．これは非同期例外に対して支払う代償です．」
&lt;ul&gt;
&lt;li&gt;ちょっと何言ってるかよくわからない…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全てのリソース割り当ては &lt;code&gt;bracket&lt;/code&gt; や &lt;code&gt;finally&lt;/code&gt; のような関数で行う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のようにして，アプリ専用の例外を定義し使用することが推奨されている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;FilePathError&lt;/span&gt; FilePath&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Exception&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="dt"&gt;AppExceptions&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;  show &lt;span class="fu"&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;    &lt;span class="dt"&gt;NetworkChangeError&lt;/span&gt; err &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;network error: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; (unpack err)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;    &lt;span class="dt"&gt;FilePathError&lt;/span&gt; fp &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;error accessing filepath at: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; fp&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;    &lt;span class="dt"&gt;ImpossibleError&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;this codepath should never have been executed. Please report a bug.&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに，&lt;code&gt;Exception&lt;/code&gt; 型クラス(というか &lt;a href="https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Exception-Base.html#t:SomeException"&gt;&lt;code&gt;SomeException&lt;/code&gt;&lt;/a&gt; 型)は，いわゆる存在型を利用して具体型(&lt;code&gt;AppExceptions&lt;/code&gt; とか)を隠蔽している．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;疑問なところは，投げた例外を &lt;code&gt;catch&lt;/code&gt; してからディスパッチして良いのだろうか？ 実行時例外じゃなくて大域脱出をしたいだけなんだけどな． ちょっとイマイチ使い方が分からない．&lt;/p&gt;
&lt;h3 id="strict"&gt;Strict&lt;/h3&gt;
&lt;p&gt;特別な理由が無い限り，データフィールド(レコードのフィールド？？)は正格にすべき，とのこと． 割と重要そうなのに一文しかない．&lt;/p&gt;
&lt;h3 id="プロジェクトテンプレート"&gt;プロジェクトテンプレート&lt;/h3&gt;
&lt;p&gt;そのうち，新しい Stack テンプレートを作るそうだ． もちろん，&lt;code&gt;cabal&lt;/code&gt; ファイルは使わず &lt;code&gt;hpack&lt;/code&gt; を使用する．&lt;/p&gt;
&lt;h3 id="安全第一"&gt;安全第一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rio&lt;/code&gt; は安全性を最優先しており，そのため部分関数と遅延 I/O を全力で避けている． もし，遅延 I/O を使いたい場合は &lt;code&gt;conduit&lt;/code&gt; のようなストリーミングライブラリを使いなさい，とのこと．&lt;/p&gt;
&lt;h3 id="一般化"&gt;一般化&lt;/h3&gt;
&lt;p&gt;Haskell のよくある疑問として，いつ一般化すべきか，というのがある(いつ？)． README にはいくつかの簡単なガイドラインが書いてある．&lt;/p&gt;
&lt;p&gt;パラメトリック多相の場合，わりと議論の余地が無く，多相的な方が有用． つまり，&lt;code&gt;reverse :: [a] -&amp;gt; [a]&lt;/code&gt; は &lt;code&gt;reverse :: [Int] -&amp;gt; [Int]&lt;/code&gt; より優れている．&lt;/p&gt;
&lt;p&gt;型クラスの場合は話が微妙になる． &lt;code&gt;Foldable&lt;/code&gt; や &lt;code&gt;Traversable&lt;/code&gt; のような &lt;code&gt;RIO&lt;/code&gt; で定義済みの型クラスには可能な限り一般化(インスタンスを定義)するのが良いだろう． しかし，本当の疑問は &lt;strong&gt;自身で型クラスを定義すべきかどうか&lt;/strong&gt; の場合． 原則としては可能な限りそれは避けるべきだ． もし，自身で型クラスを定義している場合は，&lt;strong&gt;自分が期待していなかった型がインスタンス化されてもバグが起きないよう&lt;/strong&gt; に気を付けること，とのこと．&lt;/p&gt;
&lt;h3 id="コーディングスタイル"&gt;コーディングスタイル&lt;/h3&gt;
&lt;p&gt;議論中だそうだ．&lt;/p&gt;
&lt;h3 id="モジュール階層"&gt;モジュール階層&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RIO.Prelude.XXX&lt;/code&gt; モジュールはドキュメントを Haddock で読みやすくするための階層で，個別にインポートすることを想定しているわけではない． と書いてあるが，結局 &lt;a href="https://github.com/commercialhaskell/rio/pull/72"&gt;ver.0.1 からは Haddock からも消えてしまった&lt;/a&gt;ので気にする必要はない．&lt;/p&gt;
&lt;h1 id="io-まわり"&gt;I/O まわり&lt;/h1&gt;
&lt;p&gt;(この話は README に書いてあるわけではないです)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RIO&lt;/code&gt; モジュールには文字列型(&lt;code&gt;String&lt;/code&gt;)の一般的な &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; のような I/O 関数は無い． 実用コードの場合，これらの関数を直接呼ぶことは稀だろうが，例えば CLI を作ったときに &lt;code&gt;--version&lt;/code&gt; オプションでバージョン情報を出力したい場合などがある．&lt;/p&gt;
&lt;p&gt;替わりとして次のような I/O 関数が提供されている．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Strict.ByteString&lt;/code&gt; 型の &lt;code&gt;putStr&lt;/code&gt; や &lt;code&gt;getLine&lt;/code&gt; であれば &lt;code&gt;RIO.ByteString&lt;/code&gt; モジュールで再定義されている&lt;/li&gt;
&lt;li&gt;ファイルの入出力であれば &lt;code&gt;RIO&lt;/code&gt; モジュールに &lt;code&gt;Strict.ByteString&lt;/code&gt; 版と &lt;code&gt;Text&lt;/code&gt; 版が提供されている&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt; 型の標準出力 &lt;a href="https://hackage.haskell.org/package/rio-0.1.0.0/docs/RIO.html#v:hPutBuilder"&gt;&lt;code&gt;hPutBuilder&lt;/code&gt;&lt;/a&gt; 関数ならある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンソールに対する I/O はどれを使うべきかはまだ&lt;a href="https://github.com/commercialhaskell/rio/issues/5"&gt;議論中&lt;/a&gt;みたいだ．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;何となく&lt;a href="https://github.com/matsubara0507/scrapbook/tree/rio"&gt;置き換えはできた&lt;/a&gt;けど，例外や I/O 回りは良く分かってない… また試していこう．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/02/windows-windows10.html</id><title type="text">[windows] Windows10セットアップ・設定項目のメモ</title><updated>2018-04-12T13:07:28.167+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/02/windows-windows10.html"/><summary type="text">Windows10セットアップ時の設定項目、インストールアプリの備忘録。


スタートメニュー・タスクバーの設定

タスクバーの設定 

小さいタスクバーボタンを使う：オン 
[スタート]ボタンを右クリックするかWindowsキー＋Xキーを押したときに表示されるメニューで、コマンドプロンプトをWindows PowerShellに置き換える：オフ
タスクバーボタンを結合する

「タスクバーに入りきらない場合」を選択

タスクバーをすべての ディスプレイに表示する：オフ



 Quick Launcherを表示する

クイック起動を復活する 
Windows 10 タスクバーにクイック起動を表示する

スタートメニューにコントロールパネルを表示する

「Windows 10」のコントロールパネルを表示する方法について

スタートメニューにピン止めするアプリ：

Windowsシステム</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html</id><title type="text">ML Day ＃1 に行ってきた</title><updated>2018-04-02T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-04-02-ml-day-1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;ML Day ＃1 に行ってきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-04-02" itemprop="datePublished"&gt;
        Apr 2, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://ml-lang.connpass.com/event/78199/"&gt;ML Day #1&lt;/a&gt; というイベントに参加してきたので，そのメモ？まとめ？みたいな感じの記事です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ML Day は毎年やってるML勉強会というML系の発表会形式の勉強会のこと． (なぜか)名前を変えたらしい． ちなみに，今後は半年に一回ペースでやりたいらしい．&lt;/p&gt;
&lt;h2 id="ぼくのはなし"&gt;ぼくのはなし&lt;/h2&gt;
&lt;p&gt;新設された LT 枠で発表してきた．&lt;/p&gt;
&lt;p&gt;スライドはこれ&lt;/p&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/o84VhGTUREO4No" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;さすがに Haskell の話をするのはアレだったので，Haskell の新しいモジュールシステム Backpack のベースになった MixML の話をした． この日までに(Haskellで)実装完了してドヤ顔する予定だったのだが全然終わらなかった orz (Alt braif*ck じゃなくて)ちゃんとした規模の処理系を実装するのって，大変なんですね…&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;a href="https://github.com/rossberg/mixml"&gt;SML/NJ で実装されたもの&lt;/a&gt;があり，実質これを参考に Haskell で書き直すだけの作業． だけど SML -&amp;gt; Haskell に直すのって大変，非純粋なものを純粋な世界にするって大変(そりゃそう)． 気軽に状態を持ちやがって…&lt;/p&gt;
&lt;h2 id="自分的ハイライト"&gt;自分的ハイライト&lt;/h2&gt;
&lt;p&gt;濃い目の話が多かったのでざっくりと．&lt;/p&gt;
&lt;p&gt;資料は既に&lt;a href="https://ml-lang.connpass.com/event/78199/presentation/"&gt;ほとんど上がっている&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="ml型付の基礎の基礎"&gt;ML型付の基礎の基礎&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/haochenxie"&gt;Haochen&lt;/a&gt; くん
&lt;ul&gt;
&lt;li&gt;名〇屋で &lt;a href="https://sicss.connpass.com/event/71199/"&gt;TaPL の読書会&lt;/a&gt;を主催してるひと&lt;/li&gt;
&lt;li&gt;こんど&lt;a href="https://nupsc.sicss.org/"&gt;名古屋でプロコン&lt;/a&gt;やるんだって&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haochenxie.name/dl/the_introduction_of_foundation_of_ml_type_checking.pdf"&gt;資料はコレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基礎 (foundation) の 基礎 (introduction) の話
&lt;ol type="1"&gt;
&lt;li&gt;型は素晴らしい&lt;/li&gt;
&lt;li&gt;でも型を書きたくない
&lt;ul&gt;
&lt;li&gt;プログラマは怠惰を美徳にしている生き物だもんね&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再構築すればいいじゃない！
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;型検査無しにもどるなんてのは論外&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;素晴らしい本(TaPL)と素晴らしい先生(ピアース先生)
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;ML Day 出る以上読め&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;おまけとして let 多相の話もしてた&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sicss.connpass.com/event/83801/"&gt;5/6に論理プログラミング言語の第一人者の講演&lt;/a&gt;を企画しているらしい
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://readcoqart.connpass.com/event/83722/"&gt;Coq 勉強会&lt;/a&gt;と被ってるのがなぁぁぁぁ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tba"&gt;TBA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href="https://twitter.com/pi8027"&gt;坂口和彦&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;PPL2018 のポスター賞の人でその話を&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発表スライドは上がってないけど &lt;a href="http://logic.cs.tsukuba.ac.jp/~sakaguchi/posters/ppl2018.pdf"&gt;PPL2018 のポスター&lt;/a&gt;はあった&lt;/li&gt;
&lt;li&gt;Coq でリストの置換(permutation)の自動証明(だったかな)
&lt;ul&gt;
&lt;li&gt;証明の過程をいろいろ話してくれた&lt;/li&gt;
&lt;li&gt;(がぼくはよくわかってない)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sqlab.jp/FLOPS2018/"&gt;FLOPS’18&lt;/a&gt; に通ったので発表するらしい&lt;/li&gt;
&lt;li&gt;質問: 項書き換えでできないの？
&lt;ul&gt;
&lt;li&gt;中野先生に聞かれた(PPLで？？)&lt;/li&gt;
&lt;li&gt;出来たら教えてといって何もないのでできないんじゃない？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="型つき組版処理システムsatysfi"&gt;型つき組版処理システムSATySFi&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/bd_gfngfn"&gt;bd_gfngfn&lt;/a&gt; 氏&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://drive.google.com/file/d/1BB7ZAiwPO3hVtq7PGImPtMs1-kOd7SzW/view"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;彼の有名な &lt;a href="https://github.com/gfngfn/SATySFi"&gt;型つき組版処理システムSATySFi&lt;/a&gt; の話
&lt;ul&gt;
&lt;li&gt;目標: L〇TeX を倒す&lt;/li&gt;
&lt;li&gt;目標: エラーの可読性向上(大事)&lt;/li&gt;
&lt;li&gt;ML系に似た組版用型システムが載っている
&lt;ul&gt;
&lt;li&gt;let 多相もレコード多相もある&lt;/li&gt;
&lt;li&gt;しかし GADT や Functor はまだ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「いきなり PDF がでまして」をよく言っていた(笑)&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;質問: 構文にポリシーはあるの？
&lt;ul&gt;
&lt;li&gt;ML系の文法にしたい(けど LaTeX に寄せたほうが…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="mlでつくる拡張可能インタプリタ"&gt;MLでつくる拡張可能インタプリタ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;発表者は &lt;a href="https://twitter.com/linerlock"&gt;linerlock&lt;/a&gt; 氏
&lt;ul&gt;
&lt;li&gt;今日までつくば大生
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;これのせいで二番煎じに&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://speakerdeck.com/takahisa/extensible-interpreter-in-ml"&gt;コレ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;言語開発 &lt;strong&gt;も&lt;/strong&gt; モジュラーにしたいので拡張可能なインタプリタを作ればいいじゃない
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/takahisa/kennel"&gt;コレ&lt;/a&gt;のことかな？&lt;/li&gt;
&lt;li&gt;例えば超簡易的な自作言語に新しくリスト追加してと言われても簡単にできるように&lt;/li&gt;
&lt;li&gt;評価器は楽しいので(拡張可能な評価器の)研究が多い&lt;/li&gt;
&lt;li&gt;構文解析は無い…なのでここをサイボウズラボユースでやった(？)
&lt;ul&gt;
&lt;li&gt;構文解析の無い言語なんてないのにね&lt;/li&gt;
&lt;li&gt;作ったの&lt;a href="https://github.com/takahisa/finale"&gt;コレ&lt;/a&gt;かな？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「(BNFに新しい構文を)上に足すか下に足すか、花火じゃないけど」
&lt;ul&gt;
&lt;li&gt;上に足すか下に足すかで意味が変わることが…&lt;/li&gt;
&lt;li&gt;そこで最長一致法 : 全部試して一番長いのをとる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;型とか最適化とかできてない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lt"&gt;LT&lt;/h3&gt;
&lt;p&gt;は割愛(つかれた)． ラインナップは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自作言語を OCaml で作り直したら ML みたいなコア言語になってしまったという話&lt;/li&gt;
&lt;li&gt;Elm の紹介&lt;/li&gt;
&lt;li&gt;OCaml の祖先 CAML の解説&lt;/li&gt;
&lt;li&gt;自作したパーサージェネレーターの紹介&lt;/li&gt;
&lt;li&gt;Verifastの辛い話(&lt;del&gt;古いOCamlを使うのつらいという愚痴&lt;/del&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LT の資料は全部 connpass にあがっている．&lt;/p&gt;
&lt;h3 id="コンパイラバックエンド"&gt;コンパイラバックエンド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は&lt;a href=""&gt;インターネットの闇&lt;/a&gt;さん
&lt;ul&gt;
&lt;li&gt;この会の主催者(？)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OCaml のソースコードを皆で読もうの会
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;バックエンドはコンパイラのコト&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;not Webバックエンド&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ガリグ先生しか読めない化け物(type系)&lt;/li&gt;
&lt;li&gt;OCaml のバックは副作用ガンガン使う、FPとは？GC付きのC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bucklescriptでノベルゲームdslを作る"&gt;BuckleScriptでノベルゲームDSLを作る&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者は[pocketberserker]氏
&lt;ul&gt;
&lt;li&gt;普段は F# の人&lt;/li&gt;
&lt;li&gt;F# ネタが切れた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;資料は&lt;a href="https://github.com/pocketberserker/ml_day_1"&gt;ココ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;資料もこの DSL で書かれたもの(？？)&lt;/li&gt;
&lt;li&gt;ノベルゲーなのでバックができない(笑)&lt;/li&gt;
&lt;li&gt;発表者はデバッグモードで戻ってた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノベルゲーDSLを作りたい遺伝子を持ってしまったので作るという話
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/cowlick/cowlick"&gt;つくったやつ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自分が今書いてるのはS式なのか？？？？S式が分からなくなる&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;strong&gt;Reason を ML ユーザーが触るべきではない！&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="感想"&gt;感想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;濃い(誉め言葉)&lt;/li&gt;
&lt;li&gt;後半は疲れてしまった(ごめん)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;質問時間を含めて発表時間(律儀に終わる必要はない)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;MixML 完成させてリベンジ発表したい&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html</id><title type="text">多相バリアントを使いこなそう with Haskell</title><updated>2018-03-24T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-03-24-poly-variant-with-haskell.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;多相バリアントを使いこなそう with Haskell&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-03-24" itemprop="datePublished"&gt;
        Mar 24, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;&lt;a href="https://sampou.connpass.com/event/80492/"&gt;この前の「『Haskellによる関数プログラミングの思考法』読書会」&lt;/a&gt;の後の懇親会(？)で &lt;strong&gt;多相バリアント&lt;/strong&gt; の話になりまして，その時に以下の記事が話題にあがった．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090512/1242055541"&gt;多相バリアントを使いこなそう(2) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://osiire.hatenablog.com/entry/20090516/1242456737"&gt;多相バリアントを使いこなそう(4) - osiire’s blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの記事は OCaml で多相バリアントの紹介をしています． ということで，同様の議論を Haskell でもしてみた！というのが，この記事の内容です．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;(2018.04.13 追記アリ)&lt;/p&gt;
&lt;h3 id="haskell-と多相バリアント"&gt;Haskell と多相バリアント&lt;/h3&gt;
&lt;p&gt;悲しいことに，Haskell には組み込みで多相バリアントは無い(バリアントとは Haskell の代数的データ型における直和型と概ね一緒)． なので，多相バリアントを Haskell で模倣するために，毎度おなじみ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;&lt;code&gt;extensible&lt;/code&gt;&lt;/a&gt; パッケージを用いる．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ネタバレをすると Haskell で同じことをするのは難しかった． なので，本質的な議論は osiire’s blog の方を読んだ方がいいと思うよ． 結局，本記事は osiire’s blog のと同様のことを Haskell もとい，&lt;code&gt;extensible&lt;/code&gt; パッケージでどのように行うか，という記事って感じになった．&lt;/p&gt;
&lt;h2 id="多相バリアントの基本"&gt;多相バリアントの基本&lt;/h2&gt;
&lt;p&gt;多相バリアントとは，名前の通り，多相的なバリアントである． バリアントは前述したとおり，直和型と基本的に同じ．&lt;/p&gt;
&lt;p&gt;例えば，普通の直和型として次のようなものがあったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Joker&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Str&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Number&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;「最初の型はジョーカーと数字札があるトランプの型，次の型は何かファイルからデータを読み込む時に文字列と数字のデータを統一的に扱うための型」だそうです(&lt;a href="http://osiire.hatenablog.com/entry/20090510/1241957550"&gt;多相バリアントを使いこなそう(1)&lt;/a&gt; より)． どちらの型にも &lt;code&gt;Number Int&lt;/code&gt; という部分があるので次のような関数を両方に適用できそうな気がする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;getNumber (&lt;span class="dt"&gt;Number&lt;/span&gt; n) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Just&lt;/span&gt; n&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;getNumber _ &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Nothing&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，そんなことはできない(そもそも，Haskell の値コンストラクタは名前空間を共有してしまうので同時に利用はできないのだが…)． そこで多相バリアントを用いれば，このような関数を実装することが出来るようになる．&lt;/p&gt;
&lt;h3 id="多相バリアントを定義"&gt;多相バリアントを定義&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;extensible&lt;/code&gt; パッケージを使って多相バリアント(拡張可能バリアント)を定義すると次のようになる(&lt;code&gt;DataKinds&lt;/code&gt; と &lt;code&gt;TypeOperators&lt;/code&gt; 言語拡張が必要)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;joker&amp;quot; &amp;gt;: (), &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;str&amp;quot; &amp;gt;: String, &amp;quot;number&amp;quot; &amp;gt;: Int ]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とくに細かい説明はしないが，なんとなく意味が読み取れるだろう． &lt;code&gt;getNumber&lt;/code&gt; 関数の実装は難しいので後回しにするとして，&lt;code&gt;getNumber&lt;/code&gt; 関数の型は &lt;code&gt;extensible&lt;/code&gt; パッケージの &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#t:-8838-"&gt;&lt;code&gt;⊆&lt;/code&gt;&lt;/a&gt; 型クラスを用いて次のように書ける(意味は見た通り)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE FlexibleContexts #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHCi で試してみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;getNumber (undefined&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;InData&lt;/span&gt;)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに動作する．&lt;/p&gt;
&lt;h2 id="包含関係"&gt;包含関係&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;getNumber&lt;/code&gt; 関数をどのように実装するかだが，その前に多相バリアントの包含関係を議論しておく(この議論は&lt;a href="http://osiire.hatenablog.com/entry/20090514/1242235108"&gt;多相バリアントを使いこなそう(3)&lt;/a&gt;に対応する)．&lt;/p&gt;
&lt;p&gt;次のような簡単なバリアント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;HogeFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;fuga&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このバリアント型に対し，&lt;code&gt;⊆&lt;/code&gt; を用いて多相的な関数は2種類考えれる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; と &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; を要素に持つバリアント型全てが利用できる関数である(さっきの &lt;code&gt;getNumber&lt;/code&gt; と同じ)． &lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;&amp;quot;hoge&amp;quot; &amp;gt;: ()&lt;/code&gt; か &lt;code&gt;&amp;quot;fuga&amp;quot; &amp;gt;: ()&lt;/code&gt; のどれかを要素に持つ(それ以外は持ってはいけない)バリアント型全てに利用できる関数である． 試しに，次の3つのバリアント型の値を定義し，GHCi で試してみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="ot"&gt;hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;hoge1 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;&lt;span class="ot"&gt;hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="st"&gt;&amp;quot;piyo&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; () &lt;span class="ch"&gt;&amp;#39;: HogeFields)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;hoge2 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;piyo &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;&lt;span class="ot"&gt;hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;hoge&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;hoge3 &lt;span class="fu"&gt;=&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;見てわかるように(？)，&lt;code&gt;hoge3 ⊆ hoge1 ⊆ hoge2&lt;/code&gt; である(厳密にはバリアントの要素の集合で成り立つ関係だが)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;toInt1&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;toInt1&lt;span class="ot"&gt; hoge2 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;fuga&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt1’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt1 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge1&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;toInt2&lt;span class="ot"&gt; hoge1 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-16" data-line-number="16"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;interactive&lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; error&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-17" data-line-number="17"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;Couldn&amp;#39;t&lt;/span&gt; match &lt;span class="kw"&gt;type&lt;/span&gt; ‘&lt;span class="ch"&gt;&amp;#39;Missing (&amp;quot;piyo&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; ())’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-18" data-line-number="18"&gt;                     with ‘&lt;span class="ch"&gt;&amp;#39;Expecting pos0’&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-19" data-line-number="19"&gt;        arising from a use &lt;span class="kw"&gt;of&lt;/span&gt; ‘toInt2’&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-20" data-line-number="20"&gt;    &lt;span class="fu"&gt;?&lt;/span&gt; &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; toInt2 hoge2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-21" data-line-number="21"&gt;&lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;:&lt;/span&gt;t toInt2 hoge3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-22" data-line-number="22"&gt;toInt2&lt;span class="ot"&gt; hoge3 ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに，&lt;code&gt;toInt1&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge2&lt;/code&gt; に適用でき，&lt;code&gt;toInt2&lt;/code&gt; は &lt;code&gt;hoge1&lt;/code&gt; と &lt;code&gt;hoge3&lt;/code&gt; に適用できている．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;さて，&lt;code&gt;toInt1&lt;/code&gt; と &lt;code&gt;toInt2&lt;/code&gt; の実装を与えてみる． 実は簡単なのは後者 &lt;code&gt;toInt2&lt;/code&gt; だ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="ot"&gt;toInt2 ::&lt;/span&gt; (xs ⊆ &lt;span class="dt"&gt;HogeFields&lt;/span&gt;) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;toInt2 &lt;span class="fu"&gt;=&lt;/span&gt; flip matchField (spread&lt;span class="ot"&gt; xs ::&lt;/span&gt; &lt;span class="dt"&gt;Hoge&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;a href="https://matsubara0507.github.io/posts/2017-11-28-fun-of-extensible-1.html"&gt;昔の記事&lt;/a&gt;でも紹介した) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Inclusion.html#v:spread"&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/a&gt; 関数を用いることで &lt;strong&gt;バリアント型を拡張できる&lt;/strong&gt; (&lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Field.html#v:matchField"&gt;&lt;code&gt;matchField&lt;/code&gt;&lt;/a&gt; 関数の使い方についてはこの&lt;a href="https://matsubara0507.github.io/posts/2018-01-31-fun-of-extensible-2.html"&gt;記事&lt;/a&gt;を参照して)．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="ot"&gt;shrink ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt; xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="ot"&gt;spread ::&lt;/span&gt; (xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; ys&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;del&gt;拡縮する関数 &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; は強力なのだが，多相的すぎて前後の型が分からないとエラーになる(気がする(パッケージの作者じゃないので細かいことはよくわからん))ので，型注釈 (&lt;code&gt;spread xs :: Hoge&lt;/code&gt; の部分)を与える必要がある．&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(2018.04.13 追記) &lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; の代わりに &lt;code&gt;shrinkAssoc&lt;/code&gt; や &lt;code&gt;spreadAssoc&lt;/code&gt; を使えば値が多相でもうまく扱えるとのコトを&lt;a href="https://www.reddit.com/r/haskell_jp/comments/86rx9b/多相バリアントを使いこなそう_with_haskell/dwaq3cw/"&gt;作者様よりコメント&lt;/a&gt;いただいた． 感謝．&lt;/p&gt;
&lt;h3 id="必殺-coinclusion"&gt;必殺 Coinclusion&lt;/h3&gt;
&lt;p&gt;前者が難しいのは，&lt;code&gt;spread&lt;/code&gt; や &lt;code&gt;shrink&lt;/code&gt; とは逆の振る舞いを要求するからだ． そのために(この前作者から教えてもらった隠し技(別に隠してない)) &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使う！ &lt;code&gt;Nullable&lt;/code&gt; を使うとバリアントやレコードの全ての要素を簡単に &lt;code&gt;Maybe&lt;/code&gt; でラップできる(なんかいいテーマがあったら，そのうち解説する)． さらに &lt;code&gt;Nullable&lt;/code&gt; を用いることで，Coinclusion を定義できる！&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb12-1" data-line-number="1"&gt;&lt;span class="ot"&gt;wrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:*&lt;/span&gt; xs) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; h &lt;span class="fu"&gt;:*&lt;/span&gt; ys&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" data-line-number="2"&gt;&lt;span class="ot"&gt;retrench ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (h &lt;span class="fu"&gt;:|&lt;/span&gt; ys) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; ((&lt;span class="fu"&gt;:|&lt;/span&gt;) h) xs&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;wrench&lt;/code&gt; や &lt;code&gt;retrench&lt;/code&gt; は &lt;code&gt;shrink&lt;/code&gt; と &lt;code&gt;spread&lt;/code&gt; の逆向きの変換になっているのが分かるだろうか？ 逆向きにしたせいで足りない部分は &lt;code&gt;Nullable&lt;/code&gt; によって &lt;code&gt;Nothing&lt;/code&gt; となる． 例えば &lt;code&gt;Variant (&amp;quot;piyo&amp;quot; &amp;gt;: () ': HogeFields)&lt;/code&gt; から &lt;code&gt;Hoge&lt;/code&gt; に縮小する場合は，&lt;code&gt;embedAssoc (#piyo @= ())&lt;/code&gt; が &lt;code&gt;Nothing&lt;/code&gt; となり，他が &lt;code&gt;Just&lt;/code&gt; でラップされる．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;Coinclusion を用いて &lt;code&gt;toInt2&lt;/code&gt; 関数を実装してみると次のようになる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds           #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RankNTypes          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE ScopedTypeVariables #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;&lt;span class="ot"&gt;toInt1 ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;HogeFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;toInt1 &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;hoge &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;fuga &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;2&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;&lt;span class="ot"&gt;matchFieldWithDefault ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" data-line-number="12"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; r &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" data-line-number="13"&gt;matchFieldWithDefault defaultValue pat &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" data-line-number="14"&gt;  fromMaybe defaultValue &lt;span class="fu"&gt;.&lt;/span&gt; matchFieldWithMaybe pat&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" data-line-number="16"&gt;&lt;span class="ot"&gt;matchFieldWithMaybe ::&lt;/span&gt; forall xs ys h r &lt;span class="fu"&gt;.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" data-line-number="17"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; ys, xs ⊆ ys) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r) xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;VariantOf&lt;/span&gt; h ys &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" data-line-number="18"&gt;matchFieldWithMaybe pat &lt;span class="fu"&gt;=&lt;/span&gt; matchWith func (wrench pat)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" data-line-number="19"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" data-line-number="20"&gt;&lt;span class="ot"&gt;    func ::&lt;/span&gt; forall x &lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; h r)) x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Field&lt;/span&gt; h x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; r&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" data-line-number="21"&gt;    func fx gx &lt;span class="fu"&gt;=&lt;/span&gt; (\x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; runMatch (getField x) &lt;span class="fu"&gt;$&lt;/span&gt; getField gx) &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getNullable fx&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;めんどくさいので細かい解説はしない(そもそももっといい方法があるかもしれない)． この &lt;code&gt;matchFieldWithMaybe&lt;/code&gt; を用いれば &lt;code&gt;getNumber&lt;/code&gt; も簡単に実装できるだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getNumber ::&lt;/span&gt; (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="ch"&gt;&amp;#39;[&amp;quot;number&amp;quot; &amp;gt;: Int] ⊆ xs) =&amp;gt; Variant xs -&amp;gt; Maybe Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;getNumber &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithMaybe &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-イベントを拡張する"&gt;例 : イベントを拡張する&lt;/h2&gt;
&lt;p&gt;ここからは「多相バリアントを使いこなそう」で取り上げられてた例を Haskell で示そう． ひとつ目は次のふたつのイベント型を考える．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;keyPress&amp;quot; &amp;gt;: Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;keyRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;mousePress&amp;quot; &amp;gt;: (Int, Int)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;   , &lt;span class="st"&gt;&amp;quot;mouseRelease&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;   , &lt;span class="st"&gt;&amp;quot;click&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; (&lt;span class="dt"&gt;Int&lt;/span&gt;, &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて，これらの両方の型許容する型 &lt;code&gt;Event&lt;/code&gt; を作りたい． 普通の直和型を用いて次のように書くことが出来る．&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Key&lt;/span&gt; &lt;span class="dt"&gt;KeyboardEvent&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Mouse&lt;/span&gt; &lt;span class="dt"&gt;MouseEvent&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん，これでは元のふたつの型をうまく再利用できていない． 既に何度か登場している型レベルリストの連結 &lt;a href="https://hackage.haskell.org/package/extensible-0.4.8/docs/Data-Extensible-Product.html#t:-43--43-"&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt; を使って次のように書くこともできる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Event&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; (&lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="dt"&gt;MouseEventFields&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こうすると，&lt;code&gt;Event&lt;/code&gt; 型と &lt;code&gt;KeyboardEvent&lt;/code&gt; 型・&lt;code&gt;MouseEvent&lt;/code&gt; 型には包含関係ができ，前述した &lt;code&gt;Hoge&lt;/code&gt; 型で示した方法により各々で関数を共有することが出来る． 例えば次の &lt;code&gt;getCharFromEvent&lt;/code&gt; 関数は &lt;code&gt;KeyboardEvent&lt;/code&gt; 型と &lt;code&gt;Event&lt;/code&gt; 型の両方で利用できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb18-1" data-line-number="1"&gt;&lt;span class="ot"&gt;getCharFromEvent ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" data-line-number="2"&gt;  (&lt;span class="dt"&gt;Generate&lt;/span&gt; xs, &lt;span class="dt"&gt;KeyboardEventFields&lt;/span&gt; ⊆ xs) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Char&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" data-line-number="3"&gt;getCharFromEvent &lt;span class="fu"&gt;=&lt;/span&gt; matchFieldWithDefault (error &lt;span class="st"&gt;&amp;quot;not a key&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyPress   &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;keyRelease &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" data-line-number="6"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="例-トランプで-expression-problem"&gt;例 : トランプで Expression Problem&lt;/h2&gt;
&lt;p&gt;Expression Problem が何なのかは各位ググってもらうとして，「多相バリアントを使いこなそう」の最後で紹介されていた，多相バリアントによる Expression Problem の解法を Haskell でもやってみる．&lt;/p&gt;
&lt;p&gt;次のような型と関数があったとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" data-line-number="3"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;number&amp;quot; &amp;gt;: Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" data-line-number="4"&gt;   , &lt;span class="st"&gt;&amp;quot;jack&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" data-line-number="5"&gt;   , &lt;span class="st"&gt;&amp;quot;queen&amp;quot;&lt;/span&gt;  &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;king&amp;quot;&lt;/span&gt;   &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-7" data-line-number="7"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-9" data-line-number="9"&gt;&lt;span class="ot"&gt;cardNum ::&lt;/span&gt; &lt;span class="dt"&gt;Card&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-10" data-line-number="10"&gt;cardNum &lt;span class="fu"&gt;=&lt;/span&gt; matchField cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-12" data-line-number="12"&gt;&lt;span class="ot"&gt;cardNumPattern ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; (&lt;span class="dt"&gt;Match&lt;/span&gt; &lt;span class="dt"&gt;Identity&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="dt"&gt;CardFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-13" data-line-number="13"&gt;cardNumPattern&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-14" data-line-number="14"&gt;    &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; id&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;11&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-16" data-line-number="16"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;12&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-17" data-line-number="17"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const &lt;span class="dv"&gt;13&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-18" data-line-number="18"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;cardNumPattern&lt;/code&gt; を切り出しているのがあからさまに恣意的だが…)これに以下のことは可能だろうか？&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(キャストせず)&lt;/li&gt;
&lt;li&gt;元のコードを一切変更せず&lt;/li&gt;
&lt;li&gt;新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;新しい操作も加えた&lt;/li&gt;
&lt;li&gt;新しい場合分け構造を定義する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後の「構造」というのは今回は置いておいて(OCaml ではモジュールとして定義してたが，Haskell でモジュールに切り分けるにはファイルを切り分ける必要があるので…めんどい…)，1-4を考えてみよう． &lt;code&gt;Card&lt;/code&gt; 型やその関数を拡張したものとして，次のような &lt;code&gt;CardExt&lt;/code&gt; 型とその関数を定義した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb20-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Variant&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" data-line-number="2"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;CardExtFields&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;CardFields&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[&amp;quot;joker&amp;quot; &amp;gt;: ()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" data-line-number="4"&gt;&lt;span class="ot"&gt;cardExtNum ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" data-line-number="5"&gt;cardExtNum &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" data-line-number="6"&gt;  matchField &lt;span class="fu"&gt;$&lt;/span&gt; shrink (&lt;span class="fu"&gt;#&lt;/span&gt;joker &lt;span class="fu"&gt;@=&lt;/span&gt; (const &lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; () &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; cardNumPattern)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" data-line-number="8"&gt;&lt;span class="ot"&gt;nextCardExt ::&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;CardExt&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" data-line-number="9"&gt;nextCardExt &lt;span class="fu"&gt;=&lt;/span&gt; matchField&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" data-line-number="10"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; (\n &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;if&lt;/span&gt; n &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; n &lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" data-line-number="11"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;jack   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" data-line-number="12"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;queen  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" data-line-number="13"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;king   &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; ())&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" data-line-number="14"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;joker  &lt;span class="fu"&gt;@=&lt;/span&gt; const (embedAssoc &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;number &lt;span class="fu"&gt;@=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" data-line-number="15"&gt;   &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt; nil&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで一応&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;静的で安全に(もちろん!)&lt;/li&gt;
&lt;li&gt;既存のコードを改造せず&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;joker&amp;quot; &amp;gt;: ()&lt;/code&gt; という新しい場合分けを加え&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextCardExt&lt;/code&gt; という新しい操作(関数)を加える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ことができた．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;組込みでこれらの機能がある OCaml はいいなぁとなった．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180316/1521169933</id><title type="text">TLS 1.3 開発日記 その27 ID 25/26</title><updated>2018-03-16T03:12:13Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180316/1521169933"/><summary type="html">
&lt;div class="section"&gt;
&lt;h4&gt;ドラフト25&lt;/h4&gt;
&lt;p&gt;ドラフト24までは、AEADに使う additonal_data は空文字列だった。ドラフト25からは、&lt;a href="https://github.com/tlswg/tls13-spec/pull/1158" target="_blank"&gt;正しいレコードヘッダが使われることを遵守させるため&lt;/a&gt;に、additonal_dataが以下のように定義された。&lt;/p&gt;
&lt;pre&gt;
       additional_data = TLSCiphertext.opaque_type ||
                         TLSCiphertext.legacy_record_version ||
                         TLSCiphertext.length
&lt;/pre&gt;
&lt;p&gt;以下の TLSCiphertext の構造と見比べれば、これがレコードヘッダそのものであることが分かるだろう。&lt;/p&gt;
&lt;pre&gt;
       struct {
           ContentType opaque_type = application_data; /* 23 */
           ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
           uint16 length;
           opaque encrypted_record[TLSCiphertext.length];
       } TLSCiphertext;
&lt;/pre&gt;
&lt;p&gt;注意したいのは、TLSCiphertext.lengthである。復号化の際は TLSCiphertext.length は、入力の長さを図ればよい。しかし、暗号化の際は AEAD-Encrypt を呼び出す前に、結果の暗号文の長さを計算する必要がある。&lt;/p&gt;
&lt;p&gt;TLS 1.3のAEAD-Encryptは、暗号文+認証タグを生成する。暗号文の長さは、平文の長さに等しい。よって、以下のように計算できる。&lt;/p&gt;
&lt;pre&gt;
      暗号文の長さ = 平文の長さ + 認証タグの長さ
&lt;/pre&gt;
&lt;p&gt;一方 TLS 1.2 では、&lt;a href="http://d.hatena.ne.jp/kazu-yamamoto/20170426/1493186127" target="_blank"&gt;additonal_data に平文(本当は圧縮文)のレコードヘッダを使う&lt;/a&gt;。すなわち、復号化の際にあらかじめ平文の長さを計算しておく必要がある。TLS 1.2 の ADEAD では explicit IV が利用されるので、以下のように平文の長さを計算できる。&lt;/p&gt;
&lt;pre&gt;
      平文の長さ = 暗号文の長さ - explicit IV の長さ - 認証タグの長さ
&lt;/pre&gt;
&lt;h4&gt;ドラフト26&lt;/h4&gt;
&lt;p&gt;supported_versions拡張では、TLS 1.2 以前のバージョンを交渉してはいけないことが明記された。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180306/1520314185</id><title type="text">[Haskell]あなたの知らないSemigroupの世界</title><updated>2018-03-06T05:29:45Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180306/1520314185"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;自分で定義するデータの中には、足し算したくなるようなデータがある。たとえば、送信と受信のカウンターを定義したとしよう。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synType"&gt;data&lt;/span&gt; Metrics &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics {
    rx &lt;span class="synStatement"&gt;::&lt;/span&gt; Int
  , ts &lt;span class="synStatement"&gt;::&lt;/span&gt; Int
  } &lt;span class="synType"&gt;deriving&lt;/span&gt; (Eq, Show)
&lt;/pre&gt;

&lt;p&gt;これは以下のように足し算できると嬉しいだろう。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;+&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;しかしこれは Num のインスタンスにすべきではない。このデータ型に掛け算は定義できないからだ。かといって、addMetrics みたいな関数を定義するのはかっこ悪い。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;`addMetrics`&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;このように演算子が一個だけ欲しいと思ったら、それは多分 Monoid だ。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synPreProc"&gt;import&lt;/span&gt; Data.Monoid

&lt;span class="synType"&gt;instance&lt;/span&gt; Monoid Metrics &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;0&lt;/span&gt; &lt;span class="synConstant"&gt;0&lt;/span&gt;
    Metrics r1 t1 &lt;span class="synStatement"&gt;`mappend`&lt;/span&gt; Metrics r2 t2 &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics (r1 &lt;span class="synStatement"&gt;+&lt;/span&gt; r2) (t1 &lt;span class="synStatement"&gt;+&lt;/span&gt; t2)
&lt;/pre&gt;

&lt;p&gt;GHC 7.10までは、(&amp;#60;&amp;#62;) が mappend の別名であるので、以下のようなコードが書ける。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;やったね！&lt;/p&gt;
&lt;h4&gt;GHC 8.4へようこそ&lt;/h4&gt;
&lt;p&gt;上記のコードを GHC 8.4 で読み込むと以下のようなエラーが出る。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
Example.hs&lt;span class="synStatement"&gt;:&lt;/span&gt;&lt;span class="synConstant"&gt;8&lt;/span&gt;&lt;span class="synStatement"&gt;:&lt;/span&gt;&lt;span class="synConstant"&gt;10&lt;/span&gt;&lt;span class="synStatement"&gt;:&lt;/span&gt; error&lt;span class="synStatement"&gt;:&lt;/span&gt;
    ・ No &lt;span class="synType"&gt;instance&lt;/span&gt; for (Semigroup Metrics)
        arising from the superclasses &lt;span class="synStatement"&gt;of&lt;/span&gt; an &lt;span class="synType"&gt;instance&lt;/span&gt; declaration
    ・In the &lt;span class="synType"&gt;instance&lt;/span&gt; declaration for ‘Monoid Metrics’
  &lt;span class="synStatement"&gt;|&lt;/span&gt;
&lt;span class="synConstant"&gt;8&lt;/span&gt; &lt;span class="synStatement"&gt;|&lt;/span&gt; &lt;span class="synType"&gt;instance&lt;/span&gt; Monoid Metrics &lt;span class="synType"&gt;where&lt;/span&gt;
  &lt;span class="synStatement"&gt;|&lt;/span&gt;          &lt;span class="synStatement"&gt;^^^^^^^^^^^^^^&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;これはどういうことだろう？ その疑問に答えるのがこの記事の主旨である。&lt;/p&gt;
&lt;p&gt;mappendよりも(&amp;#60;&amp;#62;)の方がかっこいいのに、長い間 (&amp;#60;&amp;#62;) はMonoidのメソッドにはしてもらえなかった。あくまで別名であった。それは一部の人に、SemigroupをMonoidのスーパークラスにするという野望があったからだ。&lt;/p&gt;
&lt;p&gt;数学での定義を思い出そう：&lt;/p&gt;
&lt;h5&gt; 半群 (Semigroup)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt; モノイド (Monoid)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;li&gt; 単位元：e &amp;#60;&amp;#62; a = a &amp;#60;&amp;#62; e = a&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt; 群 (Group)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;li&gt; 単位元：e &amp;#60;&amp;#62; a = a &amp;#60;&amp;#62; e = a&lt;/li&gt;
&lt;li&gt; 逆元：a &amp;#60;&amp;#62; inv a = e&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっきの疑問に答えると、GHC 8.4ではSemigroupがMonoidのスーパークラスとなり、Metricsに対する(&amp;#60;&amp;#62;)の定義がないために、エラーが出たという訳だ。&lt;/p&gt;
&lt;h4&gt;状況把握&lt;/h4&gt;
&lt;p&gt;今後どのようなコードを書けばよいかという疑問に答えるためには、GHCの各バージョンでの状況を把握しなければならない。&lt;/p&gt;
&lt;h5&gt;GHC 7.10 (base 4.8)&lt;/h5&gt;
&lt;p&gt;GHC 7.10 では、みなさんご存知のように base パッケージに Data.Monoid モジュールがある：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- base : Data.Monoid&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
    mappend &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend
&lt;/pre&gt;

&lt;p&gt;Monoid型自体はPreludeの仲間入りを果たしたが、(&amp;#60;&amp;#62;)は明示的にimportする必要がある。&lt;/p&gt;
&lt;p&gt;Data.Semigroupは、semigroupsパッケージで定義されている：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- semigroup : Data.Semigroup&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
    (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

&lt;span class="synType"&gt;default&lt;/span&gt; (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; Monoid a &lt;span class="synStatement"&gt;=&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
  (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend
&lt;/pre&gt;

&lt;p&gt;最後の default は、DefaultSignatures という拡張で、Monoidの制約を持てば Semigroupの方の (&amp;#60;&amp;#62;) は mappend で代用できると読む。親子関係がひっくり返っていて、なんだかなぁという感じである。&lt;/p&gt;
&lt;h5&gt;GHC 8.0 (base 4.9)&lt;/h5&gt;
&lt;p&gt;Data.Semigroupがsemigroupパッケージからbaseパッケージへ移った：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- base : Data.Monoid&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
    mappend &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend

&lt;span class="synComment"&gt;--base : Data.Semigroup&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
    (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
&lt;/pre&gt;

&lt;p&gt;親子関係はない。&lt;/p&gt;
&lt;p&gt;フラグ -Wnoncanonical-monoid-instances が定義された。これは、MonoidのインスタンスなのにSemigroupのインスタンスになってないと警告を出すフラグである。デフォルトは off。上位互換性に関するフラグ -Wcompat を付けても、警告が出る。&lt;/p&gt;
&lt;p&gt;まだ GHC 8.4 を使えない人は、-Wall の横に -Wcompat を書き足して遊んでみるとよい。&lt;/p&gt;
&lt;h5&gt; GHC 8.2 (base 4.10)&lt;/h5&gt;
&lt;p&gt;何も変更なし。嵐の前の静けさだ。&lt;/p&gt;
&lt;h5&gt; GHC 8.4 (base 4.11)&lt;/h5&gt;
&lt;p&gt;なんとなんと、MonoidとSemigroupがPreludeの仲間に入った。そして、SemigroupがMonoidのスーパークラスとなった。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- Prelude&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
  (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synStatement"&gt;=&amp;#62;&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
  mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
&lt;/pre&gt;

&lt;p&gt;訂正：SemigroupがMonoidのスパークラスになったために、(&amp;#60;&amp;#62;) を定義してないとエラーが出るようになった。嵐がやってきたのだ。&lt;/p&gt;
&lt;h4&gt;対処方法&lt;/h4&gt;
&lt;p&gt;ここまで解説すれば、対処方法は明らかであろう。&lt;a href="https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid" target="_blank"&gt;Semigroup (as superclass of) Monoid Proposal&lt;/a&gt;の最後に、semigroupsパッケージを使う方法と使わない方法が載っているので、よく眺めてほしい。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html</id><title type="text">[haskell] http-clientライブラリを利用してHaskellでHTTPクライアント機能を実装する</title><updated>2018-03-05T09:34:57.715+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html"/><summary type="text">Haskellでは、http-clientライブラリを用いることで、HTTPクライアント機能を簡単に実装できます。http-client以外にも何種類かライブラリがありますが、今回はhttp-client, http-client-tlsの機能と使い方をまとめておきます。

本エントリで紹介するhttp-client, http-client-tlsライブラリの機能：

単純なHTTP GETリクエスト

主要な型の説明 

Managerのカスタマイズ 

https
proxy設定 
タイムアウト値の設定

Requestのカスタマイズ

ベーシック認証 
リクエストヘッダ 

Responseの操作

ストリーミング受信 
レスポンスヘッダの参照 

エラーハンドリング 






単純なHTTP GETリクエスト
{-# LANGUAGE OverloadedStrings #</summary></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v6</id><title type="text">test6</title><updated>2018-03-03T13:44:46Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v6"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v5</id><title type="text">test5</title><updated>2018-03-03T12:20:13Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v5"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v4</id><title type="text">test4</title><updated>2018-03-03T05:46:33Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v4"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v3</id><title type="text">test3</title><updated>2018-03-03T05:05:52Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v3"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v2</id><title type="text">test2</title><updated>2018-03-03T04:59:34Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v2"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v1</id><title type="text">test1</title><updated>2018-03-03T04:55:52Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v1"/></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180302/1519966635</id><title type="text">TLS 1.3 開発日記 その26 ID 24</title><updated>2018-03-02T04:57:15Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180302/1519966635"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;TLS 1.3 ドラフト24で重要な変更は1つだけ。レコードのバージョン。&lt;/p&gt;
&lt;p&gt;ドラフト23では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に定められた。これはこれでよい。&lt;/p&gt;
&lt;p&gt;しかし、サーバから HelloRetryRequest なる ServerHello が返され場合はどうなるだろう？ ある実装では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello (HRR) のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となるだろう。また別の実装では、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello (HRR) のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となるだろう。&lt;/p&gt;
&lt;p&gt;どちらがミドルボックスを騙せるかというと、後者である。前者はレコードのバージョンがころころ変わるから、ミドルボックスが怪しいと思って通信を遮断するかもしれない。&lt;/p&gt;
&lt;p&gt;というわけで、2回目の ClientHello のレコードバージョンは、0x0303 に定められた。なお、実装者間の合意ではドラフト 24 に対応しても、supported_versions 拡張に指定するTLSのバージョンにはドラフト 23 の値を使うことで合意が取れている。&lt;/p&gt;
&lt;p&gt;個人的には、レコードの書式にバージョンフィールドがあるのはプロトコルの設計ミスだと思う。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html</id><title type="text">[haskell] stack install cryptoniteがno such instruction: `rdrand %r8'エラーで失敗する問題の対処方法</title><updated>2018-02-25T15:34:07.378+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html"/><summary type="text">手許の環境（mac）で、cryptoniteライブラリのビルドがエラーになる問題が発生したが、ネットの情報を元に解決できたので、その症状と手順をblogに残しておく。



エラーの症状：
stack install cryptoniteで以下のようなエラーが発生。
% stack install cryptonite
--  While building custom Setup.hs for package cryptonite-0.24 using:
      /Users/xxx/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.0.1.0 build --ghc-options " </summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180214/1518587871</id><title type="text">[TLS][Haskell]TLS 1.3 開発日記 その25 picotls</title><updated>2018-02-14T05:57:51Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180214/1518587871"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;kazuho さんが実装を進めている picotls を使う方法のまとめ。picotls は TLS 1.3 のみを実装している。またデフォルトで利用できる ECDHE は P256 のみである。&lt;/p&gt;
&lt;h4&gt; インストール&lt;/h4&gt;
&lt;p&gt;cmakeが必要なので、あらかじめインストールしておく。master ブランチが draft 23。&lt;/p&gt;
&lt;pre&gt;
% git clone https://github.com/h2o/picotls
% cd picotls
% git submodule init
% git submodule update
% cmake .
% make
&lt;/pre&gt;

&lt;p&gt;これで、トップディレクトリに "cli" というコマンドができる。"cli" は、サーバにもクライアントにもなる。&lt;/p&gt;
&lt;h4&gt; picotls サーバ&lt;/h4&gt;
&lt;pre&gt;
% ./cli -k $SOMEWHERE/key.pem -c $SOMEWHERE/certificate.pem 127.0.0.1 13443
&lt;/pre&gt;

&lt;h4&gt; picotls クライアント&lt;/h4&gt;
&lt;p&gt;Full:&lt;/p&gt;
&lt;pre&gt;
% ./cli 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;HRR: &lt;/p&gt;
&lt;p&gt;最初はkey_shareを空にして送るという裏技を使う&lt;/p&gt;
&lt;pre&gt;
% ./cli -n 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;PSK:&lt;/p&gt;
&lt;p&gt;最初の -s オプションでチケットを保存し、次の -s オプションでチケットを読み込む。&lt;/p&gt;
&lt;pre&gt;
% rm ticket
% cli -s ticket 127.0.0.1 443
% cli -s ticket 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;0RTT:&lt;/p&gt;
&lt;pre&gt;
% rm ticket
% cli -s ticket 127.0.0.1 443
% cat early-data.txt - | cli -s ticket 127.0.0.1 443
&lt;/pre&gt;

&lt;/div&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180116/1516075029</id><title type="text">[TLS][Haskell]TLS 1.3 開発日記 その24 ID23</title><updated>2018-01-16T03:57:09Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180116/1516075029"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;ID23での変更点：&lt;/p&gt;
&lt;h4&gt; key_share拡張&lt;/h4&gt;
&lt;p&gt;Canonのプリンターが40を使っていることが判明したので、key_share拡張の値を40から51へ変更。&lt;/p&gt;
&lt;h4&gt; signature_algorithms_cert拡張&lt;/h4&gt;
&lt;p&gt;signature_algorithmsに加えてsignature_algorithms_cert拡張を新設した。CertificateVerify用がsignature_algorithms、証明書用がsignature_algorithms_cert。signature_algorithms_certがなければsignature_algorithmsで代用する。&lt;/p&gt;
&lt;p&gt;PSSを分割した。たとえばrsa_pss_sha256は、rsaEncryption用のrsa_pss_rsae_sha256とRSASSA-PSS用のrsa_pss_pss_sha256に分かれた。&lt;/p&gt;
&lt;h4&gt; 不変条件&lt;/h4&gt;
&lt;p&gt;不変条件が加筆された：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クライアントは提案したものは必ず実装してないといけない&lt;/li&gt;
&lt;li&gt;サーバはわからないものは単に無視(異常終了してはいけない)&lt;/li&gt;
&lt;li&gt;TLSを終端するミドルボックスはその両方を満たせ&lt;/li&gt;
&lt;li&gt;単にリレーするミドルボックスは中身を触るな&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt; CSS&lt;/h4&gt;
&lt;p&gt;状態を持たないサーバは、一番目と二番目のClientHelloの間に到着するCSSを無視すること。&lt;/p&gt;
&lt;h4&gt; 静的なRSA&lt;/h4&gt;
&lt;p&gt;静的なRSAは、Bleichenbacher-type攻撃を防止するために使用不可にすべき。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html</id><title type="text">[haskell][yesod] TypedContentを利用してクライアントが要求するフォーマットでレスポンスを返す</title><updated>2016-12-17T15:16:26.835+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html"/><summary type="text">Yesod Advent Calendar 2016の6日目の記事です。

RESTfulなAPIを提供する場合、クライアントの都合にあわせて、フォーマットを変えてレスポンスを返したいケースがあります。サーバー上で管理しているDBから、表現だけをHTML, JSON, XML, CSVなどに変更して返すイメージです。例えば、人物情報（名前、年齢、性別など）の一覧を返す際には以下のようなデータが返されることになります。

HTML
&lt;table border&gt;
  &lt;tr&gt;
    &lt;th&gt;name&lt;/th&gt;    &lt;th&gt;sex&lt;/th&gt;    &lt;th&gt;age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Taro Yamada&lt;/td&gt;    &lt;td&gt;Male&lt;/td&gt;    &lt;td&gt;18&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Hanako Yamada&lt;/</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html</id><title type="text">[haskell][yesod] stackのnewコマンドで指定できるyesod関連templateの説明</title><updated>2016-12-03T23:37:28.283+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html"/><summary type="text">現状、stackで指定できるyesod関連のtemplatesには以下のものがあります。どのtemplateに何が用意されているのか、知りたかったのですがどこにも説明されていないようなので、調べてまとめてみました。
% stack templates | grep yesod
yesod-hello-world （←現時点では削除されています）
yesod-minimal
yesod-mongo
yesod-mysql
yesod-postgres
yesod-postgres-fay
yesod-simple
yesod-sqlite


以下、各テンプレートの説明です。後に出てくるテンプレートほど内容が複雑になっています。テンプレートを指定して新しいプロジェクトを生成する場合は以下のコマンドを実行します。
% stack new プロジェクト名 yesod-???




</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html</id><title type="text">[emacs] emacs上のgrep関連機能、複数ファイルの一括置換手順のまとめ</title><updated>2016-11-30T10:03:25.873+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html"/><summary type="text">emacs上でgrep関連の機能を利用する際のTIPSをまとめておきます（よく忘れて調べ直すので…）。


grepコマンドのオプション

指定ディレクトリ以下のファイルを再帰的に検索

-R DIR    シンボリックリンクを辿る
-r  DIR    シンボリックリンクは辿らない

検索対象をファイル名でフィルタする

--include=GLOB    GLOBにファイル名を指定する。"*.cpp"のようにワイルドカード（*,?,[...]）を指定可能

検索対象から指定ファイル・ディレクトリを除外する

--exclude=GLOB   GLOBに除外するファイルのファイル名を指定する（ワイルドカード指定可能）。
--exclude-dir=DIR DIRに指定されたディレクトリをスキップ


使用例：

docディレクトリ以下の.txtを拡張子に持つ全てのファイルを対象に"</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html</id><title type="text">[cygwin] cygwin64セットアップメモ</title><updated>2016-11-28T00:47:36.358+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html"/><summary type="text">自分向け備忘録。cygwin64環境をセットアップする際の手順をまとめておきます。


設定


ssh-agent関連

ssh-agentの重複起動を防ぐ
ssh-agentのために秘密鍵セットアップ

~/.ssh/

※group/otherのrw権限は削除


ssh-agentがパスワードを覚えてくれなくなった問題への対処

pingのエラー回避
ユーザーのアカウント名、ホームディレクトリの変更

/etc/passwdを編集する

GNU screen でlessやvimの終了後に画面クリアをしない方法
改行コードにCR+LFが用いられているbashスクリプトを実行するための設定
tcshのデフォルト補完設定のイマイチな部分を修正




環境変数

HOME

ホームディレクトリを設定



SHELL

"/bin/tcsh"とすることでデフォルトのシェルが切り替わる
</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html</id><title type="text">[haskell][yesod] YesodにおけるRESTfulなJSON API実装チュートリアル</title><updated>2016-08-28T17:53:43.356+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html"/><summary type="text">HaskellのwebフレームワークであるYesodにおいて、RESTful APIを実装する手順を紹介します。Haskell上のデータ構造をJSONテキストに変換する、逆に、JSONテキストをパースしてHaskell上のデータ構造を生成する、といった処理が非常に簡単に実現できます。加えて、コードを書かなくてもバックエンドのDBとのORマッピングが可能になっており、効率的に開発することができます。
ここで紹介しているコードはgithubにコミットしています。


準備：

json-sampleというプロジェクト名でYesodのscaffolding siteをセットアップする

空のプロジェクト生成

% stack new json-sample yesod-sqlite --system-ghc

"--system-ghc"は省略可能。インストール済みのghcを使うことを指示し</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html</id><title type="text">[haskell][yesod] stack対応版Yesod tutorial</title><updated>2016-07-17T18:06:36.108+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html"/><summary type="text">HaskellのwebサービスフレームワークにYesodというフレームワークがあります。Yesodに触れたことのない開発者向けに書かれたチュートリアルの一つにYesod tutorialがあり、手順に沿っていくだけで簡単なwebサービスを動作させることができ、Yesodで何ができるかを簡単に理解できるようになっています。
ただ残念なことに、このYesod tutorialの記載は内容が古く、stackを利用した現行の手順とマッチしなくなっています。stackに対応している最新環境（Yesod 1.4.x）における順があると役に立つと思い、書き起こしてみました。


Before the real start（はじめに）

Install（インストール手順）
stackをインストールする。以下のサイトが参考になります。

installation instructions for </summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html</id><title type="text">[haskell][yesod] stack exec -- yesod devel で devel.hs: getAddrInfo: does not existというエラーになる問題の対処方法</title><updated>2016-07-17T17:39:43.279+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html"/><summary type="text">
Widnwos環境での現象：
windows上でyesodのscafolding siteをセットアップし、さあ起動！ブラウザから接続確認してOKとなるはずが、なぜか「The application isn't built」という表示が出てしまいました。



このときターミナルには以下のようなログが出力されていました。
% stack exec -- yesod devel
Yesod devel server. Type 'quit' to quit
Application can be accessed at:

http://localhost:3000
https://localhost:3443
If you wish to test https capabilities, you should set the following variable:
  export </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html</id><title type="text">[haskell] cmdargsパッケージで楽々コマンドライン引数パース</title><updated>2016-02-11T01:10:46.307+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html"/><summary type="text">コマンドラインツール実装時、オプション指定とか引数の並びとか考え始めると大変です。HaskellではSystem.EnvironmentモジュールからgetArgsという関数が提供されていますが、本エントリで紹介するcmdargsパッケージを利用すると以下のようなことが簡単にできます。

cmdargsパッケージの特徴：

データ構造を定義するだけで起動引数・オプションのパースができる
パース結果を型付きで参照することができる
パース失敗時には、原因がわかるエラーメッセージが表示される
--help, --versionオプションで表示される情報を自動で生成してくれる

Haskell版GNU getoptライブラリと比べて以下の2点が優れている、とHPには書かれています。

HLintコマンドラインのハンドリングが1/3の短さ
Cabal, darcsなどのmultiple mode</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージ利用時にテーブルにインデックスを生成する方法</title><updated>2016-01-30T17:12:12.076+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html"/><summary type="text">PersistentパッケージにはMigration機能が備わっており、自動的にテーブルを生成してくれます。スキーマ変更を行った際にも、変換が可能な限りテーブル内のレコードを保持したまま新しいスキーマに変換してくれます（Migration機能については過去のエントリでまとめています）。

自分が利用する上で、インデックスやトリガーを生成する手順が紹介されておらず困っていたのですが、rawExecuteという関数を用いることで自由にDDLを発行できることがわかりました。以下その手順とサンプルを紹介しておきます。


サンプルコード：
以下は、personテーブルのnameカラムにインデックスをs生成するサンプルです。runMigration実行直後に、runExecuteを実行することでインデックスを生成しています。このサンプルではインデックスを生成しているだけですが、同じ手順でトリガーの</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージのmigration機能のまとめ</title><updated>2016-01-30T17:11:40.032+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html"/><summary type="text">HaskellでDB操作ができるPersistentパッケージの紹介をしましたが、このエントリではPersistentパッケージが提供しているmigration機能をまとめておきます。
DBを作って運用していると、機能追加や仕様変更に伴いスキーマ変更が必要になるケースが多々あります。このようなケースにおいてPersistentのmigration機能がどれくらい使えるのかを調べた結果です。


基本：
Persistetのmigration機構は（保守的なルールに沿って）スキーマ変更をある程度まで自動で処理してくれます。
ロードしたDB内のテーブル情報と、コードで定義されたEntity Definition（テーブル定義）を比較し、以下のケースにおいてスキーマの変更を行います。

カラムの型を変更した場合：

ただし、値の変換ができない場合には、DBによって拒否されることになります。

</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html</id><title type="text">[haskell][gcc][win] Windows版Haskell Platform付属のgccでC++11のコードをコンパイルする方法</title><updated>2016-01-15T00:45:37.692+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html"/><summary type="text">Windows版のHaskell Platformにはmingwが同梱されておりgccが含まれています。現在自分のPCにはHaskell Platform 2014.2.0.0をインストールしているのですが、これに付属されているgccでC++11のコードをコンパイルしようとすると、以下のようなエラーになってしまいました。
% gcc -std=c++11 cpp11.cpp
cc1plus.exe: error: unrecognized command line option '-std=c++11'


-stdオプションで"c++11"を指定しても、認識してくれません。
本家のサイトによると、'-std=c++11'オプションはgcc 4.7でサポートされたようです。これに対し、Haskell Platform 2014.2.0.0に付属されているgccのバージョンを確認したところ</summary></entry><entry><id>http://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html</id><title type="text">[sqlite] SQLiteのロック・トランザクション関連仕様の整理</title><updated>2016-01-06T12:11:40.986+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html"/><summary type="text">SQLiteは共有ロック・排他ロックの仕組みを備えており、プロセス内の複数スレッド、だけでなく、プロセスをまたぐ状態でSQLが同時に発行されても適切に処理されます。
トランザクションに複数のモードが存在し、指定するモードに依って取得されるロックが変わります。さらにSQLの内容に依存してロック状態が遷移するため、複数プロセスがアクセスしたときの挙動を正確に把握できるよう、仕様を整理してみました。
（文中の「プロセス」は、正確には「プロセス、もしくはスレッド」を意味します。）


DBのロック状態の種類：

UNLOCKED

ロックされていない状態。誰も読み書きしていない。DBの初期状態。

SHARED

read可、write不可な状態。複数プロセスが同時にSHAREDロックを取得可能。複数プロセスが同時にreadできることを意味する。DBがこの状態にあるとき、他のプロセスからの</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html</id><title type="text">[cygwin][haskell][emacs] MinGWでcygwinの"/cygdrive"パスにアクセスする裏技（cygwin環境のemacsでflycheckを動作させる方法）</title><updated>2015-12-27T23:55:24.842+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html"/><summary type="text">haskell関連のコマンドはMinGW上でビルドされているため、cygwin環境の"/cygdrive"から始まるパスには対応していません。haskell-hlintから呼び出されるhlintも当然この問題の影響を受けておりemacs関連の設定が適切にされていたとしても、以下のようなエラーが表示されてしまいます。



ミニバッファに表示されるエラー詳細：
Suspicious state from syntax checker haskell-hlint: Checker haskell-hlint returned non-zero exit code 1, but no errors from output: hlint.exe: Couldn't find file: /cygdrive/c/Users/Hiroyuki/tmp/flycheck_hello.hs



</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html</id><title type="text">[haskell][stack] stack exec ghciで”Couldn't match expected type"エラーが発生する問題の対処</title><updated>2015-11-08T15:09:21.187+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html"/><summary type="text">先日、haskellのパッケージ管理をcabalからstackに移行して「便利〜！」と感動していたところなのですが、stach exec ghciでソースをロードしようとすると"Couldn't match expected type: xxxxx"とエラーが発生する問題に遭遇しました。
ネットの情報を参考に解決することができたのでその手順をまとめておきます。


問題：
stack buildは成功するにもかかわらず、stack exec ghci xxx.hs（xxx.hsはbuild対象のファイル）がエラーになる。
stack exec ghci実行時のエラーログ：
% stack exec ghci FileToVec.hs
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
[1 of 1] </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html</id><title type="text">[cygwin] cygwinのシェル起動時にPATHの先頭に/usr/binと/usr/local/binが勝手に追加されないようにする</title><updated>2015-11-04T22:29:43.126+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html"/><summary type="text">cygwinのデフォルトの設定では、シェル起動時に以下の2つのディレクトリが自動的にPATHの先頭に追加されます。

/usr/local/bin
/usr/bin


cygwinでインストールされているコマンドと同名の別コマンドを優先して起動したい場合には、この設定が邪魔になります。
これを無効にするには以下の方法があります。お好みでどちらかを選択してください。

/etc/profileもしくは/etc/csh.loginの該当処理をコメントアウトする（bash / tcsh）

cygwinがPATHを上書きしているのは、/etc/profile（bashの場合）と/etc/csh.login（tcshの場合）です。これらのスクリプトを編集することで、/usr/binと/usr/local/binが勝手に追加されないようにできます。

ORIGINAL_PATHでPATHを上書き</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html</id><title type="text">[ssh] OpenSSHのアップデートでssh-agentがパスワードを覚えてくれなくなった問題への対処</title><updated>2015-09-06T00:44:24.703+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html"/><summary type="text">ssh-agent/ssh-addを利用してsshを用いたサーバーへのログイン時のパスワード入力を省略している方、OpenSSHのアップデートにより、毎回パスワード入力を求められるようになった場合は以下の設定を疑ってみてください。


問題の症状：
OpenSSHパッケージを最新版にアップデートすると発生するようになった問題です。ssh-agentを起動してssh-addで鍵を正しく登録しているにも関わらず、sshコマンドを実行する度に"password:"というプロンプトが表示されてパスワードの入力を求められてしまいます。


環境：
問題に遭遇＆解決した私のcygwin環境では以下のバージョンで問題が発生することを確認しました。

OpenSSH_7.0p1, OpenSSL 1.0.2d 9 Jul 2015
OpenSSH_7.1p1, OpenSSL 1.0.2d 9 Jul </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html</id><title type="text">[cygwin] cygwin版X server（XWin）にリモートクライアントから接続できない問題の対処方法</title><updated>2015-09-02T23:09:07.989+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html"/><summary type="text">cygwinを最新バージョンにアップデートしたところ、リモートのX clientからwindows上のcygwin版X serverに接続できなくなってしまいました。
対処方法は簡単でXWin起動時に"-listen tcp"オプションを付けてあげればよいだけです。cygwinバージョンアップ前にはオプション指定なしで接続できていたため、デフォルトの設定が変わったのだと思われます。


cygwin環境：
uname -aで表示されるcygwinバージョン情報です。

% uname -a
CYGWIN_NT-6.1 xxx 2.2.1(0.289/5/3) 2015-08-20 11:42 x86_64 Cygwin



問題発生時の症状：
クライアント側で起動したxtermをサーバー側で表示しようとすると、以下のようなエラーになっていました。
% xterm
xterm Xt </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html</id><title type="text">[cygwin][emacs] cygwin版emacsでgtagsを使えるようにする方法</title><updated>2015-08-17T00:49:02.649+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html"/><summary type="text">これまでタグジャンプにはctagsを用いていたのですが、gtagsの「呼び出し元も一覧できる」という機能に惹かれてセットアップしてみました。いくつかはまりポイントがあったのでその対応方法も含め、手順を残しておきます。
cgwin提供のパッケージにはgtagsは含まれていなかったため、自前でビルドすることにしました。


目次：

gatgsの特徴
gtagsのインストール手順
emacsの設定
gtagsの使い方




gtagsの特徴：

良い点！

関数の呼び出し元を一覧表示しジャンプできる（gtags-find-rtag）
関数だけでなく、ローカル変数を含む任意のシンボルをタグジャンプできる（gtags-find-symbol）

正規表現で一覧絞り込み可能（gtags-find-pattern）
開いているファイルで絞り込み可能（gtags-parsefiile）

特定文字列</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/06/subversion.html</id><title type="text">[subversion] 特定ディレクトリ以下をサーバーとの同期対象から除外する方法</title><updated>2015-06-26T13:55:24.651+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/06/subversion.html"/><summary type="text">subversionでチェックアウトした作業コピー内の特定ディレクトリ以下をサーバーとの同期対象から除外したい、ということを考えたことはないでしょうか。
例えば、リポジトリの特定ディレクトリ以下に自分にとって不要なファイルやアーカイブが多数コミットされていると、以下のような無駄が生じます。これらの無駄をなくしたい、というのが主なユースケースです。

不要なファイル・アーカイブによってディスクスペースが占有される
サーバー上に更新が発生した際にupdateに余計な時間がかかってしまう



単純に特定ディレクトリ以下の作業ファイルを削除してしまうと、コミット時に差分として検知されてしまう、また、次回以降のupdateコマンドで再ダウンロードされてしまう、という非常に残念な挙動になります。

このようなケースでは以下の方法を使えば、差分が検知されない状態で所定ディレクトリ以下のファイルを削除</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html</id><title type="text">[windows][haskell] Widnwos環境でHaskell Platformを完全削除する方法</title><updated>2015-04-05T01:53:40.022+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html"/><summary type="text">Windows上でHaskell Platformを完全削除する方法です。
LinuxやMac環境についてはネット上に多数情報がありますが、Windows環境についてはそれが見当たらなかったため、本エントリにまとめておきます。確認した環境はWindows 8.1＋Haslell Platform 2014.2.0.0です。


削除手順：
Windows環境では以下の手順でHaskell Platformを完全に削除できます。

Haskell Platformのアンインストール

[コントロールパネル] - [プログラム] - [プログラムと機能]を開く
"Haslell Platform 2014.2.0.0"を選択して[アンインストール]を実行

ユーザー領域に作成されたパッケージ関連ファイルの削除

手動（エクスプローラ、rmコマンドなど）で次の２つのディレクトリ以下を完全に削除</summary></entry></feed>
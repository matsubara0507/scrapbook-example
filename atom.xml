<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Sample Site Posts</title><id>https://matsubara0507.github.io/scrapbook-example/atom.xml</id><updated>2018-10-29T00:00:00Z</updated><link href="https://matsubara0507.github.io/scrapbook-example"/><entry><id>https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html</id><title type="text">Hacktoberfest 2018 なので PR を5つ以上出してみた</title><updated>2018-10-29T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-10-29-join-hacktoberfest-2018.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Hacktoberfest 2018 なので PR を5つ以上出してみた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-10-29" itemprop="datePublished"&gt;
        Oct 29, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;去年に引き続き，Hacktoberfest に参加しました． 2017 は PR を4つでしたが，2018 は5つになったようです．&lt;/p&gt;
&lt;p&gt;ちなみに Hacktoberfest がなんなのかや，参加方法については&lt;a href="https://matsubara0507.github.io/posts/2017-10-11-join-hacktoberfest-2017.html"&gt;過去記事&lt;/a&gt;を見てください（多分変わってなかったはず）．&lt;/p&gt;
&lt;h2 id="マイステータス"&gt;マイステータス&lt;/h2&gt;
&lt;p&gt;10月29日時点のステータスはこんな感じ．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/join-hacktoberfest-2018/status.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hacktoberfest.digitalocean.com/stats/matsubara0507"&gt;ここから見れる&lt;/a&gt;が，毎年同じリンクを使ってるっぽいので，2019年にこの記事を見にきた人は役に立たないリンクです(笑)&lt;/p&gt;
&lt;h2 id="出した-pr"&gt;出した PR&lt;/h2&gt;
&lt;p&gt;自分のリポジトリに対する PR もカウントされてしまうので，それを除くと4リポジトリ7PRです．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/10"&gt;haskell-jp/makeMistakesToLearnHaskell ＃10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/14"&gt;haskell-jp/makeMistakesToLearnHaskell ＃14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/16"&gt;haskell-jp/makeMistakesToLearnHaskell ＃16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell-jp/makeMistakesToLearnHaskell/pull/30"&gt;haskell-jp/makeMistakesToLearnHaskell ＃30&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stackage/pull/4078"&gt;commercialhaskell/stackage ＃4078&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Hacktoberfest-2018/Hello-world/pull/2483"&gt;Hacktoberfest-2018/Hello-world ＃2483&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/stackbuilders/dotenv-hs/pull/101"&gt;stackbuilders/dotenv-hs ＃101&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とはいえ，haskell-jp は僕が活動しているコミュニティだし，stackage は Haskell 版 Gem の登録申請みたいなものだし，Hacktoberfest-2018/Hello-world はただの遊びだし． ちゃんと OSS に出した PR は一つだ…&lt;/p&gt;
&lt;h3 id="haskell-jpmakemistakestolearnhaskell"&gt;haskell-jp/makeMistakesToLearnHaskell&lt;/h3&gt;
&lt;p&gt;このリポジトリは，2018/11/10 に開催予定の &lt;a href="https://haskell-jp.connpass.com/event/92617/"&gt;Haskell Day 2018&lt;/a&gt; の午前中で行われる予定のハンズオンで使うものです． &lt;a href="https://github.com/igrep"&gt;igrep&lt;/a&gt; 氏がメインで作っており，僕は CI を設定したり，Cabal から hpack に移行したり，コンテンツをいじるより環境周りをいじった．&lt;/p&gt;
&lt;h3 id="commercialhaskellstackage"&gt;commercialhaskell/stackage&lt;/h3&gt;
&lt;p&gt;このリポジトリは Haskell のパッケージマネージャーである &lt;a href="https://www.stackage.org/"&gt;Stackage&lt;/a&gt; の管理リポジトリだ． &lt;a href="http://hackage.haskell.org/"&gt;Hackage&lt;/a&gt; というのもあるが，Hackage はパッケージストレージで，Stackage は Hackage にある各パッケージのバージョンのリゾルバを提供している（ビルド可能な組み合わせのこと）． 他の言語と異なり，リゾルバがあることで Haskell アプリケーションの作者が常に各パッケージ間のバージョンなどを細かく管理する必要はなく，特定のリゾルバを設定するだけで良い．&lt;/p&gt;
&lt;p&gt;最近，Haskell のデファクトスタンダードなコンパイラ，GHC の最新バージョンである GHC 8.6 がリリースされた． それに伴い，Stackage の Nightly 版が GHC 8.6 へ移行され，多くのパッケージが disable された． 徐々にメジャーパッケージが reenable されたので，&lt;a href="http://hackage.haskell.org/package/servant-kotlin"&gt;僕の作成したパッケージ&lt;/a&gt;も reenable する PR を送ったのだ．&lt;/p&gt;
&lt;h3 id="hacktoberfest-2018hello-world"&gt;Hacktoberfest-2018/Hello-world&lt;/h3&gt;
&lt;p&gt;これは Hacktoberfest が作ったお遊びリポジトリだ（多分）． いろんな言語の &lt;code&gt;Hello, world!&lt;/code&gt; と出力するプログラムを集めるリポジトリのようだ．&lt;/p&gt;
&lt;p&gt;僕は &lt;a href="https://hacktoberfest.digitalocean.com/stats"&gt;Hacktoberfest のグローバルステータス&lt;/a&gt;の「Highest Pull Request Count Repos」で見かけた（今は read-only になっているので PR は出せない）． 面白そうだったので，まだ無かった &lt;a href="https://www.egison.org/"&gt;Egison&lt;/a&gt; のプログラムを PR として出した．&lt;/p&gt;
&lt;pre class="egison"&gt;&lt;code&gt;(define $main
  (lambda [$args]
    (write &amp;quot;Hello, world!\n&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Egison は江木さんという方が学生のころから作ってるパターンマッチ志向という独特のパラダイムを持つプログラミング言語だ． 全然関係ない話だが，今度&lt;a href="https://connpass.com/event/102061/"&gt;ワークショップ&lt;/a&gt;も行われる．&lt;/p&gt;
&lt;h3 id="stackbuildersdotenv-hs"&gt;stackbuilders/dotenv-hs&lt;/h3&gt;
&lt;p&gt;唯一のまともな OSS な PR． &lt;a href="http://hackage.haskell.org/package/dotenv"&gt;dotenv&lt;/a&gt; という Haskell パッケージのリポジトリだ． 自分が作ってる &lt;a href="https://github.com/matsubara0507/stack-tpls"&gt;CLI ツール&lt;/a&gt;に使おうと思って README に書いてある通りに書いて見たら，動かなかったので，その修正 PR を出した．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Configuration.Dotenv&lt;/span&gt; (loadFile, defaultConfig)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;loadFile defaultConfig&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;こう書くと &lt;code&gt;defaultConfig&lt;/code&gt; が無いと怒られる．&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;Main.hs:17:42: error:
    Module ‘Configuration.Dotenv’ does not export ‘defaultConfig’
   |                             
17 | import           Configuration.Dotenv   (defaultConfig, loadFile)
   |                                          ^^^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コードを見に行ったら &lt;code&gt;defaultConfig&lt;/code&gt; を Reexport し忘れていたので，Reexport し直す PR を出した． 無事マージされ，最新バージョンでリリースされたので，もし同じバグを踏んだ人がいた場合はバージョン &lt;code&gt;0.6.0.3&lt;/code&gt; 以上を試してほしい．&lt;/p&gt;
&lt;h2 id="t-shirt"&gt;T-shirt&lt;/h2&gt;
&lt;p&gt;去年と同様に「You’ve completed the Hacktoberfest challenge!」というメールが届いた（10/27に）． メール本文にあるユニークなリンクを踏んでTシャツのリクエストを出せる． Tシャツのサイズと，自分の住所などを英語で記載するだけだ．&lt;/p&gt;
&lt;p&gt;アメリカ以外はだいたいひと月ほどで届くらしい． ちなみに，去年は12月20日ぐらいに届いてた．&lt;/p&gt;
&lt;h3 id="おしまい"&gt;おしまい&lt;/h3&gt;
&lt;p&gt;あんまり OSS っぽい PR を出せなくて残念…&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html</id><title type="text">GHC 8.6 がインストールできなかった</title><updated>2018-10-28T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-10-28-ghc-8-6-error-no-gmp.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;GHC 8.6 がインストールできなかった&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-10-28" itemprop="datePublished"&gt;
        Oct 28, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;対したことではないんだけど，日本語の記事が無っかたのでメモ． ちなみに OS は macOS Sierra (10.12.6) です．&lt;/p&gt;
&lt;h2 id="ghc-8.6-でビルドできない"&gt;GHC 8.6 でビルドできない&lt;/h2&gt;
&lt;p&gt;現在 stackage の Nightly は最新の GHC バージョンである 8.6 がインストールされる． 結構パッケージも揃ってきたので，自分のパッケージもビルドしてみようかなと思って，resolver を Nightly に変えて &lt;code&gt;stack build&lt;/code&gt; したら下記のようなエラーが出た．&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
Downloaded nightly-2018-10-26 build plan.    
Preparing to install GHC to an isolated location.
This will not interfere with any system-level installation.
Downloaded ghc-8.6.1.                                      
Installing GHC ...                                                                         
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--vebose&lt;/code&gt; を付けて詳細を見てみる．&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build --verbose
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
2018-10-28 13:31:22.068195: [debug] Checking for project config at: /Users/username/git/haskell/servant-kotlin/stack.yaml
2018-10-28 13:31:22.069706: [debug] Loading project config file stack.yaml
 .
 .
 .
2018-10-28 13:32:21.355443: [debug] /Library/Developer/CommandLineTools/usr/bin/ranlib: file: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1/rts/libHSrts_thr_p.a(Select.thr_p_o) has no symbols
2018-10-28 13:32:21.621133: [debug] &amp;quot;utils/ghc-cabal/dist-install/build/tmp/ghc-cabal-bindist&amp;quot; copy libraries/ghc-prim dist-install &amp;quot;strip&amp;quot; &amp;#39;&amp;#39; &amp;#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1&amp;#39; &amp;#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/lib/ghc-8.6.1&amp;#39; &amp;#39;/Users/username/.stack/programs/x86_64-osx/ghc-8.6.1/share/doc/ghc-8.6.1/html/libraries&amp;#39; &amp;#39;v p dyn&amp;#39;  
2018-10-28 13:32:21.841900: [debug] dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib
2018-10-28 13:32:21.842003: [debug]   Referenced from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/libraries/base/dist-install/build/libHSbase-4.12.0.0-ghc8.6.1.dylib
2018-10-28 13:32:21.842062: [debug]   Reason: image not found
2018-10-28 13:32:21.842273: [debug] make[1]: *** [install_packages] Abort trap: 6
2018-10-28 13:32:21.844303: [debug] make: *** [install] Error 2
Installing GHC ...
Received ExitFailure 2 when running
Raw command: /usr/bin/make install
Run from: /Users/username/.stack/programs/x86_64-osx/ghc-8.6.1.temp/ghc-8.6.1/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;どうやら &lt;code&gt;/usr/local/opt/gmp/lib/libgmp.10.dylib&lt;/code&gt; が無いみたいだ．&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
ls: /usr/local/opt/gmp/lib/libgmp.10.dylib: No such file or directory&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで検索すると，Ruby に関することだが &lt;a href="https://stackoverflow.com/questions/34912946"&gt;StackOverflow があった&lt;/a&gt;． 曰く，&lt;code&gt;gmp&lt;/code&gt; パッケージを入れれば良いらしい（多くの人は他のどこかのタイミングで入ってるのかも）．&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ brew reinstall gmp
==&amp;gt; Reinstalling gmp
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/gmp-6.1.2_2.sierra.bottle.tar.gz
######################################################################## 100.0%
==&amp;gt; Pouring gmp-6.1.2_2.sierra.bottle.tar.gz
🍺  /usr/local/Cellar/gmp/6.1.2_2: 18 files, 3.1MB

$ ls /usr/local/opt/gmp/lib/libgmp.10.dylib
/usr/local/opt/gmp/lib/libgmp.10.dylib&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで GHC 8.6 で &lt;code&gt;stack build&lt;/code&gt; できるようになった．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;まぁ一応ね，一応メモした．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/10-22-stack-191.html</id><title type="text">Stack 1.9.1 がリリースされました。</title><updated>2018-10-22T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/10-22-stack-191.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;10月18日に Stack version 1.9.1 が&lt;a href="https://github.com/commercialhaskell/stack/blob/v1.9.1/ChangeLog.md#v191"&gt;リリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;更新は &lt;code&gt;stack upgrade&lt;/code&gt; コマンドを実行します。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack upgrade
Current Stack version: 1.7.1, available download version: 1.9.1
Newer version detected, downloading
Querying for archive location for platform: linux-x86_64-static
Downloading from: https://github.com/commercialhaskell/stack/releases/download/v1.9.1/stack-1.9.1-linux-x86_64-static.tar.gz
Download complete, testing executable
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
New stack executable available at /home/guchi/.local/bin/stack
Also copying stack executable to /usr/local/bin/stack
Permission error when trying to copy: /usr/local/bin: copyFile:atomicCopyFileContents:withReplacementFile:openBinaryTempFile: permission denied (Permission denied)
Should I try to perform the file copy using sudo? This may fail
Try using sudo? (y/n)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行ファイルは &lt;code&gt;~/.local/bin/stack&lt;/code&gt; と &lt;code&gt;/usr/local/bin&lt;/code&gt; にインストールされます。&lt;/p&gt;
&lt;p&gt;ただし、権限が無いと上記のように &lt;code&gt;/usr/local/bin&lt;/code&gt; へのコピーに失敗するため &lt;code&gt;sudo&lt;/code&gt; で再実行するか聞かれます。必要であれば &lt;code&gt;y&lt;/code&gt; でインストールしましょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;Try using sudo? (y/n) y
Going to run the following commands:

-  sudo cp /home/guchi/.local/bin/stack /usr/local/bin/stack.tmp
-  sudo mv /usr/local/bin/stack.tmp /usr/local/bin/stack

sudo file copy worked!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールされるバージョンは以下の通りです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack --version
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;気になる更新内容まとめ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static binary の復活&lt;/li&gt;
&lt;li&gt;Cabal 2.4 への対応&lt;/li&gt;
&lt;li&gt;internal-library 関連のバグ修正&lt;/li&gt;
&lt;li&gt;namespaced template&lt;/li&gt;
&lt;li&gt;stack run&lt;/li&gt;
&lt;li&gt;ghci に -fobject-code を渡した際にちゃんとキャッシュされるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id="changelog-翻訳"&gt;Changelog (翻訳)&lt;/h2&gt;
&lt;h3 id="リリースノート"&gt;リリースノート&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nh2"&gt;@nh2&lt;/a&gt;さんのおかげで、静的にリンクされた Linux バイナリが再び利用できるようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/blob/c34f11190302b2db9bab44ac6e45ca2c5f7810ce/doc/maintainers/releases.md#build-linux-static-binary-distribution-with-nix"&gt;Build Linux static binary distribution with Nix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/nh2/static-haskell-nix/tree/upstream-nixpkgs-musl-1.1.19/static-stack"&gt;Fully statically linked stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;download.fpcomplete.com&lt;/code&gt; から Ubuntu, Debian, CentOS, Fedora, Arch のパッケージリポジトリを削除する予定です。これらは既に1年以上前から非推奨となっており、新しいリリースにも対応していませんでしたが、過去のスクリプトとの互換性のために残していました。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="大きな変更点"&gt;大きな変更点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Cabal 2.4 にアップグレードしました。
&lt;ul&gt;
&lt;li&gt;注意点: ファイル名のパターンマッチの動作が変わりました。Cabal spec 2.4 より前のバージョンでは &lt;code&gt;*.txt&lt;/code&gt; は &lt;code&gt;foo.txt&lt;/code&gt; にマッチしていましたが、&lt;code&gt;foo.2.txt&lt;/code&gt; にはマッチしませんでした。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4317"&gt;Use Cabal 2.4 for the 1.9 branch #4317&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/cabal/blob/master/Cabal/ChangeLog.md#2400-mikhail-glushenkov-september-2018"&gt;ChangeLog (Cabal 2.4)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/cabal/pull/5372"&gt;Multi-dot globbing #5372&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/cabal/issues/784"&gt;Wildcards in data-files don’t work with filenames containing multiple dots #784&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haskell/cabal/issues/5057"&gt;&lt;code&gt;cabal sdist&lt;/code&gt; does not pick up files with multiple dots #5057&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GHCJS&lt;/code&gt; のサポートが &lt;code&gt;experimental (実験的)&lt;/code&gt; へ降格しました。また、&lt;code&gt;GHCJS&lt;/code&gt; が実験段階であることをユーザに知らせるための警告が表示されるようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4086"&gt;DISCUSSION: Mark GHCJS support as deprecated? #4086&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4154"&gt;Warning about GHCJS use when constructing a build plan #4154&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/commit/729a052cede11855644bf00c4b7661a89148bdc7#diff-e705c8fadf1193ab59443a5e6c8cbe8b"&gt;commit@729a052cede11855644bf00c4b7661a89148bdc7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="変更点"&gt;変更点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;ghc-options&lt;/code&gt; と &lt;code&gt;config.yaml&lt;/code&gt; の &lt;code&gt;ghc-options&lt;/code&gt; を結合するようにしました。今までは置き換えていました。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="解説"&gt;解説&lt;/h4&gt;
&lt;p&gt;グローバルな &lt;code&gt;~/.stack/.config.yaml&lt;/code&gt; とプロジェクト固有の &lt;code&gt;stack.yaml&lt;/code&gt; の話で &lt;code&gt;package.yaml&lt;/code&gt; は関係しません。&lt;/p&gt;
&lt;p&gt;例として、それぞれファイルの内容を以下のように設定しておきます。(&lt;code&gt;$everything&lt;/code&gt; は全てのパッケージを指定)&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="co"&gt;# ~/.stack/config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;span class="fu"&gt;ghc-options:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;  &lt;span class="fu"&gt;&amp;quot;$everything&amp;quot;:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="co"&gt;# stack.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-12.13&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;&lt;span class="fu"&gt;ghc-options:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;  &lt;span class="fu"&gt;&amp;quot;$everything&amp;quot;:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;bbb&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;パッケージの指定が重複していたときに今までは、&lt;code&gt;stack.yaml&lt;/code&gt; (プロジェクト固有) の &lt;code&gt;ghc-options&lt;/code&gt; で上書きされていましたが、 &lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;ghc-options&lt;/code&gt; を結合するようになりました。以下は動作例です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;# stack v1.9.1 の動作
$ stack build
... --ghc-options aaa --ghc-options bbb

# stack v1.7.1 の動作
$ stack build
... --ghc-options bbb&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ghc-options&lt;/code&gt; の内容が重複する場合は両方とも引数に与えられますが、後ろの値で上書きされるようなのでプロジェクト固有の設定が優先されます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="co"&gt;# ~/.stack/config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;&lt;span class="fu"&gt;ghc-options:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;  &lt;span class="fu"&gt;&amp;quot;$everything&amp;quot;:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;-dumpdir=./respect-config&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="co"&gt;# stack.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-12.13&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;&lt;span class="fu"&gt;ghc-options:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" title="6"&gt;  &lt;span class="fu"&gt;&amp;quot;$everything&amp;quot;:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;-dumpdir=./respect-stack&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実際に試してみると、以下のようになると思います。&lt;/p&gt;
&lt;pre class="sell"&gt;&lt;code&gt;$ stack build -v
... --ghc-options -dumpdir=./respect-config --ghc-options -dumpdir=./respect-stack

$ ls  -l
...
drwxrwxr-x 5 guchi guchi 4096 10月 21 13:35 respect-stack
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3753"&gt;Stack does not respect ghc-options in user config #3753&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3781"&gt;Fix inheritance of category ghc-options from config.yaml #3753 #3781&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4089"&gt;Have project ghc-options append to config.yaml ghc-options #3753&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; コマンドはパッケージのサブライブラリをビルドする際に executables, test, benchmarks, libraries などと同様の方法でアナウンスを行うようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4111"&gt;Consistent handling of internal libraries #4111&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4111/commits/4a4b63f59130bb66477d155dcb401d50fac02fab"&gt;commit@4a4b63f59130bb66477d155dcb401d50fac02fab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack sdist&lt;/code&gt; コマンドはサニティチェックの結果にかかわらず、生成された tarball の場所をアナウンスするようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4117"&gt;Mention tarball earlier in sdist #4117&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4112"&gt;stack sdist fails when modules are exposed based on a flag in the cabal file #4112&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack setup&lt;/code&gt; コマンドの &lt;code&gt;--upgrade-cabal&lt;/code&gt; オプションは廃止されます。この機能は GHC 8.2 以降では動作しません。また、このフラグが実装された当初の動機は Stack がカスタムセットアップのためにスナップショットの &lt;code&gt;Cabal&lt;/code&gt; ライブラリを利用し始めたことでほとんど無くなりました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4070"&gt;#4070&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4118"&gt;Deprecate the –upgrade-cabal flag (fixes #4070) #4118&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4070"&gt;&lt;code&gt;stack setup --upgrade-cabal&lt;/code&gt; doesn’t work for Cabal-2.2.0.1 + ghc-8.2.2 #4070&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;新たに namespaced template 機能が実装されたため、&lt;code&gt;stack templates&lt;/code&gt; コマンドは利用可能な全てのテンプレートの一覧を良い感じに表示できなくなりました。代わりに、テンプレートを見つける方法についての&lt;a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md"&gt;ヘルプファイル&lt;/a&gt;をダウンロードし、表示します。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4039"&gt;#4039&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4129"&gt;Get stack templates help from Github file #4039 #4129&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md"&gt;help file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;ビルドツールを &lt;code&gt;cabal-install&lt;/code&gt; と同様の方法で取り扱うようになりました。また、レガシーな &lt;code&gt;build-tools&lt;/code&gt; フィールドに対しては、ツールマップの中からビルドツールパッケージを調べるのではなく、ハードコードされたビルドツールのリストを利用します。この変更により Stack の動作は &lt;code&gt;cabal-install&lt;/code&gt; に近づいたため、いくつかのバグを回避し、最適化/遅延性の恩恵を得られる可能性があります。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4125"&gt;#4125&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4125"&gt;stack 1.7.1 still has problems finding build tools (“The program ‘happy’ is required”) #4125&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4132"&gt;Use a hard-coded tool dependency map (fixes #4125) #4132&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/595"&gt;Build-tools not detected when not using Stackage snapshot #595&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3178"&gt;Stack cannot find happy during build #3178&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3249"&gt;Extensible snapshots #3249&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;パフォーマンスの低下を避けるため、Mustache テンプレートに (50kb を超える) 大きなファイルを適用できなくなりました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4133"&gt;#4133&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4134"&gt;Do not apply Mustache to large files (fixes #4133) #4134&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4133"&gt;stack new is very slow at compiling Mustache templates #4133&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack upload&lt;/code&gt; はデフォルトでパッケージに署名を行うようになりました。また、&lt;code&gt;--no-signature&lt;/code&gt; オプションで署名をスキップできます。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;#3739&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;stack upload –no-signature still shows “Unable to find gpg2 or gpg executable” #3739&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4167"&gt;Fix behavior of –no-signature to turn signing off #4167&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;テンプレートダウンロード時のネットワーク接続問題に備えて、事前にチェックを行うようになりました。もし、問題があればキャッシュ済みのテンプレートを利用します。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3850"&gt;stack new requires network to work #3850&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3850"&gt;stack new requires network to work #3850&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4173"&gt;Use cached template if template download fails #4173&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="その他の改良点"&gt;その他の改良点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Windows 10 より前の Windows 環境では、ターミナルのデフォルト値が &lt;code&gt;--color=never&lt;/code&gt; となります。エミュレーションによる出力のみ ANSI カラーコードが利用できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4106"&gt;Re #4091: Pre-Windows 10, default –color=never #4106&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Windows 環境では、デフォルトのターミナルを ‘mintty’ (false) として認識するように変更しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4015"&gt;Windows: use ‘hIsTerminalDevice or isMinTTYHandle’ #4015&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; コマンドは &lt;code&gt;stack.yaml&lt;/code&gt; の &lt;code&gt;extra-deps&lt;/code&gt; に &lt;code&gt;base&lt;/code&gt; が明示的に記載されているとき、警告を出すようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3993"&gt;Help users not to go down the road of base upgrade/downgrade, addresses #3940 #3993&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3940"&gt;Warn when upgrading base #3940&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; コマンドは、ビルドプランで達成不可能な &lt;code&gt;base&lt;/code&gt; バージョンが要求された際に、別の GHC バージョンを試すように提案するようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3993"&gt;Help users not to go down the road of base upgrade/downgrade, addresses #3940 #3993&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;新たなサブコマンド &lt;code&gt;run&lt;/code&gt; が導入されました。このコマンドは &lt;code&gt;cabal run&lt;/code&gt; のように、指定された executable をビルド&amp;amp;実行します。executable が省略された場合は、プロジェクト内で最初に利用可能な executable が指定されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3952"&gt;Introduce &lt;code&gt;stack run&lt;/code&gt; command line option #3952&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/233"&gt;Wishlist: &lt;code&gt;stack run&lt;/code&gt; #233&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html"&gt;stack run コマンド – BIGMOON Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; コマンドは、依存関係が足りない旨を伝えるメッセージにパッケージの最新の cabal ファイルリビジョンハッシュを含めるようになりました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/pull/4068"&gt;#4068&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="解説-1"&gt;解説&lt;/h4&gt;
&lt;p&gt;こんな感じで表示されるようです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;...
  * Recommended action: try adding the following to your extra-deps in /home/thomas/github/stack/stack.yaml:
rio-0.1.2.0@sha256:cb2a65cee1c0450815002ca890633215e4544b5c1c9f7091a950142c6efe8f3f&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4068"&gt;Add cabal-hash revision info when displaying recommended packages when failing to construct buildplan #4068&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3925"&gt;Modify “recommended packages” output to include revision info #3925&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack sdist&lt;/code&gt; コマンドに新しく &lt;code&gt;--tar-dir&lt;/code&gt; オプションを追加しました。このオプションにより指定したディレクトリに生成された tarball をコピーできるようになります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3621"&gt;3568 add tar files option to sdist #3621&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3568"&gt;Stack sdist option to place build artefacts elsewhere #3568&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/commit/9a58d5bf5346bedb0d460335c7018c256591966d"&gt;commit@9a58d5bf5346bedb0d460335c7018c256591966d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--interleaved-output&lt;/code&gt; オプションと &lt;code&gt;build.interleaved-output&lt;/code&gt; 設定値が導入されました。これにより、複数の並行ビルドの出力が &lt;code&gt;packagename&amp;gt;&lt;/code&gt; プレフィックス付きで同時に標準エラー出力にダンプされます。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3225"&gt;#3225&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4097"&gt;Add the interleaved-output option/config value #3225 #4097&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3225"&gt;Add flag to print GHC output to stdout #3225&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3508"&gt;Report progress on STDOUT/STDERR during compilation of individual modules #3508&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトの再接続戦略を exponential backoff に変更しました。これにより &lt;a href="https://github.com/commercialhaskell/stack/issues/3510"&gt;#3510&lt;/a&gt; の問題が緩和されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4109"&gt;Changed the default retry strategy #4109&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3510"&gt;Stack does not retry effectively when S3 is being flaky. #3510&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.14/retry-0.7.7.0/Control-Retry.html#v:exponentialBackoff"&gt;exponentialBackoff&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack new&lt;/code&gt; コマンドは &lt;code&gt;username/foo&lt;/code&gt; という形式で、&lt;code&gt;commercialstack&lt;/code&gt; 以外のリポジトリからテンプレートをダウンロードできるようになりました。また &lt;code&gt;github:&lt;/code&gt; という形式でプレフィックスを付けることでサービスを指定することもできます。現状は &lt;code&gt;github:&lt;/code&gt; の他に &lt;code&gt;gitlab:&lt;/code&gt; と &lt;code&gt;bitbucket:&lt;/code&gt; が利用可能です。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4103"&gt;4039 namespaced templates #4103&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4039"&gt;Namespaced templates #4039&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html"&gt;namespaced templates - BIGMOON Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gitrev&lt;/code&gt; から &lt;code&gt;githash&lt;/code&gt; に切り替えました。このパッケージには &lt;code&gt;gitrev&lt;/code&gt; にマージされていないバグフィックスが含まれています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4130"&gt;Switch to githash to include some unmerged bugfixes in gitrev #4130&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'allow-newer': true&lt;/code&gt; を追加するファイルがわかりづらいため、ユーザ設定ファイルへのパスをエラーメッセージに含めるようにしました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3685"&gt;#3685&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3685"&gt;allow-newer in global-project doesn’t work #3685&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4127"&gt;Point to user’s config.yaml when advising ‘allow-newer: true’ #4127&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; コマンドはビルド後ではなく、ビルド前にどのメインターゲットを読み込むか質問するようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4138"&gt;‘stack ghci’ now asks which main module to load before building #4138&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;hpack のバージョンを 0.29.0 に更新しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4151"&gt;Bump to hpack 0.29 #4151&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;GHC 8.4 以降のバージョンを利用したとき、自動的に Haddock へ &lt;code&gt;--quickjump&lt;/code&gt; オプションが渡されるようになります。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4163"&gt;Pass –quickjump to Haddock for GHC 8.4 and later #4163&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;hackage-base-url&lt;/code&gt; 設定オプションを利用することで、パッケージアップロード時の Hackage ベースURL に任意のURLを指定できるようになりました。(デフォルトは &lt;code&gt;https://hackage.haskell.org/&lt;/code&gt; です)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4167"&gt;Fix behavior of –no-signature to turn signing off #4167&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;stack upload –no-signature still shows “Unable to find gpg2 or gpg executable” #3739&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Nix 利用時に GHC のマイナーバージョンを省略した場合、メジャーブランチの最新のマイナーバージョンを自動的に利用するようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4189"&gt;Do not hardcode GHC versions for Nixpkgs #4189&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="バグフィックス"&gt;バグフィックス&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; を繰り返し実行したときに &lt;code&gt;.o&lt;/code&gt; ファイルを無効化しなくなりました。これにより、&lt;code&gt;-fobject-code&lt;/code&gt; でコンパイルされた全てのモジュールは ghci を実行する度にキャッシュされます。 詳細: &lt;a href="https://github.com/commercialhaskell/stack/pull/4038"&gt;#4038&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4038"&gt;Set cabal_macros.h work directory in stack ghci to something non-temporary #4038&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3344"&gt;stack ghci recompiles all modules on every startup, even when invoked with “-fobject-code” or “–no-build” #3344&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~/.stack/config.yaml&lt;/code&gt; と &lt;code&gt;stack.yaml&lt;/code&gt; の最後に改行が追加されました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3983"&gt;fixed: terminating is newline #3983&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;前回のリリースで &lt;code&gt;ghc-pkg&lt;/code&gt; コマンドの出力が &lt;code&gt;stderr&lt;/code&gt; に出力されてしまう問題が再発したので修正しました。現在の出力はとても静かになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4028"&gt;Make ghc-pkg calls less noisy #4028&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v1.7.1&lt;/code&gt; で導入された再コンパイルチェックの問題を修正し、回帰テストを追加しました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4001"&gt;#4001&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4003"&gt;4001 excess recompilation #4003&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4001"&gt;–file-watch is watching test suites again #4001&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; は internal library を含むパッケージの処理で internal libray に対応する間違ったパッケージを探し、モジュールの読み込みに失敗していました。この問題は現在修正済みで、ライブラリとサブライブラリが適切に追跡されるようにコードが変更されました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3926"&gt;#3926&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3926"&gt;&lt;code&gt;stack ghci&lt;/code&gt; does not recognise internal libraries #3926&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/3982"&gt;Handle internal libraries in GHCi. #3982&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;internal library に依存していないパッケージを &lt;code&gt;stack build&lt;/code&gt; すると、internal library をビルドしていないのにも関わらず登録しようとするため、ビルドに失敗していました。この問題は internal library を常にビルドすることで解決しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4033"&gt;Handle internal libs not listed as dependencies #4033&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3996"&gt;Build fails with internal libraries that aren’t dependencies #3996&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;NixOS 環境では &lt;code&gt;--no-nix&lt;/code&gt; オプションの影響を受けなくなりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4021"&gt;Allow Nix mode to be disabled under NixOS #4021&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4002"&gt;stack does not honor –no-nix under NixOS #4002&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;RAM を大量に消費してしまう問題が再発していたので修正しました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4027"&gt;#4027&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4027"&gt;Regression in 1.7.1 (compared to 1.6.5) in getPackageFiles RAM usage #4027&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4066"&gt;Fix RAM usage upon big dump-hi files parsing #4066&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;コマンドラインの引数の順序によって動作が異なる問題を修正しました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3959"&gt;#3959&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3959"&gt;It should not matter if flags given before command or after #3959&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4067"&gt;Change parsers to use &lt;code&gt;flag'&lt;/code&gt; instead of &lt;code&gt;switch&lt;/code&gt; #4067&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;パッケージをアップロードする際の Hackage クレデンシャル保存プロンプトで、ユーザの入力前に表示されなければならないメッセージが入力後に表示されてしまっていた問題を修正しました。ghci のターゲット選択プロンプトでも同様の問題が発生していたので修正しました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4063"&gt;Flush after prompt #4063&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4162"&gt;Stack Upload waits for confirmation BEFORE printing confirmation message #4162&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack solver&lt;/code&gt; コマンドで、PATH に &lt;code&gt;cabal&lt;/code&gt; が存在しない場合、ユーザに対して &lt;code&gt;stack install cabal-install&lt;/code&gt; の実行を促すためのメッセージが表示されるようになりました。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4100"&gt;Solver cabal install hint #4100&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3841"&gt;stack solver complains there’s no cabal in path. #3841&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; コマンドはサブライブラリを含むパッケージが executable, test, benchmark などの依存関係になっている場合でも、正しくビルドできるようになりました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3787"&gt;#3787&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="解説-2"&gt;解説&lt;/h4&gt;
&lt;p&gt;Cabal 2.0 から &lt;code&gt;internal Libraries&lt;/code&gt; が追加され、stack 側も対応したという感じです。&lt;/p&gt;
&lt;p&gt;例として以下のような &lt;code&gt;package.yaml&lt;/code&gt; があった場合&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;&lt;span class="co"&gt;# package.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;&lt;span class="fu"&gt;name:&lt;/span&gt;&lt;span class="at"&gt; test-internal&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" title="3"&gt;&lt;span class="fu"&gt;dependencies:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" title="4"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; base&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" title="5"&gt;&lt;span class="fu"&gt;internal-libraries:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" title="6"&gt;  &lt;span class="fu"&gt;internal-foo:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;{}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自動生成される &lt;code&gt;cabal&lt;/code&gt; ファイルは以下のようになります。&lt;/p&gt;
&lt;pre class="cabal"&gt;&lt;code&gt;name:           test-internal
version:        0.0.0
build-type:     Simple
cabal-version:  &amp;gt;= 2.0

library internal-foo
  other-modules:
      Paths_test_internal
  build-depends:
      base
  default-language: Haskell2010&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この状態でビルドした結果は次のとおりです。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;# v1.7.1
$ stack build
Package has buildable sublibraries but no buildable libraries, I&amp;#39;m giving up
CallStack (from HasCallStack):
  error, called at src/Stack/Package.hs:280:30 in stack-1.7.1-JqFYW3fz7If7um4NzPRwPj:Stack.Package

# v1.9.1
$ stack build
test-internal-0.0.0: configure (internal-lib)
Configuring test-internal-0.0.0...
test-internal-0.0.0: build (internal-lib)
Preprocessing library &amp;#39;internal-foo&amp;#39; for test-internal-0.0.0..
Building library &amp;#39;internal-foo&amp;#39; for test-internal-0.0.0..
[1 of 1] Compiling Paths_test_internal ( .stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build/internal-foo/autogen/Paths_test_internal.hs, .stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build/internal-foo/Paths_test_internal.o )
ignoring (possibly broken) abi-depends field for packages
test-internal-0.0.0: copy/register
Installing internal library internal-foo in /home/guchi/Desktop/stack-191-working/test-internal/.stack-work/install/x86_64-linux/lts-12.14/8.4.3/lib/x86_64-linux-ghc-8.4.3/test-internal-0.0.0-6jijyMwb8IH16YEILzaUQW-internal-foo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4111"&gt;Consistent handling of internal libraries #4111&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3787"&gt;Internal libraries does not work if there’s no main library #3787&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.haskell.org/cabal/users-guide/developing-packages.html#sublibs"&gt;Internal Libraries - Cabal document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sol/hpack#library-fields"&gt;hpack Top-level fields&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;internal library に依存したテストスイートのカバレッジレポートで、サブライブラリが適切に処理されるようになりました。以前まではカバレッジレポートを生成するときにエラーとなっていました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4105"&gt;#4105&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4111"&gt;Consistent handling of internal libraries #4111&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4105"&gt;Error running test coverage when tests depend on internal lbraries. #4105&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;スナップショット更新時にサブライブラリがプリコンパイルキャシュに追加されるようになりました。以前まではスナップショットにサブライブラリを含むパッケージが存在するようなスナップショットを更新するとビルドが壊れていました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/4071"&gt;#4071&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4111"&gt;Consistent handling of internal libraries #4111&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/4071"&gt;haddock-library’s internal attoparsec library cannot be found - broken package #4071&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Stack は &lt;code&gt;warning&lt;/code&gt; の代わりに適切な &lt;code&gt;error&lt;/code&gt; ログレベルでエラーメッセージをプリティプリントするようになりました。これにより self-executing scripts で runhaskell のプラン構築エラーがターミナルに出力されない問題も修正されます。詳細: &lt;a href="https://github.com/commercialhaskell/stack/pull/4114"&gt;#4114&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4114"&gt;Fixes self-executing scripts not piping plan construction errors from runhaskell to terminal, issue #3942 #4114&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3942"&gt;Self-executing scripts don’t pipe plan construction errors from runhaskell to terminal #3942&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;Cabal の呼び出しに失敗した際に “While building Setup.hs” という間違ったメッセージが表示されていた問題を修正しました。詳細: &lt;a href="https://github.com/commercialhaskell/stack/issues/3934"&gt;#3934&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考リンク&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/pull/4131"&gt;Fix invalid “While building Setup.hs” #3934 #4131&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/issues/3934"&gt;Invalid “While building Setup.hs” error message #3934&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="changelog-オリジナル"&gt;Changelog (オリジナル)&lt;/h2&gt;
&lt;h3 id="release-notes"&gt;Release notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Statically linked Linux bindists are back again, thanks to &lt;a href="https://github.com/nh2"&gt;@nh2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We will be deleting the Ubuntu, Debian, CentOS, Fedora, and Arch package repos from &lt;code&gt;download.fpcomplete.com&lt;/code&gt; soon. These have been deprecated for over a year and have not received new releases, but were left in place for compatibility with older scripts.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="major-changes"&gt;Major changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Upgrade to Cabal 2.4
&lt;ul&gt;
&lt;li&gt;Note that, in this process, the behavior of file globbing has been modified to match that of Cabal. In particular, this means that for Cabal spec versions less than 2.4, &lt;code&gt;*.txt&lt;/code&gt; will match &lt;code&gt;foo.txt&lt;/code&gt;, but not &lt;code&gt;foo.2.txt&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GHCJS&lt;/code&gt; support is being downgraded to ‘experimental’. A warning notifying the user of the experimental status of &lt;code&gt;GHCJS&lt;/code&gt; will be displayed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="behavior-changes"&gt;Behavior changes:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ghc-options&lt;/code&gt; from &lt;code&gt;stack.yaml&lt;/code&gt; are now appended to &lt;code&gt;ghc-options&lt;/code&gt; from &lt;code&gt;config.yaml&lt;/code&gt;, whereas before they would be replaced.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; will now announce when sublibraries of a package are being build, in the same way executables, tests, benchmarks and libraries are announced&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack sdist&lt;/code&gt; will now announce the destination of the generated tarball, regardless of whether or not it passed the sanity checks&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;--upgrade-cabal&lt;/code&gt; option to &lt;code&gt;stack setup&lt;/code&gt; has been deprecated. This feature no longer works with GHC 8.2 and later. Furthermore, the reason for this flag originally being implemented was drastically lessened once Stack started using the snapshot’s &lt;code&gt;Cabal&lt;/code&gt; library for custom setups. See: &lt;a href="https://github.com/commercialhaskell/stack/issues/4070"&gt;#4070&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;With the new namespaced template feature, &lt;code&gt;stack templates&lt;/code&gt; is no longer able to meaningfully display a list of all templates available. Instead, the command will download and display a &lt;a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md"&gt;help file&lt;/a&gt; with more information on how to discover templates. See: &lt;a href="https://github.com/commercialhaskell/stack/issues/4039"&gt;#4039&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Build tools are now handled in a similar way to &lt;code&gt;cabal-install&lt;/code&gt;. In particular, for legacy &lt;code&gt;build-tools&lt;/code&gt; fields, we use a hard-coded list of build tools in place of looking up build tool packages in a tool map. This both brings Stack’s behavior closer into line with &lt;code&gt;cabal-install&lt;/code&gt;, avoids some bugs, and opens up some possible optimizations/laziness. See: &lt;a href="https://github.com/commercialhaskell/stack/issues/4125"&gt;#4125&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Mustache templating is not applied to large files (over 50kb) to avoid performance degredation. See: &lt;a href="https://github.com/commercialhaskell/stack/issues/4133"&gt;#4133&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack upload&lt;/code&gt; signs the package by default, as documented. &lt;code&gt;--no-signature&lt;/code&gt; turns the signing off. &lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;#3739&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;In case there is a network connectivity issue while trying to download a template, stack will check whether that template had been downloaded before. In that case, the cached version will be used. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;#3850&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="other-enhancements"&gt;Other enhancements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;On Windows before Windows 10, –color=never is the default on terminals that can support ANSI color codes in output only by emulation&lt;/li&gt;
&lt;li&gt;On Windows, recognise a ‘mintty’ (false) terminal as a terminal, by default&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; issues a warning when &lt;code&gt;base&lt;/code&gt; is explicitly listed in &lt;code&gt;extra-deps&lt;/code&gt; of &lt;code&gt;stack.yaml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; suggests trying another GHC version should the build plan end up requiring unattainable &lt;code&gt;base&lt;/code&gt; version.&lt;/li&gt;
&lt;li&gt;A new sub command &lt;code&gt;run&lt;/code&gt; has been introduced to build and run a specified executable similar to &lt;code&gt;cabal run&lt;/code&gt;. If no executable is provided as the first argument, it defaults to the first available executable in the project.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; missing dependency suggestions (on failure to construct a valid build plan because of missing deps) are now printed with their latest cabal file revision hash. See &lt;a href="https://github.com/commercialhaskell/stack/pull/4068"&gt;#4068&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Added new &lt;code&gt;--tar-dir&lt;/code&gt; option to &lt;code&gt;stack sdist&lt;/code&gt;, that allows to copy the resulting tarball to the specified directory.&lt;/li&gt;
&lt;li&gt;Introduced the &lt;code&gt;--interleaved-output&lt;/code&gt; command line option and &lt;code&gt;build.interleaved-output&lt;/code&gt; config value which causes multiple concurrent builds to dump to stderr at the same time with a &lt;code&gt;packagename&amp;gt;&lt;/code&gt; prefix. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3225"&gt;#3225&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The default retry strategy has changed to exponential backoff. This should help with &lt;a href="https://github.com/commercialhaskell/stack/issues/3510"&gt;#3510&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack new&lt;/code&gt; now allows template names of the form &lt;code&gt;username/foo&lt;/code&gt; to download from a user other than &lt;code&gt;commercialstack&lt;/code&gt; on Github, and can be prefixed with the service &lt;code&gt;github:&lt;/code&gt;, &lt;code&gt;gitlab:&lt;/code&gt;, or &lt;code&gt;bitbucket:&lt;/code&gt;. &lt;a href="https://github.com/commercialhaskell/stack/issues/4039"&gt;#4039&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Switch to &lt;code&gt;githash&lt;/code&gt; to include some unmerged bugfixes in &lt;code&gt;gitrev&lt;/code&gt; Suggestion to add &lt;code&gt;'allow-newer': true&lt;/code&gt; now shows path to user config file where this flag should be put into &lt;a href="https://github.com/commercialhaskell/stack/issues/3685"&gt;#3685&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now asks which main target to load before doing the build, rather than after&lt;/li&gt;
&lt;li&gt;Bump to hpack 0.29.0&lt;/li&gt;
&lt;li&gt;With GHC 8.4 and later, Haddock is given the &lt;code&gt;--quickjump&lt;/code&gt; flag.&lt;/li&gt;
&lt;li&gt;It is possible to specify the Hackage base URL to upload packages to, instead of the default of &lt;code&gt;https://hackage.haskell.org/&lt;/code&gt;, by using &lt;code&gt;hackage-base-url&lt;/code&gt; configuration option.&lt;/li&gt;
&lt;li&gt;When using Nix, if a specific minor version of GHC is not requested, the latest minor version in the given major branch will be used automatically.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bug-fixes"&gt;Bug fixes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; now does not invalidate &lt;code&gt;.o&lt;/code&gt; files on repeated runs, meaning any modules compiled with &lt;code&gt;-fobject-code&lt;/code&gt; will be cached between ghci runs. See &lt;a href="https://github.com/commercialhaskell/stack/pull/4038"&gt;#4038&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.stack/config.yaml&lt;/code&gt; and &lt;code&gt;stack.yaml&lt;/code&gt; terminating by newline&lt;/li&gt;
&lt;li&gt;The previous released caused a regression where some &lt;code&gt;stderr&lt;/code&gt; from the &lt;code&gt;ghc-pkg&lt;/code&gt; command showed up in the terminal. This output is now silenced.&lt;/li&gt;
&lt;li&gt;A regression in recompilation checking introduced in v1.7.1 has been fixed. See &lt;a href="https://github.com/commercialhaskell/stack/issues/4001"&gt;#4001&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack ghci&lt;/code&gt; on a package with internal libraries was erroneously looking for a wrong package corresponding to the internal library and failing to load any module. This has been fixed now and changes to the code in the library and the sublibrary are properly tracked. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3926"&gt;#3926&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For packages with internal libraries not depended upon, &lt;code&gt;stack build&lt;/code&gt; used to fail the build process since the internal library was not built but it was tried to be registered. This is now fixed by always building internal libraries. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3996"&gt;#3996&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-nix&lt;/code&gt; was not respected under NixOS&lt;/li&gt;
&lt;li&gt;Fix a regression which might use a lot of RAM. See &lt;a href="https://github.com/commercialhaskell/stack/issues/4027"&gt;#4027&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Order of commandline arguments does not matter anymore. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3959"&gt;#3959&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;When prompting users about saving their Hackage credentials on upload, flush to stdout before waiting for the response so the prompt actually displays. Also fixes a similar issue with ghci target selection prompt.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;cabal&lt;/code&gt; is not on PATH, running &lt;code&gt;stack solver&lt;/code&gt; now prompts the user to run &lt;code&gt;stack install cabal-install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build&lt;/code&gt; now succeeds in building packages which contain sublibraries which are dependencies of executables, tests or benchmarks but not of the main library. See &lt;a href="https://github.com/commercialhaskell/stack/issues/3959"&gt;#3787&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Sublibraries are now properly considered for coverage reports when the test suite depends on the internal library. Before, stack was erroring when trying to generate the coverage report, see &lt;a href="https://github.com/commercialhaskell/stack/issues/4105"&gt;#4105&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Sublibraries are now added to the precompiled cache and recovered from there when the snapshot gets updated. Previously, updating the snapshot when there was a package with a sublibrary in the snapshot resulted in broken builds. This is now fixed, see &lt;a href="https://github.com/commercialhaskell/stack/issues/4071"&gt;#4071&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;[#4114] Stack pretty prints error messages with proper &lt;code&gt;error&lt;/code&gt; logging level instead of &lt;code&gt;warning&lt;/code&gt; now. This also fixes self-executing scripts not piping plan construction errors from runhaskell to terminal (issue #3942).&lt;/li&gt;
&lt;li&gt;Fix invalid “While building Setup.hs” when Cabal calls fail. See: &lt;a href="https://github.com/commercialhaskell/stack/issues/3934"&gt;#3934&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack upload&lt;/code&gt; signs the package by default, as documented. &lt;code&gt;--no-signature&lt;/code&gt; turns the signing off. &lt;a href="https://github.com/commercialhaskell/stack/issues/3739"&gt;#3739&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html</id><title type="text">[cygwin] cygwinセットアップ・環境構築手順メモ</title><updated>2018-10-20T19:31:17.645+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/01/cygwin-cygwin.html"/><summary type="text">

主に自分向けの防備録です。windows10上で確認。インストーラーはここからDLする。





&lt;&lt;設定&gt;&gt;

ssh-agentの重複起動を防ぐ


ユーザーのアカウント名、ホームディレクトリの変更



/etc/passwdを編集する（最新バージョンでは自動生成されない？）
Cygwinを移動したら/etc/passwdの再生成を
巨大ドメインに参加している PC での /etc/passwd, /etc/group ファイルのつくりかた 

ssh-agentのために秘密鍵セットアップ



~/.ssh/


※group/otherの権限を削除する必要がある

% chmod 700 ~/.ssh 


less, lv, manコマンド終了時に画面をクリアしない

[linux][cygwin] less, manの終了直前の画面をクリアしないで端末上に残す方法 
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html</id><title type="text">stack-templates を集める with GraphQL</title><updated>2018-10-14T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-10-14-collect-stack-templates.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;stack-templates を集める with GraphQL&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-10-14" itemprop="datePublished"&gt;
        Oct 14, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/GraphQL.html"&gt;GraphQL&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;Haskell Day の仕込みパート1です(2があるかは知らない)． stack の次期バージョン v1.9 で追加される namespaced template を試してみました．&lt;/p&gt;
&lt;p&gt;ちなみに，現在 v1.9 はプレリリースになったので，下記コマンドで簡単にアップデートできます．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack upgrade --binary-version 1.9.0.1&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="namespaced-template"&gt;namespaced template&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stack new&lt;/code&gt; で指定できるテンプレートを，GitHub などのオンラインからも取ってこれるようになった機能． 詳しくは開発段階からキャッチアップしてる e-bigmoon さんの記事を読むと良い．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html"&gt;namespaced templates - BIGMOON haskellers blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="作ってみた"&gt;作ってみた&lt;/h3&gt;
&lt;p&gt;GitHub などで &lt;code&gt;stack-templates&lt;/code&gt; という名前のリポジトリを作り，&lt;code&gt;hsfiles&lt;/code&gt; という拡張子のテンプレートファイルをトップレベルに置く． 今回ぼくは &lt;a href="https://github.com/matsubara0507/stack-templates"&gt;matsubara0507/stack-templates&lt;/a&gt; というリポジトリを作り，２つ程作ってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get-opt-cli.hsfiles&lt;/code&gt; : &lt;a href="http://hackage.haskell.org/package/base/docs/System-Console-GetOpt.html"&gt;&lt;code&gt;System.Console.GetOpt&lt;/code&gt;&lt;/a&gt; を用いたCLIのテンプレート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;optparse-applicative-cli.hsfiles&lt;/code&gt; : &lt;a href="http://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; を用いたCLIのテンプレート&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どちらも，よくCLIを作るときの書き方をテンプレートとして起こしたもの． 普段は &lt;a href="http://hackage.haskell.org/package/rio"&gt;rio&lt;/a&gt; と &lt;a href="http://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; を使っているので，単純に optparse-applicative などを使ったテンプレートという訳でもない．&lt;/p&gt;
&lt;h3 id="テストする"&gt;テストする&lt;/h3&gt;
&lt;p&gt;できれば，テンプレートを &lt;code&gt;stack new&lt;/code&gt; して &lt;code&gt;stack build&lt;/code&gt; した時点ではコンパイルを通ってほしい． ということで &lt;code&gt;stack new&lt;/code&gt; して &lt;code&gt;stack build&lt;/code&gt; を試してくれるテストを &lt;a href="https://github.com/matsubara0507/stack-templates/blob/7abc95184241c2df9f81ec1a45f9a662a98db05a/.travis.yml"&gt;TravisCI&lt;/a&gt; に書いた．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="fu"&gt;matrix:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;include:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;env:&lt;/span&gt;&lt;span class="at"&gt; TEMPLATE=&amp;quot;get-opt-cli&amp;quot; ARGS=&amp;quot;--resolver lts-12&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;    &lt;span class="fu"&gt;compiler:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;: #stack 8.4.3&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;addons:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;{&lt;/span&gt;&lt;span class="fu"&gt;apt:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;{&lt;/span&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[&lt;/span&gt;libgmp-dev&lt;span class="kw"&gt;]}}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;env:&lt;/span&gt;&lt;span class="at"&gt; TEMPLATE=&amp;quot;optparse-applicative-cli&amp;quot; ARGS=&amp;quot;--resolver lts-12&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;    &lt;span class="fu"&gt;compiler:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="st"&gt;&amp;quot;: #stack 8.4.3&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;    &lt;span class="fu"&gt;addons:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;{&lt;/span&gt;&lt;span class="fu"&gt;apt:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;{&lt;/span&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[&lt;/span&gt;libgmp-dev&lt;span class="kw"&gt;]}}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="fu"&gt;before_install:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;&lt;span class="co"&gt;# install stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;&lt;span class="fu"&gt;install:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; stack new sample &lt;span class="st"&gt;&amp;quot;./$TEMPLATE&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; |&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;  set -ex&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;  cd sample&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" data-line-number="18"&gt;  stack --no-terminal --install-ghc $ARGS test --bench --only-dependencies&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" data-line-number="19"&gt;  set +ex&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" data-line-number="20"&gt;&lt;span class="fu"&gt;script:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" data-line-number="21"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; |&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" data-line-number="22"&gt;  set -ex&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-23" data-line-number="23"&gt;  stack --no-terminal $ARGS test --bench --no-run-benchmarks --no-haddock-deps&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-24" data-line-number="24"&gt;  set +ex&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/commercialhaskell/stack-templates/blob/879f95dc44b24201bc64fcf8f4b9e2192c23dad4/test-templates.hs"&gt;commercialhaskell/stack-templates でもテストは書いてある&lt;/a&gt;がぼくのはすごいシンプルだ．&lt;/p&gt;
&lt;h2 id="stack-templates-を集める"&gt;stack-templates を集める&lt;/h2&gt;
&lt;p&gt;さて，これだけでは完全に e-bigmoon さんの劣化記事だ． なので，stack-templates を GitHub から集めてくる CLI ツールを作ることにした．&lt;/p&gt;
&lt;p&gt;試したところ，GitHub の検索で &lt;code&gt;stack-template in:name&lt;/code&gt; と検索すれば，それなりにヒットすることがわかった(間違いも多いが)． なので，ざっくりとした手順は:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;検索系の GitHub API を叩く&lt;/li&gt;
&lt;li&gt;stack-templates という名前のリポジトリの &lt;code&gt;*.hsfiles&lt;/code&gt; というファイルだけ抽出&lt;/li&gt;
&lt;li&gt;それらを出力&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ここで GitHub API v3 (RESTful API)を利用すると，リポジトリのファイル群を取得するのに検索系の API を叩いてから，各リポジトリの API を叩く必要がある． それは面倒だ． なので，ここ数年注目を集めている(？) GraphQL API (GitHub API v4)を試してみることにした．&lt;/p&gt;
&lt;h3 id="graphql"&gt;GraphQL&lt;/h3&gt;
&lt;p&gt;ちょうどこの前に，友人から「GraphQL はいいぞ，API をなんども叩く必要がない．」と紹介されたので試してみた．&lt;/p&gt;
&lt;p&gt;GitHub の API では &lt;code&gt;api.github.com/graphql&lt;/code&gt; というエンドポイントに対し，POST メソッドでクエリを送信する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode sh"&gt;&lt;code class="sourceCode bash"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;$ &lt;span class="ex"&gt;curl&lt;/span&gt; \&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;  -H &lt;span class="st"&gt;&amp;quot;Authorization: bearer token&amp;quot;&lt;/span&gt; \&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;  -X POST \&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;  -d &lt;span class="st"&gt;&amp;quot;{ &lt;/span&gt;&lt;span class="dt"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="st"&gt;query&lt;/span&gt;&lt;span class="dt"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="st"&gt;: &lt;/span&gt;&lt;span class="dt"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="st"&gt; ... &lt;/span&gt;&lt;span class="dt"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="st"&gt; }&amp;quot;&lt;/span&gt; \&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;  https://api.github.com/graphql&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;...&lt;/code&gt; のところにクエリを記述する． クエリは簡単な DSL のようになっており，クエリによってどんな形の JSON が返ってくるか(型のようなもの)やどんな値が返ってくるかが決まる． 例えば &lt;code&gt;stack-template in:name&lt;/code&gt; 検索してヒットしたリポジトリの名前だけを取得してみよう． その場合は次のようなクエリを書く．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query{
  search(query: &amp;quot;stack-template in:name&amp;quot;, type: REPOSITORY, first: 2) {
    repositoryCount,
    edges{
      node{ ... on Repository{ nameWithOwner } }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;first&lt;/code&gt; は検索にヒットした最初の2つを返すという意味． 上限は 100 で，&lt;code&gt;first&lt;/code&gt; ないしは逆の意味の &lt;code&gt;last&lt;/code&gt; のどちらかは指定をする必要がある(そういうエラーが返ってくる)． &lt;code&gt;repositoryCount&lt;/code&gt; は検索でヒットしたリポジトリの総数で，&lt;code&gt;edges&lt;/code&gt; のところはリポジトリの &lt;code&gt;nameWithOwner&lt;/code&gt; を返すように指定している． このように &lt;code&gt;{}&lt;/code&gt; の中ではカンマ区切りで，返す JSON の形を指定できる． 具体的に何が指定できるかは &lt;a href="https://developer.github.com/v4/query/"&gt;GitHub API v4 のドキュメント&lt;/a&gt;を見ると良い． 試しに curl で叩いてみる(クエリ内の &lt;code&gt;&amp;quot;&lt;/code&gt; をエスケープすることを忘れずに):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -H &amp;quot;Authorization: bearer XXX&amp;quot; -X POST -d &amp;quot;{ \&amp;quot;query\&amp;quot;: \&amp;quot; ... \&amp;quot; }&amp;quot; https://api.github.com/graphql
{&amp;quot;data&amp;quot;:{&amp;quot;search&amp;quot;:{&amp;quot;repositoryCount&amp;quot;:76,&amp;quot;edges&amp;quot;:[{&amp;quot;node&amp;quot;:{&amp;quot;nameWithOwner&amp;quot;:&amp;quot;Azure/AzureStack-QuickStart-Templates&amp;quot;}},{&amp;quot;node&amp;quot;:{&amp;quot;nameWithOwner&amp;quot;:&amp;quot;commercialhaskell/stack-templates&amp;quot;}}]}}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Connection とか Fields とかの用語については自分もよくわかってないので自分で調べてください． 今のところ，雰囲気で使ってる(笑)&lt;/p&gt;
&lt;h3 id="ファイルを集める"&gt;ファイルを集める&lt;/h3&gt;
&lt;p&gt;さて，前述した結果(リポジトリ名)だけが欲しいなら GitHub API v3 でも十分だ． さらに，ファイルも取得してみよう． &lt;a href="https://developer.github.com/v4/object/repository/"&gt;Repository のドキュメント&lt;/a&gt; を眺めると &lt;code&gt;object&lt;/code&gt; という Field がある． 察するに，リポジトリの任意のブランチ(&lt;code&gt;expression&lt;/code&gt; で指定したもの)のコミットオブジェクトを返してくれるのだろう． (たぶん)stack-templates は全部 master が前提なので，master のコミットオブジェクトを取ってくる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;... on Repository{
  nameWithOwner,
  object(expression:&amp;quot;master&amp;quot;){
    ... on Commit { }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちなみに &lt;code&gt;... on Commit&lt;/code&gt; というのは Inline Fragments と呼ばれるもので，object の型(サブタイプ？)が &lt;code&gt;Commit&lt;/code&gt; だった場合に &lt;code&gt;Commit{}&lt;/code&gt; 以下の Field を返すそうだ． git オブジェクトなので他にも &lt;code&gt;Tree&lt;/code&gt; や &lt;code&gt;Blob&lt;/code&gt; がある．&lt;/p&gt;
&lt;p&gt;さて，あとは git オブジェクトの知識があれば簡単にかける． コミットオブジェクトにはツリーオブジェクト，要するにトップレベルのディレクトリのハッシュが記載されているので&lt;a href="https://developer.github.com/v4/object/commit/"&gt;ドキュメント&lt;/a&gt;からそれっぽいのを見つける． ツリーオブジェクトには，そのディレクトリに含まれるブロブオブジェクト(ファイル)とツリーオブジェクト(ディレクトリ)のハッシュが記載されてる． stack-templates は(今のところ)トップレベルに &lt;code&gt;*.hsfiles&lt;/code&gt; を置かないといけないので，トップレベルのオブジェクトたちの名前を取得しよう:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;... on Repository{
  nameWithOwner,
  object(expression:&amp;quot;master&amp;quot;){
    ... on Commit { tree{ entries{ name, type } } }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; には &lt;code&gt;blob&lt;/code&gt; やら &lt;code&gt;tree&lt;/code&gt; やらが入る． これで，検索にヒットした全てのリポジトリから &lt;code&gt;master&lt;/code&gt; のトップレベルにあるファイルを取得するクエリが出来上がった．&lt;/p&gt;
&lt;h3 id="ページネーション"&gt;ページネーション&lt;/h3&gt;
&lt;p&gt;今のところ，検索にヒットするリポジトリ数は76個なので &lt;code&gt;first: 100&lt;/code&gt; とすれば全て取得できるが，今後ヒット数が100を超えたときようにページネーションの仕組みを整えておく． やり方は簡単で，&lt;code&gt;search&lt;/code&gt; Connection のところで &lt;a href=""&gt;&lt;code&gt;pageInfo&lt;/code&gt;&lt;/a&gt; という Field を追加する．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;search(query: &amp;quot;stack-template in:name&amp;quot;, type: REPOSITORY, first: 1) {
  repositoryCount,
  pageInfo{
    endCursor,
    hasNextPage
  },
  edges{
    node{ ... on Repository{ .... } }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hasNextPage&lt;/code&gt; は次のページが存在するかどうかを真偽値で返してくれる． &lt;code&gt;endCursor&lt;/code&gt; はこのページの最後を表すハッシュ値？で，&lt;code&gt;search&lt;/code&gt; Connection の引数(&lt;code&gt;type&lt;/code&gt; とか &lt;code&gt;first&lt;/code&gt; とかのとこ)に &lt;code&gt;after&lt;/code&gt; で指定することで，それ以降の結果を取ってくる． このような &lt;code&gt;pageInfo&lt;/code&gt; の情報さえあれば，プログラム内でループさせることは容易だろう．&lt;/p&gt;
&lt;h3 id="まとめると"&gt;まとめると&lt;/h3&gt;
&lt;p&gt;次のようなクエリになった:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query{
  search(query: &amp;quot;stack-template in:name&amp;quot;, type: REPOSITORY, first: 100) {
    repositoryCount,
    pageInfo{
      endCursor,
      hasNextPage
    },
    edges{
      node{ ... on Repository{
        nameWithOwner,
        object(expression:&amp;quot;master&amp;quot;){
          ... on Commit { tree{ entries{ name, type } } }
        }
      } }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを curl の引数に与えて叩くだけで 100 個分のリポジトリの全てのトップレベルファイル群を取得できる．&lt;/p&gt;
&lt;h3 id="stack-tpls"&gt;stack-tpls&lt;/h3&gt;
&lt;p&gt;実際に作った CLI ツールは &lt;a href="https://github.com/matsubara0507/stack-tpls"&gt;&lt;code&gt;matsubara0507/stack-tpls&lt;/code&gt;&lt;/a&gt; というリポジトリに置いてある． 使い方は README に書いてある． 一覧を取得するには &lt;code&gt;stack-tpls --list&lt;/code&gt; と打てば良い．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack-tpls --list
github:commercialhaskell/chrisdone.hsfiles
github:commercialhaskell/foundation.hsfiles
 .
 .
 .&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この結果を &lt;code&gt;stack new&lt;/code&gt; の引数に与えることでそのまま利用できる． また，テンプレートの中身を確認したい場合は，&lt;code&gt;stack-tpls github:commercialhaskell/chrisdone.hsfiles&lt;/code&gt; と引数に与えることで Raw を取ってきてくれる． リンクだけが欲しい場合は &lt;code&gt;--link&lt;/code&gt; オプションを指定すると良い．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack-tpls --link github:commercialhaskell/rio.hsfiles
https://github.com/commercialhaskell/stack-templates/blob/master/rio.hsfiles&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="todo"&gt;ToDo&lt;/h3&gt;
&lt;p&gt;一週間ほど前の思いつきからの突貫で作ったのでイロイロと抜けてる箇所があって:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エラーハンドリングが雑&lt;/li&gt;
&lt;li&gt;GitLab と BitBucket には対応していない&lt;/li&gt;
&lt;li&gt;GraphQL の使い方がエレガントじゃない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に最後のがすごい気になっていて，現状は完全に文字列を埋め込んでいるだけなのだ． できれば，強力な型システムを利用した GitHub GraphQL Client ライブラリを作りたい(なんか昔に Haskell-jp で話題に上がったなぁ)．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;GraphQL，クライアント側に取ってすごい便利．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/09-17-time-package.html</id><title type="text">time パッケージの使い方</title><updated>2018-09-17T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/09-17-time-package.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;Haskell で時間や日付を扱う際に良く利用されるのは &lt;a href="https://www.stackage.org/lts-12.9/package/time"&gt;time&lt;/a&gt; パッケージです。&lt;/p&gt;
&lt;p&gt;このパッケージが使いやすいかどうかは人それぞれですが、使い方を知っておくと便利なのでよく使いそうな関数を簡単に解説しようと思います。&lt;/p&gt;
&lt;p&gt;これからの例は以下のコマンドを実行していると仮定して話を進めます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack repl --package time --resolver lts-12.9
$ import Data.Time&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h2 id="time-パッケージのモジュール構造"&gt;Time パッケージのモジュール構造&lt;/h2&gt;
&lt;p&gt;基本的には &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time.html"&gt;Data.Time&lt;/a&gt; を import して使います。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Time&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Data.Time は以下のモジュールを再エクスポートしています。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;モジュール名&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html"&gt;Data.Time.Calendar&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html"&gt;Data.Time.Clock&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;全然使わないので良くわからない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-LocalTime.html"&gt;Data.Time.LocalTime&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日本の現在時刻を取得など&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html"&gt;Data.Time.Format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;出力の整形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="rio-を利用している場合"&gt;rio を利用している場合&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/lts-12.9/package/rio"&gt;rio&lt;/a&gt; を利用している場合は &lt;a href="https://www.stackage.org/haddock/lts-12.9/rio-0.1.5.0/RIO-Time.html"&gt;RIO.Time&lt;/a&gt; を import します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;RIO.Time&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="data.time.localtime"&gt;Data.Time.LocalTime&lt;/h2&gt;
&lt;p&gt;現在時刻を取得する場合にこのモジュールを使います。現在時刻を取得したいからと言って &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html#v:getCurrentTime"&gt;getCurrentTime&lt;/a&gt; を利用すると日本時間にならないので注意してください。&lt;/p&gt;
&lt;h3 id="getzonedtime"&gt;getZonedTime&lt;/h3&gt;
&lt;p&gt;システムのタイムゾーンに応じた現在時刻を返します。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t getZonedTime
getZonedTime :: IO ZonedTime

&amp;gt; getZonedTime
2018-09-17 13:41:05.512522063 JST&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="getcurrenttimezone"&gt;getCurrentTimeZone&lt;/h3&gt;
&lt;p&gt;システムのタイムゾーンを取得します。このタイムゾーンに基づいて &lt;code&gt;getZonedTime&lt;/code&gt; が計算されます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t getCurrentTimeZone
getCurrentTimeZone :: IO TimeZone

&amp;gt; getCurrentTimeZone
JST&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="zonedtimetoutc"&gt;zonedTimeToUTC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ZonedTime&lt;/code&gt; を &lt;code&gt;UTCTime&lt;/code&gt; に変換するために使います。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t zonedTimeToUTC
zonedTimeToUTC :: ZonedTime -&amp;gt; UTCTime

&amp;gt; zonedTimeToUTC &amp;lt;$&amp;gt; getZonedTime
2018-09-17 04:41:27.907476307 UTC&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="utctozonedtime"&gt;utcToZonedTime&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;zonedTimeToUTC&lt;/code&gt; の逆で &lt;code&gt;UTCTime&lt;/code&gt; を &lt;code&gt;ZonedTime&lt;/code&gt; に変換する関数です。タイムゾーンのための引数を余分に取ります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t utcToZonedTime
utcToZonedTime :: TimeZone -&amp;gt; UTCTime -&amp;gt; ZonedTime

&amp;gt; utcToZonedTime &amp;lt;$&amp;gt; getCurrentTimeZone &amp;lt;*&amp;gt; getCurrentTime
2018-09-17 13:41:37.955641567 JST&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="日後の時間を計算するには"&gt;1日後の時間を計算するには？&lt;/h2&gt;
&lt;p&gt;ここで、取得した時間の1日後を計算してみましょう。&lt;/p&gt;
&lt;p&gt;そのためには Data.Time.Clock で定義されている &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html#v:addUTCTime"&gt;addUTCTime&lt;/a&gt; を使います。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;addUTCTime ::&lt;/span&gt; &lt;span class="dt"&gt;NominalDiffTime&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;UTCTime&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;UTCTime&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一引数に &lt;code&gt;NominalDiffTime&lt;/code&gt; という謎の型を取りますが、&lt;code&gt;nominalDay&lt;/code&gt; の実装を見れば &lt;code&gt;60 * 60 * 24&lt;/code&gt; っぽいことがわかるので、そんな感じで値を作ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="ot"&gt;nominalDay ::&lt;/span&gt; &lt;span class="dt"&gt;NominalDiffTime&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;nominalDay &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;86400&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに、上記の実装でなぜ &lt;code&gt;NominalDiffTime&lt;/code&gt; の値になるかと言うと、&lt;code&gt;NominalDiffTime&lt;/code&gt; は &lt;code&gt;Num&lt;/code&gt; クラスのインスタンスになっているため、自動的に &lt;code&gt;fromInteger&lt;/code&gt; が呼ばれて変換されるという仕組みです。&lt;/p&gt;
&lt;p&gt;実際に試してみましょう。1日後を計算してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; t = addUTCTime nominalDay . zonedTimeToUTC &amp;lt;$&amp;gt; getZonedTime
2018-09-17 10:32:56.880362453 UTC

&amp;gt; getZonedTime
2018-09-17 13:49:09.279378323 JST

&amp;gt; utcToZonedTime &amp;lt;$&amp;gt; getCurrentTimeZone &amp;lt;*&amp;gt; t
2018-09-18 13:49:16.211737218 JST&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同様に1時間後も計算してみましょう。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; t = addUTCTime (60 * 60) . zonedTimeToUTC &amp;lt;$&amp;gt; getZonedTime

&amp;gt; getZonedTime
2018-09-17 13:49:33.169797528 JST

&amp;gt; t
2018-09-17 05:49:36.757498845 UTC

&amp;gt; utcToZonedTime &amp;lt;$&amp;gt; getCurrentTimeZone &amp;lt;*&amp;gt; t
2018-09-17 14:49:40.930944714 JST&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上手くいってますね！&lt;/p&gt;
&lt;h2 id="data.time.localtime-1"&gt;Data.Time.LocalTime&lt;/h2&gt;
&lt;p&gt;時刻の取得・計算ができたら、あとは整形して出力するだけです！&lt;/p&gt;
&lt;p&gt;Data.Time.LocalTime モジュールの関数を使って出力を整形してみましょう！&lt;/p&gt;
&lt;h3 id="formattime"&gt;formatTime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:formatTime"&gt;formatTime&lt;/a&gt; 関数の使い方がわかれば、任意の形式で出力できるようになります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t formatTime
formatTime :: FormatTime t =&amp;gt; TimeLocale -&amp;gt; String -&amp;gt; t -&amp;gt; String&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで &lt;code&gt;FormatTime t&lt;/code&gt; の &lt;code&gt;t&lt;/code&gt; は &lt;code&gt;UTCTime&lt;/code&gt; や &lt;code&gt;ZonedTime&lt;/code&gt;、&lt;code&gt;Day&lt;/code&gt; などの型が使えます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="ot"&gt;formatTime ::&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;ZonedTime&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;&lt;span class="ot"&gt;formatTime ::&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;UTCTime&lt;/span&gt;   &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt;&lt;span class="ot"&gt;formatTime ::&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Day&lt;/span&gt;       &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;型に応じて第三引数が変わるということです。&lt;/p&gt;
&lt;p&gt;実際に使えばすぐに慣れます。(第一引数の値は &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:defaultTimeLocale"&gt;defaultTimeLocale&lt;/a&gt; を指定しておけば良いのですが、自分でカスタマイズしたものを使うこともあります)&lt;/p&gt;
&lt;p&gt;第二引数がフォーマット文字列なので、空文字列を与えれば当然結果も空になります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; formatTime defaultTimeLocale &amp;quot;&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;フォーマットの指定方法については &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:formatTime"&gt;haddock&lt;/a&gt; を参照してください。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; formatTime defaultTimeLocale &amp;quot;%D&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;09/17/18&amp;quot;

&amp;gt; formatTime defaultTimeLocale &amp;quot;%F&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;2018-09-17&amp;quot;

&amp;gt; formatTime defaultTimeLocale &amp;quot;%x&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;09/17/18&amp;quot;

&amp;gt; formatTime defaultTimeLocale &amp;quot;%Y/%m/%d-%T&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;2018/09/17-13:52:21&amp;quot;

&amp;gt; formatTime defaultTimeLocale rfc822DateFormat &amp;lt;$&amp;gt; getZonedTime
&amp;quot;Sun, 16 Sep 2018 19:53:10 JST&amp;quot;

&amp;gt; formatTime defaultTimeLocale (iso8601DateFormat Nothing) &amp;lt;$&amp;gt; getZonedTime
&amp;quot;2018-09-16&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="文字列をパーズして-zonedtime-や-day-の値を作る"&gt;文字列をパーズして ZonedTime や Day の値を作る&lt;/h2&gt;
&lt;p&gt;ここまでは現在時刻を元に時刻の計算や出力結果の整形を行いました。&lt;/p&gt;
&lt;p&gt;しかし、実際のプログラムでは文字列をパーズして &lt;code&gt;ZonedTime&lt;/code&gt; や &lt;code&gt;Day&lt;/code&gt; の値に変換したいこともあるでしょう。そのような場合は &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:parseTimeM"&gt;parseTimeM&lt;/a&gt; を使うと便利です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; :t parseTimeM
parseTimeM
  :: (Monad m, ParseTime t) =&amp;gt;
     Bool -&amp;gt; TimeLocale -&amp;gt; String -&amp;gt; String -&amp;gt; m t&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;型がわかりづらいですが、具体的にはこんな型で利用することができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" title="1"&gt;&lt;span class="ot"&gt;parseTimeM ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Day&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" title="2"&gt;&lt;span class="ot"&gt;parseTimeM ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;ZonedTime&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" title="3"&gt;&lt;span class="ot"&gt;parseTimeM ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Day&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" title="4"&gt;&lt;span class="ot"&gt;parseTimeM ::&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;TimeLocale&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;ZonedTime&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;第一引数は &lt;strong&gt;空白&lt;/strong&gt; を許容するかどうかのフラグです (True だと空白OK)&lt;/li&gt;
&lt;li&gt;第二引数は気にせず &lt;strong&gt;defaultTimeLocale&lt;/strong&gt; を指定しておきましょう&lt;/li&gt;
&lt;li&gt;第三引数は &lt;strong&gt;パーズで利用するフォーマット&lt;/strong&gt; を指定します&lt;/li&gt;
&lt;li&gt;第四引数は &lt;strong&gt;入力の文字列&lt;/strong&gt; です&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="具体例"&gt;具体例&lt;/h3&gt;
&lt;p&gt;実際にいくつか使ってみましょう。以下の通り &lt;code&gt;%F&lt;/code&gt; は &lt;code&gt;YYYY-MM-DD&lt;/code&gt; の書式になります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; formatTime defaultTimeLocale &amp;quot;%F&amp;quot; &amp;lt;$&amp;gt; getZonedTime
&amp;quot;2018-09-17&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モナドを &lt;code&gt;IO&lt;/code&gt; や &lt;code&gt;Maybe&lt;/code&gt; などに変化させた基本的な例。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; parseTimeM True defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot;2018-09-17&amp;quot; :: IO ZonedTime
2018-09-17 00:00:00 +0000

&amp;gt; parseTimeM True defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot;2018-09-17&amp;quot; :: Maybe ZonedTime
Just 2018-09-17 00:00:00 +0000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一引数を変化させて、入力文字列の空白の有無について確認する例。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; parseTimeM True defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot; 2018-09-17 &amp;quot; :: IO ZonedTime
2018-09-17 00:00:00 +0000

&amp;gt; parseTimeM False defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot; 2018-09-17 &amp;quot; :: IO ZonedTime
*** Exception: user error (parseTimeM: no parse of &amp;quot;2018-09-17 &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;入力文字列とパーズの書式がマッチしない例&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; parseTimeM False defaultTimeLocale &amp;quot;%x&amp;quot; &amp;quot; 2018-09-17 &amp;quot; :: IO ZonedTime
*** Exception: user error (parseTimeM: no parse of &amp;quot; 2018-09-17 &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Day 型の値をとしてパーズする例&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; parseTimeM True defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot;2018-09-17&amp;quot; :: IO Day
2018-09-17&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このようにして日付を取得できれば、今回は説明していませんが &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html"&gt;Data.Time.Calendar&lt;/a&gt; の &lt;a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html#v:addDays"&gt;addDays&lt;/a&gt; 関数などを使って日付の計算を行うこともできるようになります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; d = parseTimeM True defaultTimeLocale &amp;quot;%F&amp;quot; &amp;quot;2018-09-17&amp;quot; :: IO Day

&amp;gt; addDays 1 &amp;lt;$&amp;gt; d
2018-09-18

&amp;gt; addDays 35 &amp;lt;$&amp;gt; d
2018-10-22&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;time パッケージを使うと時刻や日付の計算ができる&lt;/li&gt;
&lt;li&gt;現在の&lt;strong&gt;日本&lt;/strong&gt;時間を取得した場合は &lt;strong&gt;getCurrentTime&lt;/strong&gt; ではなく、&lt;strong&gt;getZonedTime&lt;/strong&gt; を使う&lt;/li&gt;
&lt;li&gt;整形には &lt;strong&gt;formatTime&lt;/strong&gt; を使う&lt;/li&gt;
&lt;li&gt;文字列から &lt;strong&gt;ZonedTime&lt;/strong&gt; や &lt;strong&gt;Day&lt;/strong&gt; に変換する際は &lt;strong&gt;parseTimeM&lt;/strong&gt; を使う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Haskell入門の &lt;strong&gt;7.7 日付・時刻を扱う&lt;/strong&gt; にも3ページほど &lt;strong&gt;time&lt;/strong&gt; パッケージの解説があるので、気になる人はそちらも確認してみると良いかもしれません。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;
&lt;h2 id="おまけ"&gt;おまけ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;getZonedTime&lt;/code&gt; に対して &lt;code&gt;formatTime defaultTimeLocale &amp;lt;フォーマット文字&amp;gt;&lt;/code&gt; の対応表です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; getZonedTime
2018-09-17 14:44:52.052040178 JST&lt;/code&gt;&lt;/pre&gt;
&lt;div class="narrow-table"&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;文字&lt;/th&gt;
&lt;th&gt;出力結果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%-z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%_z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+ 900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%0z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+0900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%^z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+0900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%#z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+0900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%8z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+00000900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%_12z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+         900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+0900&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%Z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;JST&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Mon Sep 17 14:39:34 JST 2018&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14:39&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14:40:12&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14:40:31&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;02:40:55 PM&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%P&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pm&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PM&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%H&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%k&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%I&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;02&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%l&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%M&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;43&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;49&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;903244678000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%Q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.28084722&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1537163079&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;09/17/18&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%F&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2018-09-17&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;09/17/18&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2018&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;18&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%C&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;20&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;September&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Sep&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Sep&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;09&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;17&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;17&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%j&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;260&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;20&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;38&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Mon&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Monday&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%U&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;37&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;&lt;code&gt;%w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;code&gt;%W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;38&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/09-01-stack-profile-build.html</id><title type="text">stack でアプリケーションのバックトレースを取得する (デバッグ)</title><updated>2018-09-01T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/09-01-stack-profile-build.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;Haskell のデバッグ手法については、以下の記事がとても詳しく参考になります。素晴らしい記事です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.miz-ar.info/2018/01/debugging-haskell-program"&gt;Haskell でのデバッグ手法あれこれ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回はHaskellアプリケーションをデバックする際に、バックトレースのとても簡単な取得方法があったのでご紹介したいと思います。&lt;/p&gt;
&lt;p&gt;まとめると以下の2行です。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build --profile
$ stack exec -- &amp;lt;exe_name&amp;gt; +RTS -xc&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h2 id="バックトレースの取得方法"&gt;バックトレースの取得方法&lt;/h2&gt;
&lt;p&gt;まず、バックトレースを取得するために &lt;a href="https://www.stackage.org/haddock/lts-12.8/base-4.11.1.0/GHC-Stack.html"&gt;GHC.Stack&lt;/a&gt; で定義されている &lt;a href="https://www.stackage.org/haddock/lts-12.8/base-4.11.1.0/GHC-Stack.html#t:HasCallStack"&gt;HasCallStack&lt;/a&gt; をクラス制約として追加します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" title="7"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" title="9"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" title="10"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記の例を雛形として、&lt;strong&gt;HasCallStack&lt;/strong&gt; を追加するとどうなるのか確認していきましょう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Main.hs&lt;/code&gt; はこんな感じで &lt;strong&gt;f1&lt;/strong&gt; を呼び出します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; (main) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" title="5"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" title="6"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; f1&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HasCallStack&lt;/strong&gt; を追加しない場合は以下のような出力となります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:10:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;f3&lt;/strong&gt; でエラーが発生したことはわかりますが、それ以外は何もわかりません。&lt;/p&gt;
&lt;h3 id="f1-f2-f3-に-hascallstack-を追加した場合"&gt;f1, f2, f3 に HasCallStack を追加した場合&lt;/h3&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" title="8"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" title="9"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-11" title="11"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-12" title="12"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ビルドしてみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f2, called at src/Lib.hs:6:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f1, called at app/Main.hs:6:8 in main:Main&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちゃんと呼び出しの関係が &lt;code&gt;error&lt;/code&gt; -&amp;gt; &lt;code&gt;f3&lt;/code&gt; -&amp;gt; &lt;code&gt;f2&lt;/code&gt; -&amp;gt; &lt;code&gt;f1&lt;/code&gt; と表示されていますね！&lt;/p&gt;
&lt;h3 id="f2-f3-にのみ-hascallstack-を追加する"&gt;f2, f3 にのみ HasCallStack を追加する&lt;/h3&gt;
&lt;p&gt;では、ここで &lt;code&gt;f1&lt;/code&gt; の &lt;strong&gt;HasCallStack&lt;/strong&gt; 制約を取り除くとどうなるか確認してみます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" title="5"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" title="6"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" title="8"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" title="9"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" title="11"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" title="12"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f2, called at src/Lib.hs:6:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;f1&lt;/strong&gt; の &lt;strong&gt;HasCallStack&lt;/strong&gt; 制約を取り除いた影響により、先程出力されていた &lt;code&gt;f1, called at app/Main.hs:6:8 in main:Main&lt;/code&gt; が出なくなりました。&lt;/p&gt;
&lt;p&gt;しかし、依然として &lt;strong&gt;f2&lt;/strong&gt; と &lt;strong&gt;f3&lt;/strong&gt; のバックトレースは取得できています。そのため、本当に全てのバックトレースを取得したい場合は全ての関数に &lt;strong&gt;HasCallStack&lt;/strong&gt; 制約を追加しなけばなりません。&lt;/p&gt;
&lt;h3 id="f1-と-f3-にのみ-hascallstack-制約を追加する"&gt;f1 と f3 にのみ HasCallStack 制約を追加する&lt;/h3&gt;
&lt;p&gt;次に中間の &lt;strong&gt;f2&lt;/strong&gt; の &lt;strong&gt;HasCallStack&lt;/strong&gt; 制約を取り除いてみましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" title="5"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" title="6"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" title="8"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" title="9"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" title="11"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" title="12"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今度は &lt;strong&gt;f2&lt;/strong&gt; と &lt;strong&gt;f1&lt;/strong&gt; の両方の情報がが抜け落ちてしまいました。&lt;strong&gt;f2&lt;/strong&gt; で &lt;strong&gt;HasCallStack&lt;/strong&gt; の伝搬がストップしてしまったということです。&lt;/p&gt;
&lt;h3 id="f1-と-f2-のみに-hascallstack-を追加する"&gt;f1 と f2 のみに HasCallStack を追加する&lt;/h3&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" title="5"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" title="6"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" title="8"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;HasCallStack&lt;/span&gt; &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" title="9"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" title="11"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" title="12"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;予想通り &lt;strong&gt;f1&lt;/strong&gt;, &lt;strong&gt;f2&lt;/strong&gt;, &lt;strong&gt;f3&lt;/strong&gt; の全ての情報が途絶えましたね・・・。&lt;/p&gt;
&lt;h2 id="hascallstack-を省略したままバックトレースを取りたい"&gt;HasCallStack を省略したままバックトレースを取りたい&lt;/h2&gt;
&lt;p&gt;先程の結果を見たとおり、正確な情報を取得するためには全ての関数に &lt;strong&gt;HasCallStack&lt;/strong&gt; 制約を追加する必要がありそうです。&lt;/p&gt;
&lt;p&gt;しかしながら、規模が大きくなってくるとそんなの不可能ですよね。&lt;/p&gt;
&lt;p&gt;そんな時には &lt;code&gt;stack&lt;/code&gt; の &lt;code&gt;--profile&lt;/code&gt; オプションと &lt;code&gt;+RTS -xc&lt;/code&gt; オプションを利用します。(&lt;code&gt;--profile&lt;/code&gt; オプションは &lt;strong&gt;ghc&lt;/strong&gt; のオプションを良い感じに追加してくれます)&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Lib&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt;&lt;span class="ot"&gt;f1 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" title="4"&gt;f1 &lt;span class="fu"&gt;=&lt;/span&gt; f2&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" title="6"&gt;&lt;span class="ot"&gt;f2 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" title="7"&gt;f2 &lt;span class="fu"&gt;=&lt;/span&gt; f3&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" title="9"&gt;&lt;span class="ot"&gt;f3 ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" title="10"&gt;f3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;f3&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のような素のコードに対しても、同様にバックトレースが取得できるようになります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ stack build --profile
...
$ stack exec -- example +RTS -xc
*** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace:
  Lib.f3,
  called from Lib.CAF:f3
  --&amp;gt; evaluated by: Lib.CAF:f2
  --&amp;gt; evaluated by: Lib.CAF:f1
  --&amp;gt; evaluated by: Main.CAF:main
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:10:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
CallStack (from -prof):
  Lib.f3 (src/Lib.hs:10:1-15)
  Lib.CAF:f3 (src/Lib.hs:10:1-2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;なんか沢山表示されますが、&lt;code&gt;reporting due to +RTS -xc&lt;/code&gt; の部分を見ると、しっかりとバックトレースが取得できています。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HasCallStack&lt;/strong&gt; を使うとバックトレースが取得できる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack build --profile&lt;/code&gt; でビルドする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack exec -- &amp;lt;exe&amp;gt; +RTS -xc&lt;/code&gt; を使えば、明示的に &lt;strong&gt;HasCallStack&lt;/strong&gt; を追加しなくても、バックトレースが取得できる&lt;/li&gt;
&lt;li&gt;アプリケーションのコードに対して有効&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.miz-ar.info/2018/01/debugging-haskell-program/#HasCallStack"&gt;Haskell でのデバッグ手法あれこれ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#debugging"&gt;Debugging – stack document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xc"&gt;-xc option – GHC Users Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/08-31-stack-extradep-legacy-syntax.html</id><title type="text">stack-1.11 から location に extra-dep を指定できなくなります。</title><updated>2018-08-31T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/08-31-stack-extradep-legacy-syntax.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;まだまだ先の話ですが、&lt;code&gt;extra-dep&lt;/code&gt; の書き方が &lt;strong&gt;Legacy syntax&lt;/strong&gt; になりました。&lt;code&gt;stack-1.11&lt;/code&gt; からはビルドできなくなります。&lt;/p&gt;
&lt;p&gt;以下の設定例は&lt;a href="https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#packages"&gt;公式ドキュメント&lt;/a&gt;の例を少し変更したものです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;location:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;    &lt;span class="fu"&gt;git:&lt;/span&gt;&lt;span class="at"&gt; https://github.com/bitemyapp/esqueleto.git&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;    &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 08c9b4cdf977d5bcd1baba046a007940c1940758&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;  &lt;span class="fu"&gt;extra-dep:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="ch"&gt;true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;location:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;    ./submodules/haskell-lsp&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;  &lt;span class="fu"&gt;extra-dep:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="ch"&gt;true&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;  &lt;span class="fu"&gt;subdirs:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;    &lt;span class="kw"&gt;-&lt;/span&gt; haskell-lsp-types&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; streaming-commons-0.2.0.0&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修正方法は、設定ファイルの &lt;code&gt;packages&lt;/code&gt; に &lt;code&gt;extra-dep: true&lt;/code&gt; と指定している部分を、以下のように &lt;code&gt;extra-deps&lt;/code&gt; へ追加するだけです。また、 &lt;code&gt;subdirs&lt;/code&gt; を指定している場合は単純に分割して指定します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;git:&lt;/span&gt;&lt;span class="at"&gt; https://github.com/bitemyapp/esqueleto.git&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;    &lt;span class="fu"&gt;commit:&lt;/span&gt;&lt;span class="at"&gt; 08c9b4cdf977d5bcd1baba046a007940c1940758&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" title="7"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; ./submodules/haskell-lsp&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" title="8"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; ./submodules/haskell-lsp/haskell-lsp-types&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" title="9"&gt;  &lt;span class="kw"&gt;-&lt;/span&gt; streaming-commons-0.2.0.0&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;extra-deps&lt;/code&gt; の構文は従来の &lt;code&gt;stack&lt;/code&gt; でも使えるので、今から対応しておいても問題ないと思います。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;
&lt;!--more--&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/08-26-recordwildcards.html</id><title type="text">RecordWildCards と Reader モナド</title><updated>2018-08-26T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/08-26-recordwildcards.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Twitter&lt;/code&gt; で &lt;code&gt;RecordWildCards&lt;/code&gt; の話が流れて来たので &lt;code&gt;Reader&lt;/code&gt; モナドと組み合わせた例を1つご紹介します。&lt;/p&gt;
&lt;p&gt;この書き方は &lt;span class="citation" data-cites="fumieval"&gt;@fumieval&lt;/span&gt; さんが使っていてカッコイイ書き方だなぁと思った記憶があります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RecordWildCards #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;  {&lt;span class="ot"&gt; personName ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;  ,&lt;span class="ot"&gt; personAge  ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;span class="ot"&gt;func ::&lt;/span&gt; &lt;span class="dt"&gt;Reader&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;func &lt;span class="fu"&gt;=&lt;/span&gt; ask &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; \&lt;span class="dt"&gt;Person&lt;/span&gt; {&lt;span class="fu"&gt;..&lt;/span&gt;} &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;  &lt;span class="fu"&gt;...&lt;/span&gt; &lt;span class="co"&gt;-- personName, personAge という名前でそのまま値を利用できる&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;RecordWildCards&lt;/code&gt; に関しては既に色んな方が記事にしてくれているので、そちらをご参照ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html"&gt;GHC拡張ノック(Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://rf0444.hatenablog.jp/entry/20120617/1339910411"&gt;Haskellの言語拡張たち 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fumieval.hatenablog.com/entry/2016/12/18/181540"&gt;波打たせるものの正体(エクステンシブル・タングル)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards"&gt;GHC user guide 10.5.5. Record wildcards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id="具体例"&gt;具体例&lt;/h2&gt;
&lt;p&gt;あまり良い例が思いつかなかったのですが、 &lt;code&gt;Env&lt;/code&gt; に必要な情報を持たせておけば任意のタイミングで利用できて便利です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-12.7&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RecordWildCards #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Control.Monad.IO.Class&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" title="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Control.Monad.Trans.Reader&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" title="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.IORef&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" title="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Time.LocalTime&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" title="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Path&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" title="12"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" title="13"&gt;  {&lt;span class="ot"&gt; envCounter  ::&lt;/span&gt; &lt;span class="dt"&gt;IORef&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" title="14"&gt;  ,&lt;span class="ot"&gt; envLogPath  ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" title="15"&gt;  ,&lt;span class="ot"&gt; envUserName ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" title="16"&gt;  }&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" title="17"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-18" title="18"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-19" title="19"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-20" title="20"&gt;  counter &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; newIORef &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-21" title="21"&gt;  &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-22" title="22"&gt;        { envCounter  &lt;span class="fu"&gt;=&lt;/span&gt; counter&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-23" title="23"&gt;        , envLogPath  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(mkRelFile &lt;span class="st"&gt;&amp;quot;./output.log&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-24" title="24"&gt;        , envUserName &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;wado&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-25" title="25"&gt;        }&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-26" title="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-27" title="27"&gt;  runReaderT (access &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; access &lt;span class="fu"&gt;&amp;gt;&amp;gt;&lt;/span&gt; access) env&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-28" title="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-29" title="29"&gt;  n &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readIORef counter&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-30" title="30"&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;mconcat&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;counter = &amp;quot;&lt;/span&gt;, &lt;span class="fu"&gt;show&lt;/span&gt; n]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-31" title="31"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-32" title="32"&gt;&lt;span class="ot"&gt;access ::&lt;/span&gt; &lt;span class="dt"&gt;ReaderT&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-33" title="33"&gt;access &lt;span class="fu"&gt;=&lt;/span&gt; ask &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; \&lt;span class="dt"&gt;Env&lt;/span&gt; {&lt;span class="fu"&gt;..&lt;/span&gt;} &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; liftIO &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-34" title="34"&gt;  modifyIORef envCounter (&lt;span class="fu"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-35" title="35"&gt;  now &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getZonedTime&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-36" title="36"&gt;  &lt;span class="fu"&gt;appendFile&lt;/span&gt; (toFilePath envLogPath)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-37" title="37"&gt;    &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;mconcat&lt;/span&gt; [envUserName, &lt;span class="st"&gt;&amp;quot;: &amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;access&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot; (&amp;quot;&lt;/span&gt;, &lt;span class="fu"&gt;show&lt;/span&gt; now, &lt;span class="st"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-38" title="38"&gt;  &lt;span class="fu"&gt;return&lt;/span&gt; ()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="実行結果"&gt;実行結果&lt;/h3&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Sample.hs
counter = 3

$ cat ./output.log
wado: access (2018-08-26 14:04:07.132813451 JST)
wado: access (2018-08-26 14:04:07.133330363 JST)
wado: access (2018-08-26 14:04:07.133389916 JST)&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="missing-fields-警告"&gt;missing-fields 警告&lt;/h2&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE RecordWildCards #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" title="4"&gt;  {&lt;span class="ot"&gt; personName ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" title="5"&gt;  ,&lt;span class="ot"&gt; personAge  ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" title="6"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" title="8"&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" title="9"&gt;f &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; { &lt;span class="fu"&gt;..&lt;/span&gt; }&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" title="10"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" title="11"&gt;    personName &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のようにフィールドが全て初期化されていないコードはコンパイル時に &lt;code&gt;missing-fields&lt;/code&gt; 警告が出ます。&lt;/p&gt;
&lt;p&gt;この警告を無視すると実行時エラーになる可能性があります。無視せずにしっかり修正しましょう。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;warning&lt;span class="fu"&gt;:&lt;/span&gt; [&lt;span class="fu"&gt;-&lt;/span&gt;&lt;span class="dt"&gt;Wmissing&lt;/span&gt;&lt;span class="fu"&gt;-&lt;/span&gt;fields]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;    • &lt;span class="dt"&gt;Fields&lt;/span&gt; &lt;span class="kw"&gt;of&lt;/span&gt; ‘&lt;span class="dt"&gt;Person&lt;/span&gt;’ &lt;span class="fu"&gt;not&lt;/span&gt; initialised&lt;span class="fu"&gt;:&lt;/span&gt; personAge&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;    • &lt;span class="dt"&gt;In&lt;/span&gt; the expression&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; {&lt;span class="fu"&gt;..&lt;/span&gt;}&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;      &lt;span class="dt"&gt;In&lt;/span&gt; an equation for ‘f’&lt;span class="fu"&gt;:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;          f &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; {&lt;span class="fu"&gt;..&lt;/span&gt;}&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;            &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;                personName &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" title="8"&gt;   &lt;span class="fu"&gt;|&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" title="9"&gt;&lt;span class="dv"&gt;46&lt;/span&gt; &lt;span class="fu"&gt;|&lt;/span&gt; f &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; { &lt;span class="fu"&gt;..&lt;/span&gt; }&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" title="10"&gt;   &lt;span class="fu"&gt;|&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに、通常のレコード構文でもフィールドが部分的にしか初期化されていない場合は、同様の警告がでます。(&lt;span class="citation" data-cites="fumieval"&gt;@fumieval&lt;/span&gt; さん、ご指摘ありがとうございます)&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;  {&lt;span class="ot"&gt; personName ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;  ,&lt;span class="ot"&gt; personAge  ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" title="6"&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" title="7"&gt;f &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Person&lt;/span&gt; { personName &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;bigmoon&amp;quot;&lt;/span&gt; }&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/5334"&gt;record wildcards: field not initialised reported as type error&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RecordWildCards 言語拡張は現実世界ではとても便利 (レコードのフィールドがかなり沢山あったりするので)&lt;/li&gt;
&lt;li&gt;Reader とかと組み合わせるとオシャレ&lt;/li&gt;
&lt;li&gt;GHC の &lt;code&gt;missing-fields&lt;/code&gt; 警告は絶対に無視しない (実行時エラーが発生する可能性がある)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/02/windows-windows10.html</id><title type="text">[windows] Windows10セットアップ・設定項目のメモ</title><updated>2018-08-24T19:26:37.875+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/02/windows-windows10.html"/><summary type="text">Windows10セットアップ時の設定項目、インストールアプリの備忘録。


スタートメニュー・タスクバーの設定

タスクバーの設定 

小さいタスクバーボタンを使う：オン 
[スタート]ボタンを右クリックするかWindowsキー＋Xキーを押したときに表示されるメニューで、コマンドプロンプトをWindows PowerShellに置き換える：オフ
タスクバーボタンを結合する

「タスクバーに入りきらない場合」を選択

タスクバーをすべての ディスプレイに表示する：オフ



 Quick Launcherを表示する

クイック起動を復活する 
Windows 10 タスクバーにクイック起動を表示する

スタートメニューにコントロールパネルを表示する

「Windows 10」のコントロールパネルを表示する方法について

スタートメニューにピン止めするアプリ：

Windowsシステム</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/08-21-path-and-path-io.html</id><title type="text">path ＆ path-io パッケージ</title><updated>2018-08-21T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/08-21-path-and-path-io.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;Haskell でファイルやディレクトリを扱うプログラムを書く時によく使うパッケージとして &lt;a href="https://www.stackage.org/lts-12.7/package/filepath-1.4.2"&gt;filepath&lt;/a&gt; パッケージや &lt;a href="https://www.stackage.org/lts-12.7/package/directory-1.3.1.5"&gt;directory&lt;/a&gt; パッケージがあります。(Haskell入門の「4.4 ファイルシステム」に &lt;strong&gt;directory&lt;/strong&gt; パッケージの話が少し載っています。)&lt;/p&gt;
&lt;p&gt;これらのパッケージは結局のところただの文字列操作なので、バグを出さないためにはパッケージ利用者がかなり注意深く使わなければなりません。&lt;/p&gt;
&lt;p&gt;例えば、以下のようなパスは型レベルでは同じ文字列 (&lt;strong&gt;FilePath&lt;/strong&gt;) ですが&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="co"&gt;-- 相対パス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="ot"&gt;pathRel ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;pathRel &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;./&lt;/span&gt;aaa&lt;span class="fu"&gt;/&lt;/span&gt;bbb&lt;span class="fu"&gt;/&lt;/span&gt;ccc&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="co"&gt;-- 絶対パス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="ot"&gt;pathAbs ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;pathAbs &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;/&lt;/span&gt;home&lt;span class="fu"&gt;/&lt;/span&gt;user&lt;span class="fu"&gt;/&lt;/span&gt;aaa&lt;span class="fu"&gt;/&lt;/span&gt;bbb&lt;span class="fu"&gt;/&lt;/span&gt;ccc&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;&lt;span class="co"&gt;-- ファイルへのパス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&lt;span class="ot"&gt;pathFile ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;pathFile &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;./&lt;/span&gt;aaa&lt;span class="fu"&gt;/&lt;/span&gt;a&lt;span class="fu"&gt;.&lt;/span&gt;png&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;&lt;span class="co"&gt;-- ディレクトリへのパス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;&lt;span class="ot"&gt;pathDir ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;pathDir &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;./&lt;/span&gt;aaa&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このように、&lt;strong&gt;FilePath&lt;/strong&gt; 型では&lt;strong&gt;相対パス&lt;/strong&gt;なのか&lt;strong&gt;絶対パス&lt;/strong&gt;なのか型レベルで判断する方法が無かったり、そもそもパスが&lt;strong&gt;ファイル&lt;/strong&gt;なのか&lt;strong&gt;ディレクトリ&lt;/strong&gt;なのかすらわからなかったりします。&lt;/p&gt;
&lt;p&gt;今回紹介するのは、型レベルでこれらをちゃんと分類できるようにしている &lt;a href="https://github.com/commercialhaskell/path"&gt;path&lt;/a&gt; と &lt;a href="https://github.com/mrkkrp/path-io"&gt;path-io&lt;/a&gt; パッケージです。&lt;/p&gt;
&lt;p&gt;型レベルで &lt;strong&gt;相対パス&lt;/strong&gt; or &lt;strong&gt;絶対パス&lt;/strong&gt; と &lt;strong&gt;ファイル&lt;/strong&gt; or &lt;strong&gt;ディレクトリ&lt;/strong&gt; を表現するため、不正な操作はコンパイル時にチェックできるようになります。&lt;/p&gt;
&lt;p&gt;また、&lt;strong&gt;stack&lt;/strong&gt; の内部でも利用していたので、実用しても大丈夫だと思います。&lt;/p&gt;
&lt;p&gt;パッケージのバージョンは以下のとおりです&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;path-0.6.1&lt;/li&gt;
&lt;li&gt;path-io-1.3.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まだまだ更新が活発なパッケージなので、path-0.7 では破壊的変更を含む更新があるようです。(&lt;a href="https://github.com/commercialhaskell/path/blob/master/CHANGELOG"&gt;CHANGELOG&lt;/a&gt;)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="path-パッケージ"&gt;path パッケージ&lt;/h2&gt;
&lt;p&gt;ドキュメントが充実しているので &lt;a href="https://github.com/commercialhaskell/path/blob/master/README.md"&gt;Readme&lt;/a&gt; を読めば使い方はすぐにわかると思います。&lt;/p&gt;
&lt;h3 id="データ型"&gt;データ型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Path&lt;/code&gt; の型は &lt;code&gt;FilePath&lt;/code&gt; を幽霊型 (Phantom type) を使ってラップしているだけです。(幽霊型については &lt;a href="https://qiita.com/nobkz/items/5926257a375a4a181dde"&gt;ElmでPhantom Type (幽霊型)入門&lt;/a&gt; や &lt;a href="https://qiita.com/HirotoShioi/items/3444e215070144b8ca0f"&gt;で、出たー！幽霊型だー！(Phantom Type)&lt;/a&gt; などが日本語のわかりやすい解説だと思います)&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b t &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;  &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Data&lt;/span&gt;, &lt;span class="dt"&gt;Typeable&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ここで2つの型変数の意味は以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; - 相対パス or 絶対パス&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; - ファイル or ディレクトリ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型変数 &lt;code&gt;b&lt;/code&gt; は実際には以下の型のどちらかを取ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同様に型変数 &lt;code&gt;t&lt;/code&gt; は以下の型を取ります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt; &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的なパスの型は以下の4種類のどれかになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="co"&gt;-- ファイルへの絶対パス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;  &lt;span class="co"&gt;-- ディレクトリへの絶対パス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="co"&gt;-- ファイルへの相対パス&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;  &lt;span class="co"&gt;-- ディレクトリへの相対パス&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;型を見るだけでどんなパスなのか一目瞭然なので、めっちゃ良いですね。&lt;/p&gt;
&lt;h3 id="値の作り方"&gt;値の作り方&lt;/h3&gt;
&lt;p&gt;型については説明したので、次は実際に &lt;code&gt;Path&lt;/code&gt; 型の値を作っていきましょう！&lt;/p&gt;
&lt;h4 id="パースする方法"&gt;パースする方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Path&lt;/code&gt; 型は4種類あるので、パーズする関数も4種類あります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="ot"&gt;parseAbsDir  ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;&lt;span class="ot"&gt;parseRelDir  ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;&lt;span class="ot"&gt;parseAbsFile ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;&lt;span class="ot"&gt;parseRelFile ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;MonadThrow m&lt;/code&gt; がついていますが、この &lt;code&gt;m&lt;/code&gt; は &lt;code&gt;IO&lt;/code&gt; だと思えば以下の型と同じですし&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="ot"&gt;parseAbsDir  ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;&lt;span class="ot"&gt;parseRelDir  ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;&lt;span class="ot"&gt;parseAbsFile ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" title="4"&gt;&lt;span class="ot"&gt;parseRelFile ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; であれば、以下の型と同じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;parseAbsDir  ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;&lt;span class="ot"&gt;parseRelDir  ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;&lt;span class="ot"&gt;parseAbsFile ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Abs&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;&lt;span class="ot"&gt;parseRelFile ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;難しいことはあまり気にせず、(&lt;a href="https://www.stackage.org/haddock/lts-12.7/exceptions-0.10.0/Control-Monad-Catch.html#t:MonadThrow"&gt;MonadThrow&lt;/a&gt; 型クラスのインスタンスになっている) 色んなモナドで使えるんだなと思えば良いと思います。&lt;/p&gt;
&lt;p&gt;実際に &lt;code&gt;ghci&lt;/code&gt; を使って動作を確認してみましょう！&lt;/p&gt;
&lt;pre class="shel"&gt;&lt;code&gt;$ stack repl --package path
&amp;gt; import Path

# 型のチェック
&amp;gt; :t parseAbsDir &amp;quot;/&amp;quot;
parseAbsDir &amp;quot;/&amp;quot; :: MonadThrow m =&amp;gt; m (Path Abs Dir)
&amp;gt; :t parseAbsDir &amp;quot;./&amp;quot;
parseAbsDir &amp;quot;./&amp;quot; :: MonadThrow m =&amp;gt; m (Path Abs Dir)

# IO モナドの文脈
&amp;gt; parseAbsDir &amp;quot;/&amp;quot;
&amp;quot;/&amp;quot;
&amp;gt; parseAbsDir &amp;quot;./&amp;quot;
*** Exception: InvalidAbsDir &amp;quot;./&amp;quot;

# Maybe モナドの文脈
&amp;gt; parseAbsDir &amp;quot;/&amp;quot; :: Maybe (Path Abs Dir)
Just &amp;quot;/&amp;quot;
&amp;gt; parseAbsDir &amp;quot;./&amp;quot; :: Maybe (Path Abs Dir)
Nothing

# 以下のような &amp;quot;../&amp;quot; を含むパスはパーズできない
&amp;gt; parseAbsDir &amp;quot;./../a/b/&amp;quot;
*** Exception: InvalidAbsDir &amp;quot;./../a/b/&amp;quot;
&amp;gt; parseRelDir &amp;quot;./../a/b/&amp;quot;
*** Exception: InvalidAbsDir &amp;quot;./../a/b/&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで文字列から &lt;code&gt;Path&lt;/code&gt; 型に変換する方法がわかりましたね！結構簡単です。&lt;/p&gt;
&lt;h4 id="template-haskell-quasiquotes"&gt;Template Haskell &amp;amp; QuasiQuotes&lt;/h4&gt;
&lt;p&gt;コンパイル時にすでにファイルパスが決まっている時はテンプレートHaskellや準クォートを使うこともできます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;&lt;span class="fu"&gt;$&lt;/span&gt;(mkAbsDir &lt;span class="st"&gt;&amp;quot;/home/chris&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;&lt;span class="fu"&gt;$&lt;/span&gt;(mkRelDir &lt;span class="st"&gt;&amp;quot;chris&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;&lt;span class="fu"&gt;$&lt;/span&gt;(mkAbsFile &lt;span class="st"&gt;&amp;quot;/home/chris/x.txt&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;&lt;span class="fu"&gt;$&lt;/span&gt;(mkRelFile &lt;span class="st"&gt;&amp;quot;chris/x.txt&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;[absdir|/home/chris|]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;[reldir|chris|]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" title="3"&gt;[absfile|/home/chris/x.txt|]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" title="4"&gt;[relfile|chris/x.txt|]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで不正なパスはコンパイル時エラーとなるため、かなり安全ですね。&lt;/p&gt;
&lt;h3 id="path-から-filepath-への変換"&gt;Path から FilePath への変換&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Path&lt;/code&gt; 型の値を &lt;code&gt;FilePath&lt;/code&gt; に変換するためには &lt;code&gt;toFilePath&lt;/code&gt; 関数を利用します。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; toFilePath &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b&amp;quot;
&amp;quot;a/b/&amp;quot;

&amp;gt; toFilePath &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b/&amp;quot;
&amp;quot;a/b/&amp;quot;

&amp;gt; toFilePath &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a////b//////&amp;quot;
&amp;quot;a/b/&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんな感じで期待している文字列に変換されているか確かめることができます。&lt;/p&gt;
&lt;h3 id="パスの等価性"&gt;パスの等価性&lt;/h3&gt;
&lt;p&gt;2つの &lt;code&gt;Path&lt;/code&gt; の等しさは単純に文字列の等価性として定義されています。&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; (&lt;span class="dt"&gt;Path&lt;/span&gt; b t) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;  (&lt;span class="fu"&gt;==&lt;/span&gt;) (&lt;span class="dt"&gt;Path&lt;/span&gt; x) (&lt;span class="dt"&gt;Path&lt;/span&gt; y) &lt;span class="fu"&gt;=&lt;/span&gt; x &lt;span class="fu"&gt;==&lt;/span&gt; y&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実際にいくつか試してみます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; (==) &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b&amp;quot; &amp;lt;*&amp;gt; parseRelDir &amp;quot;./a/b&amp;quot;
True

&amp;gt; (==) &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b&amp;quot; &amp;lt;*&amp;gt; parseRelDir &amp;quot;./a/b/c&amp;quot;
False

&amp;gt; (==) &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b&amp;quot; &amp;lt;*&amp;gt; parseRelDir &amp;quot;./a/b/&amp;quot;
True&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="パスの操作"&gt;パスの操作&lt;/h3&gt;
&lt;p&gt;関数と実行結果のみを紹介していきます。&lt;/p&gt;
&lt;h4 id="つのパスの結合"&gt;2つのパスの結合&lt;/h4&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" title="1"&gt;&lt;span class="ot"&gt;(&amp;lt;/&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;Dir&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; t &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b t&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一引数は &lt;strong&gt;Dir&lt;/strong&gt; で第二引数は &lt;strong&gt;Rel&lt;/strong&gt; が指定されている点に注意してください。そのため、第一引数にファイルへのパスを与えようとするとコンパイルエラーになります。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; (&amp;lt;/&amp;gt;) &amp;lt;$&amp;gt; parseRelDir &amp;quot;a/b/c&amp;quot; &amp;lt;*&amp;gt; parseRelFile &amp;quot;a.png&amp;quot;
&amp;quot;a/b/c/a.png&amp;quot;

&amp;gt; (&amp;lt;/&amp;gt;) &amp;lt;$&amp;gt; parseRelDir &amp;quot;a/b/c&amp;quot; &amp;lt;*&amp;gt; parseRelDir &amp;quot;d&amp;quot;
&amp;quot;a/b/c/d/&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="パスの先頭部分からディレクトリパスを除去"&gt;パスの先頭部分から、ディレクトリパスを除去&lt;/h4&gt;
&lt;p&gt;Data.List の &lt;a href="https://www.stackage.org/haddock/lts-12.7/base-4.11.1.0/Data-List.html#v:stripPrefix"&gt;stripPrefix&lt;/a&gt; 関数と同じように利用できます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb17-1" title="1"&gt;&lt;span class="ot"&gt;stripProperPrefix ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;Dir&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b t &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; t)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; join $ stripProperPrefix &amp;lt;$&amp;gt; parseAbsDir &amp;quot;/usr/local/bin/&amp;quot; &amp;lt;*&amp;gt; parseAbsFile &amp;quot;/usr/local/bin/stack&amp;quot;
&amp;quot;stack&amp;quot;

&amp;gt; join $ stripProperPrefix &amp;lt;$&amp;gt; parseAbsDir &amp;quot;/local/bin/&amp;quot; &amp;lt;*&amp;gt; parseAbsFile &amp;quot;/usr/local/bin/stack&amp;quot;
*** Exception: NotAProperPrefix &amp;quot;/local/bin/&amp;quot; &amp;quot;/usr/local/bin/stack&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="パスから親ディレクトリパスを取得"&gt;パスから親ディレクトリパスを取得&lt;/h4&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb19-1" title="1"&gt;&lt;span class="ot"&gt;parent ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b t &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;Dir&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; parent &amp;lt;$&amp;gt; parseRelFile &amp;quot;ab&amp;quot;
&amp;quot;./&amp;quot;

&amp;gt; parent &amp;lt;$&amp;gt; parseRelFile &amp;quot;./a/b/c/d&amp;quot;
&amp;quot;a/b/c/&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="ディレクトリパスから相対ディレクトリパスを取得"&gt;ディレクトリパスから、相対ディレクトリパスを取得&lt;/h4&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb21-1" title="1"&gt;&lt;span class="ot"&gt;dirname ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;Dir&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;Dir&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; dirname &amp;lt;$&amp;gt; parseAbsDir &amp;quot;/a/b/c/d&amp;quot;
&amp;quot;d/&amp;quot;

&amp;gt; dirname &amp;lt;$&amp;gt; parseRelDir &amp;quot;./a/b/c/d&amp;quot;
&amp;quot;d/&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="ファイルパスから相対ファイルパスを取得"&gt;ファイルパスから相対ファイルパスを取得&lt;/h4&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb23-1" title="1"&gt;&lt;span class="ot"&gt;filename ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; &lt;span class="dt"&gt;Rel&lt;/span&gt; &lt;span class="dt"&gt;File&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; filename &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c/d.png&amp;quot;
&amp;quot;d.png&amp;quot;

&amp;gt; filename &amp;lt;$&amp;gt; parseRelFile &amp;quot;./a/b/c/d.png&amp;quot;
&amp;quot;d.png&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="ファイルパスから拡張子を取得"&gt;ファイルパスから拡張子を取得&lt;/h4&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb25-1" title="1"&gt;&lt;span class="ot"&gt;fileExtension ::&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; fileExtension &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c.png&amp;quot;
&amp;quot;.png&amp;quot;

&amp;gt; fileExtension &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c.png&amp;quot;
&amp;quot;.png&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="ファイルパスに拡張子を追加"&gt;ファイルパスに拡張子を追加&lt;/h4&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb27-1" title="1"&gt;&lt;span class="ot"&gt;addFileExtension ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-3" title="3"&gt;&lt;span class="co"&gt;-- 演算子バージョンとして (&amp;lt;.&amp;gt;) が定義されている&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-4" title="4"&gt;&lt;span class="ot"&gt;(&amp;lt;.&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; join $ addFileExtension &amp;quot;hs&amp;quot; &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c&amp;quot;
&amp;quot;/a/b/c.hs&amp;quot;

&amp;gt; join $ addFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c&amp;quot;
&amp;quot;/a/b/c.hs&amp;quot;

&amp;gt; join $ addFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c&amp;quot;
&amp;quot;a/b/c.hs&amp;quot;

&amp;gt; join $ addFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c.rs&amp;quot;
&amp;quot;a/b/c.rs.hs&amp;quot;

&amp;gt; join $ (&amp;lt;.&amp;gt; &amp;quot;.hs&amp;quot;) &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c.rs&amp;quot;
&amp;quot;a/b/c.rs.hs&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既に拡張子があっても、追加する点に注意。&lt;/p&gt;
&lt;h4 id="ファイルパスに拡張子を追加-既に拡張子がある場合は置き換える"&gt;ファイルパスに拡張子を追加 (既に拡張子がある場合は置き換える)&lt;/h4&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb29-1" title="1"&gt;&lt;span class="ot"&gt;setFileExtension ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-3" title="3"&gt;&lt;span class="co"&gt;-- 演算子バージョンとして (-&amp;lt;.&amp;gt;) が定義されている&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-4" title="4"&gt;&lt;span class="ot"&gt;(-&amp;lt;.&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;MonadThrow&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Path&lt;/span&gt; b &lt;span class="dt"&gt;File&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;&amp;gt; join $ setFileExtension &amp;quot;hs&amp;quot; &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c&amp;quot;
&amp;quot;/a/b/c.hs&amp;quot;

&amp;gt; join $ setFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseAbsFile &amp;quot;/a/b/c&amp;quot;
&amp;quot;/a/b/c.hs&amp;quot;

&amp;gt; join $ setFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c&amp;quot;
&amp;quot;a/b/c.hs&amp;quot;

&amp;gt; join $ setFileExtension &amp;quot;.hs&amp;quot; &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c.rs&amp;quot;
&amp;quot;a/b/c.hs&amp;quot;

&amp;gt; join $ (-&amp;lt;.&amp;gt; &amp;quot;.hs&amp;quot;) &amp;lt;$&amp;gt; parseRelFile &amp;quot;a/b/c.rs&amp;quot;
&amp;quot;a/b/c.hs&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="path-io"&gt;path-io&lt;/h2&gt;
&lt;p&gt;ここまでで &lt;code&gt;Path&lt;/code&gt; 型の定義や値の作り方、操作する関数などを見てきました。&lt;/p&gt;
&lt;p&gt;しかしながら、これだけでは実際にファイルを作ったり削除したりすることはできません。文字列に変換して &lt;code&gt;directory&lt;/code&gt; パッケージを利用することもできますが、やはり &lt;code&gt;Path&lt;/code&gt; 型のまま使いたいですよね。&lt;/p&gt;
&lt;p&gt;そのためには &lt;a href="https://github.com/mrkkrp/path-io"&gt;path-io&lt;/a&gt; パッケージを利用すると良いです。内部的には &lt;code&gt;directory&lt;/code&gt; パッケージを再利用していますが、&lt;code&gt;Path&lt;/code&gt; 型で使えるようにラップしてくれています。(また、便利な関数もいくつか追加されています)&lt;/p&gt;
&lt;h3 id="サンプルプログラム"&gt;サンプルプログラム&lt;/h3&gt;
&lt;p&gt;例えばこんな感じで使えます。以下の例はコマンドライン引数から受け取った文字列に拡張子 &lt;code&gt;.hs&lt;/code&gt; を追加して適当な内容で保存し、最後にディレクトリを再帰的にコピーする例です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb31"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb31-1" title="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-2" title="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-12.7&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-3" title="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-5" title="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Path&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-6" title="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Path.IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-8" title="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Control.Monad&lt;/span&gt; (when)&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-9" title="9"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-11" title="11"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-12" title="12"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-13" title="13"&gt;  args &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-14" title="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-15" title="15"&gt;  when (&lt;span class="fu"&gt;length&lt;/span&gt; args &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-16" title="16"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; src  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(mkRelDir &lt;span class="st"&gt;&amp;quot;./src&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-17" title="17"&gt;        dest &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt;(mkRelDir &lt;span class="st"&gt;&amp;quot;./.backup&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-19" title="19"&gt;    &lt;span class="co"&gt;-- 安全にディレクトリを作成&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-20" title="20"&gt;    &lt;span class="fu"&gt;mapM_&lt;/span&gt; ensureDir [src, dest]&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-21" title="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-22" title="22"&gt;    rawName &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; parseRelFile &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;head&lt;/span&gt; args&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-23" title="23"&gt;    fn &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; (src &lt;span class="fu"&gt;&amp;lt;/&amp;gt;&lt;/span&gt; rawName) &lt;span class="fu"&gt;-&amp;lt;.&amp;gt;&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;hs&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-24" title="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-25" title="25"&gt;    &lt;span class="fu"&gt;writeFile&lt;/span&gt; (toFilePath fn) &lt;span class="st"&gt;&amp;quot;main :: IO ()\nmain = undefined\n&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-26" title="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-27" title="27"&gt;    &lt;span class="co"&gt;-- ディレクトリを再帰的にコピー&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb31-28" title="28"&gt;    copyDirRecur&amp;#39; src dest&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行結果&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Sample.hs aaa

$ tree -a .
.
├── .backup
│   └── aaa.hs
├── Sample.hs
└── src
    └── aaa.hs

2 directories, 3 files

$ cat src/aaa.hs
main :: IO ()
main = undefined

$ cat .backup/aaa.hs
main :: IO ()
main = undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;動いているようです。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filepath&lt;/code&gt; や &lt;code&gt;directory&lt;/code&gt; パッケージでは文字列の操作となってしまうため、コンパイル時に不正な利用方法をチェックできない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; や &lt;code&gt;path-io&lt;/code&gt; は幽霊型を使って不正な利用をコンパイル時にチェックする&lt;/li&gt;
&lt;li&gt;実際に &lt;code&gt;stack&lt;/code&gt; でも利用されているパッケージ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html</id><title type="text">Haskell Servant で GitHub Webhook</title><updated>2018-08-18T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-08-18-haskell-github-webhook.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Haskell Servant で GitHub Webhook&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-08-18" itemprop="datePublished"&gt;
        Aug 18, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/rio.html"&gt;rio&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;久々の投稿． とある事情で GitHub Webhook 用のサーバーを Haskell で書いたのでそのメモ書きです．&lt;/p&gt;
&lt;h2 id="やったこと"&gt;やったこと&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://hackage.haskell.org/package/rio"&gt;rio&lt;/a&gt; のロガーを Servant で使う&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hackage.haskell.org/package/servant-github-webhook"&gt;servant-github-webhook&lt;/a&gt; を使って Webhook 用の Servant サーバーの構築&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実際に書いたコードは&lt;a href="https://github.com/matsubara0507/git-plantation/commit/b93ed3398b30dbba105a580d58e947f131cf1a9a"&gt;この辺り&lt;/a&gt;を見ると良いかな． 色々と途中のうえ，そもそも GitHub Webhook がメインではないリポジトリなので見にくい気がするけど．&lt;/p&gt;
&lt;h2 id="servant-で-rio-モナド"&gt;Servant で rio モナド&lt;/h2&gt;
&lt;p&gt;これはまぁおまけですね． rio はロギングとかが便利なので，先に紹介して以降で利用する．&lt;/p&gt;
&lt;h3 id="ロガーの準備"&gt;ロガーの準備&lt;/h3&gt;
&lt;p&gt;まずはロギング用のモナドを定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds        #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedLabels #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators    #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;logger&amp;quot; &amp;gt;: LogFunc&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;   ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasLogFunc&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;  logFuncL &lt;span class="fu"&gt;=&lt;/span&gt; lens (view &lt;span class="fu"&gt;#&lt;/span&gt;logger) (\x y &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; x &lt;span class="fu"&gt;&amp;amp;&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="ot"&gt;`set`&lt;/span&gt; y)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;いわゆる Has パターンというやつ． これで &lt;code&gt;RIO Env&lt;/code&gt; というのがロガーを扱えるモナドとなる．&lt;/p&gt;
&lt;h3 id="servant-でカスタムモナド"&gt;Servant でカスタムモナド&lt;/h3&gt;
&lt;p&gt;Servent Server のメイン関数は下記のように定義できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Network.Wai.Handler.Warp&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Warp&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Servant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;  logOpts &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; logOptionsHandle stdout &lt;span class="dt"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;  withLogFunc logOpts &lt;span class="fu"&gt;$&lt;/span&gt; \logger &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" data-line-number="11"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; env &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;#&lt;/span&gt;logger &lt;span class="fu"&gt;@=&lt;/span&gt; logger&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" data-line-number="12"&gt;           &lt;span class="fu"&gt;&amp;lt;:&lt;/span&gt;&lt;span class="ot"&gt; nil ::&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" data-line-number="13"&gt;    hPutBuilder stdout &lt;span class="st"&gt;&amp;quot;Listening on port 8080&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" data-line-number="14"&gt;    Warp.run &lt;span class="dv"&gt;8080&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; app env&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-16" data-line-number="16"&gt;&lt;span class="ot"&gt;app ::&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-17" data-line-number="17"&gt;app &lt;span class="fu"&gt;=&lt;/span&gt; undefined&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さて，問題はこの &lt;code&gt;app&lt;/code&gt; 関数だ． 普通は &lt;a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:Server"&gt;&lt;code&gt;Server&lt;/code&gt;&lt;/a&gt; 型と &lt;a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:serve"&gt;&lt;code&gt;serve&lt;/code&gt;&lt;/a&gt; 関数を用いて次のように書く．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;API&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="ot"&gt;api ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="dt"&gt;API&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;api &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="ot"&gt;server ::&lt;/span&gt; &lt;span class="dt"&gt;Server&lt;/span&gt; &lt;span class="dt"&gt;API&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;server &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;&lt;span class="ot"&gt;app ::&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;app &lt;span class="fu"&gt;=&lt;/span&gt;  serve api server&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Server&lt;/code&gt; 型の代わりに，カスタムモナドを利用するには &lt;a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#t:ServerT"&gt;&lt;code&gt;ServerT&lt;/code&gt;&lt;/a&gt; 型と &lt;a href="http://hackage.haskell.org/package/servant-server-0.14.1/docs/Servant-Server.html#v:hoistServer"&gt;&lt;code&gt;hoistServer&lt;/code&gt;&lt;/a&gt; 関数を用いる． それぞれの型定義は次のようになっている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Server&lt;/span&gt; api &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;ServerT&lt;/span&gt; api &lt;span class="dt"&gt;Handler&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="ot"&gt;serve ::&lt;/span&gt; &lt;span class="dt"&gt;HasServer&lt;/span&gt; api &lt;span class="ch"&gt;&amp;#39;[] =&amp;gt; Proxy api -&amp;gt; Server api -&amp;gt; Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="ot"&gt;hoistServer ::&lt;/span&gt; &lt;span class="dt"&gt;HasServer&lt;/span&gt; api &lt;span class="ch"&gt;&amp;#39;[] =&amp;gt; Proxy api -&amp;gt; (forall x. m x -&amp;gt; n x) -&amp;gt; ServerT api m -&amp;gt; ServerT api n&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さぁあとは型パズルだ！&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;server ::&lt;/span&gt; &lt;span class="dt"&gt;ServerT&lt;/span&gt; (&lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;) &lt;span class="dt"&gt;API&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;server &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="ot"&gt;app ::&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;app env &lt;span class="fu"&gt;=&lt;/span&gt; serve api &lt;span class="fu"&gt;$&lt;/span&gt; hoistServer api (runRIO env) server&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで　&lt;code&gt;server&lt;/code&gt; 関数で呼び出す， API ごとの関数で &lt;code&gt;logInfo&lt;/code&gt; のような rio のロギング関数を呼ぶことができる．&lt;/p&gt;
&lt;h2 id="servant-で-github-webhhok"&gt;Servant で GitHub Webhhok&lt;/h2&gt;
&lt;p&gt;さて色々準備ができたので，いよいよ GitHub Webhook の方に話を移す． Haskell Servant で GitHub Webhook を使うには &lt;a href="http://hackage.haskell.org/package/servant-github-webhook"&gt;servant-github-webhook&lt;/a&gt;というパッケージを使う． 意外と，このパッケージの使い方を書いた記事がなく手間取ったのでまとめる．&lt;/p&gt;
&lt;h3 id="ping-api-を作る"&gt;ping API を作る&lt;/h3&gt;
&lt;p&gt;ping API は GitHub Webhook の設定がうまくできてるかを確認する API だ．&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/haskell-github-webhook/ping-event.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;ping API は次のように設定すれば良い．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;GitHub.Data.Webhooks.Events&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Servant&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Servant.GitHub.Webhook&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;API&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;hook&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;WebhookAPI&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;WebhookAPI&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;      &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;GitHubEvent&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;#39;&lt;/span&gt;&lt;span class="dt"&gt;WebhookPingEvent&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubSignedReqBody&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] PublicEvent&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;&lt;span class="ot"&gt;server ::&lt;/span&gt; &lt;span class="dt"&gt;ServerT&lt;/span&gt; (&lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;) &lt;span class="dt"&gt;API&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;server &lt;span class="fu"&gt;=&lt;/span&gt; pingWebhook&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" data-line-number="15"&gt;&lt;span class="ot"&gt;pingWebhook ::&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" data-line-number="16"&gt;  &lt;span class="dt"&gt;RepoWebhookEvent&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; ((), &lt;span class="dt"&gt;PublicEvent&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Plant&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-17" data-line-number="17"&gt;pingWebhook _ (_, ev) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-18" data-line-number="18"&gt;  logInfo &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hook Ping Event: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; displayShow ev&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GitHub Webhook を使うには Servant の Context 機能でシークレットキーを渡す必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" data-line-number="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.Environment&lt;/span&gt;       (getEnv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" data-line-number="3"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" data-line-number="4"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" data-line-number="5"&gt;    &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="fu"&gt;=&lt;/span&gt; gitHubKey &lt;span class="fu"&gt;$&lt;/span&gt; fromString &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getEnv &lt;span class="st"&gt;&amp;quot;GH_SECRET&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" data-line-number="7"&gt;    Warp.run &lt;span class="dv"&gt;8080&lt;/span&gt; &lt;span class="fu"&gt;$&lt;/span&gt; app env key&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" data-line-number="9"&gt;&lt;span class="ot"&gt;app ::&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubKey&lt;/span&gt; &lt;span class="dt"&gt;PublicEvent&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" data-line-number="10"&gt;app env key &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" data-line-number="11"&gt;  serveWithContext api (key &lt;span class="fu"&gt;:.&lt;/span&gt; &lt;span class="dt"&gt;EmptyContext&lt;/span&gt;) &lt;span class="fu"&gt;$&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" data-line-number="12"&gt;    hoistServerWithContext api context (runRIO env) server&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-14" data-line-number="14"&gt;&lt;span class="ot"&gt;context ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ GitHubKey PublicEvent ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-15" data-line-number="15"&gt;context &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実行するときは &lt;code&gt;GH_SECRET&lt;/code&gt; 環境変数に設定した文字列を GitHub Webhook の設定の Secret に書き込む．&lt;/p&gt;
&lt;h3 id="push-api-を加える"&gt;push API を加える&lt;/h3&gt;
&lt;p&gt;もう一個 API を生やしてみよう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;WebhookAPI&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;      &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;GitHubEvent&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;#39;&lt;/span&gt;&lt;span class="dt"&gt;WebhookPingEvent&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubSignedReqBody&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] PublicEvent&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;   &lt;span class="fu"&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubEvent&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ &amp;#39;&lt;/span&gt;&lt;span class="dt"&gt;WebhookPushEvent&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubSignedReqBody&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] PushEvent&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;        &lt;span class="fu"&gt;:&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Post&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[JSON] ()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;&lt;span class="ot"&gt;server ::&lt;/span&gt; &lt;span class="dt"&gt;ServerT&lt;/span&gt; (&lt;span class="dt"&gt;RIO&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt;) &lt;span class="dt"&gt;API&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;server &lt;span class="fu"&gt;=&lt;/span&gt; pingWebhook &lt;span class="fu"&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; pushWebhook&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;&lt;span class="ot"&gt;pushWebhook ::&lt;/span&gt; &lt;span class="dt"&gt;RepoWebhookEvent&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; ((), &lt;span class="dt"&gt;PushEvent&lt;/span&gt;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Plant&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;pushWebhook _ (_, ev) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;  logInfo &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Hook Push Event: &amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; displayShow ev&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これでビルドすると次のようなエラーが出てくる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Main.hs:38:3: error:
    • No instance for (HasContextEntry &amp;#39;[] (GitHubKey&amp;#39; () PushEvent))
        arising from a use of ‘serveWithContext’
    • In the expression: serveWithContext api (key :. EmptyContext)
      In the expression:
        serveWithContext api (key :. EmptyContext)
          $ hoistServerWithContext api context (runRIO env) server
      In an equation for ‘app’:
          app env key
            = serveWithContext api (key :. EmptyContext)
                $ hoistServerWithContext api context (runRIO env) server
   |
38 |   serveWithContext api (key :. EmptyContext) $ hoistServerWithContext api context (runRIO env) server
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://github.com/tsani/servant-github-webhook/issues/13#issuecomment-408463124"&gt;ググった結果&lt;/a&gt;，こうするといいらしい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE MultiParamTypeClasses #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Servant.GitHub.Webhook&lt;/span&gt;    &lt;span class="kw"&gt;hiding&lt;/span&gt; (&lt;span class="dt"&gt;GitHubKey&lt;/span&gt;, gitHubKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Servant.GitHub.Webhook&lt;/span&gt;   (&lt;span class="dt"&gt;GitHubKey&lt;/span&gt;, gitHubKey)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" data-line-number="6"&gt;&lt;span class="ot"&gt;app ::&lt;/span&gt; &lt;span class="dt"&gt;Env&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubKey&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Application&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" data-line-number="7"&gt;app env key &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" data-line-number="9"&gt;&lt;span class="ot"&gt;context ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[ GitHubKey ]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" data-line-number="10"&gt;context &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" data-line-number="12"&gt;&lt;span class="co"&gt;-- HACK&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" data-line-number="13"&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;GitHubKey&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" data-line-number="14"&gt;  &lt;span class="dt"&gt;GitHubKey&lt;/span&gt; (forall result&lt;span class="fu"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Servant.GitHub.Webhook.GitHubKey&lt;/span&gt; result)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" data-line-number="16"&gt;&lt;span class="ot"&gt;gitHubKey ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;GitHubKey&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" data-line-number="17"&gt;gitHubKey k &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;GitHubKey&lt;/span&gt; (Servant.GitHub.Webhook.gitHubKey k)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" data-line-number="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-19" data-line-number="19"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasContextEntry&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;[GitHubKey] (Servant.GitHub.Webhook.GitHubKey result) where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-20" data-line-number="20"&gt;  getContextEntry (&lt;span class="dt"&gt;GitHubKey&lt;/span&gt; x &lt;span class="fu"&gt;:.&lt;/span&gt; _) &lt;span class="fu"&gt;=&lt;/span&gt; x&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;ちなみに，手元で試すときには ngrok を使った． 便利．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/08-12-quiz-16.html</id><title type="text">二分木の操作 (Haskell Quiz No.16)</title><updated>2018-08-12T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/08-12-quiz-16.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.16"&gt;Haskell Quiz No.16&lt;/h2&gt;
&lt;p&gt;難易度: λλ&lt;/p&gt;
&lt;p&gt;以下のような二分木の定義があります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Leaf&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; (&lt;span class="dt"&gt;Tree&lt;/span&gt; a) (&lt;span class="dt"&gt;Tree&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下の操作を定義してみましょう！&lt;/p&gt;
&lt;h3 id="部分木を左右反転させた木を返す関数"&gt;(1) 部分木を左右反転させた木を返す関数&lt;/h3&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="ot"&gt;mirror ::&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;mirror &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;undefined&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="mirror 関数適用前"&gt; → &lt;img style="width: 45%" src="/images/2018/08-12/mirror_after.svg" alt="mirror 関数適用後"&gt;&lt;/p&gt;
&lt;p&gt;左の木に &lt;strong&gt;mirror&lt;/strong&gt; 関数を適用すると、右の木を返します。&lt;/p&gt;
&lt;h3 id="木の高さを計算する関数"&gt;(2) 木の高さを計算する関数&lt;/h3&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="ot"&gt;depth ::&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;depth &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;undefined&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="depth"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;depth&lt;/strong&gt; 関数で上記の木の高さを計算すると &lt;strong&gt;3&lt;/strong&gt; になります。&lt;/p&gt;
&lt;h3 id="木が平衡かチェックする関数"&gt;(3) 木が平衡かチェックする関数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;平衡の定義: 左右の部分木の高さが高々1しか違わない&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="ot"&gt;isBalanced ::&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;isBalanced &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;undefined&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="isBalanced"&gt;&lt;/p&gt;
&lt;p&gt;上記の木は &lt;strong&gt;平衡&lt;/strong&gt; です。&lt;/p&gt;
&lt;p&gt;さらに &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#t:Functor"&gt;Functor&lt;/a&gt; と &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#t:Foldable"&gt;Foldable&lt;/a&gt; のインスタンスを定義してみましょう！(ここでは &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#v:fmap"&gt;fmap&lt;/a&gt; と &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#v:foldMap"&gt;foldMap&lt;/a&gt; を定義することにします。)&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Functor&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="ot"&gt;  fmap ::&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; b&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;  &lt;span class="fu"&gt;fmap&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;undefined&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Foldable&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;&lt;span class="ot"&gt;  foldMap ::&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;  &lt;span class="fu"&gt;foldMap&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;undefined&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;答えは次回。&lt;/p&gt;
&lt;p&gt;※ 図の作成には &lt;a href="https://mermaidjs.github.io/"&gt;mermaid&lt;/a&gt;というツールを使っています。&lt;/p&gt;
&lt;h3 id="参考"&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Programming in Haskell (14.2 Foldables and friends)&lt;/li&gt;
&lt;li&gt;関数プログラミング入門 Haskell で学ぶ原理と技法 (8.3.2 木による表現)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cis.syr.edu/courses/cis623/p2.html"&gt;CIS 623&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./07-24-quiz-15.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;葉に&lt;strong&gt;だけ&lt;/strong&gt;値を持つような&lt;strong&gt;二分木&lt;/strong&gt;を定義してみてください！&lt;/p&gt;
&lt;p&gt;図で書くとこんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/2018/07-24/tree.svg" alt="木の図" width="50%"&gt;&lt;/p&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;&lt;span class="co"&gt;-- より一般的な定義&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" title="6"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" title="7"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Leaf&lt;/span&gt; a&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" title="8"&gt;  &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; (&lt;span class="dt"&gt;Tree&lt;/span&gt; a) (&lt;span class="dt"&gt;Tree&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;この定義を使って図の木を作るとこんな感じになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="ot"&gt;t ::&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;t &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; t1 t3&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" title="4"&gt;    t1 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;) t2&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" title="5"&gt;    t2 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;) (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" title="6"&gt;    t3 &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Node&lt;/span&gt; (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;) (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;where&lt;/strong&gt; を使わない場合はこんな感じです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;intTree ::&lt;/span&gt; &lt;span class="dt"&gt;Tree&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;intTree &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;  &lt;span class="dt"&gt;Node&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;    (&lt;span class="dt"&gt;Node&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;      (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" title="6"&gt;      (&lt;span class="dt"&gt;Node&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" title="7"&gt;        (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" title="8"&gt;        (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt;)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" title="9"&gt;    (&lt;span class="dt"&gt;Node&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" title="10"&gt;      (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;4&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" title="11"&gt;      (&lt;span class="dt"&gt;Leaf&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/08-07-arrow-operators.html</id><title type="text">(^&gt;&gt;) と (&gt;&gt;^)</title><updated>2018-08-07T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/08-07-arrow-operators.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#"&gt;Control.Arrow&lt;/a&gt; モジュールに &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#v:-94--62--62-"&gt;(^&amp;gt;&amp;gt;)&lt;/a&gt; と &lt;a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#v:-62--62--94-"&gt;(&amp;gt;&amp;gt;^)&lt;/a&gt; という演算子が定義されています。&lt;/p&gt;
&lt;p&gt;ちょっとだけ面白かったので紹介しようと思います。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="準備"&gt;準備&lt;/h2&gt;
&lt;p&gt;例として、文字列を全て&lt;strong&gt;大文字&lt;/strong&gt;に変換する関数を考えてみましょう。&lt;/p&gt;
&lt;p&gt;素朴に書けばこんな感じでしょうか。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;Data.Char&lt;/span&gt; (toUpper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="ot"&gt;toAllUpper ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;toAllUpper &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;map&lt;/span&gt; &lt;span class="fu"&gt;toUpper&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数は以下のように期待通りに動きます。&lt;/p&gt;
&lt;pre class="shell"&gt;&lt;code&gt;*Main&amp;gt; toAllUpper &amp;quot;B|g0on&amp;quot;
&amp;quot;B|G0ON&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ではここで、同じように &lt;code&gt;Text&lt;/code&gt; バージョンを作りたいと思います。何も考えずに pack と unpack を使えばすぐ定義できますね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Char&lt;/span&gt; (toUpper)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Text&lt;/span&gt; (&lt;span class="dt"&gt;Text&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Text&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;T&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" title="5"&gt;&lt;span class="ot"&gt;toAllUpper ::&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" title="6"&gt;toAllUpper &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;map&lt;/span&gt; &lt;span class="fu"&gt;toUpper&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" title="8"&gt;&lt;span class="ot"&gt;toAllUpperText ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" title="9"&gt;toAllUpperText &lt;span class="fu"&gt;=&lt;/span&gt; T.pack &lt;span class="fu"&gt;.&lt;/span&gt; toAllUpper &lt;span class="fu"&gt;.&lt;/span&gt; T.unpack&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数も同様にちゃんと動きます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; toAllUpperText &lt;span class="fu"&gt;$&lt;/span&gt; T.pack &lt;span class="st"&gt;&amp;quot;B|g0on&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;span class="st"&gt;&amp;quot;B|G0ON&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="と-を無理矢理使ってみる"&gt;(^&amp;gt;&amp;gt;) と (&amp;gt;&amp;gt;^) を無理矢理使ってみる&lt;/h2&gt;
&lt;p&gt;先程定義した &lt;code&gt;toAllUpperText&lt;/code&gt; 関数は &lt;code&gt;(^&amp;gt;&amp;gt;)&lt;/code&gt; と &lt;code&gt;(&amp;gt;&amp;gt;^)&lt;/code&gt; を使って、以下のように書き直すことができます。(&lt;code&gt;Control.Arrow&lt;/code&gt; をインポートする必要があります。)&lt;/p&gt;
&lt;p&gt;左から右バージョン&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="ot"&gt;toAllUpperText&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;toAllUpperText&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; T.unpack &lt;span class="fu"&gt;^&amp;gt;&amp;gt;&lt;/span&gt; toAllUpper &lt;span class="fu"&gt;&amp;gt;&amp;gt;^&lt;/span&gt; T.pack&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右から左バージョン&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="ot"&gt;toAllUpperText&amp;#39;&amp;#39; ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;toAllUpperText&amp;#39;&amp;#39; &lt;span class="fu"&gt;=&lt;/span&gt; T.pack &lt;span class="fu"&gt;&amp;lt;&amp;lt;^&lt;/span&gt; toAllUpper &lt;span class="fu"&gt;^&amp;lt;&amp;lt;&lt;/span&gt; T.unpack&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;関数合成 (&lt;code&gt;.&lt;/code&gt;) を単純に置き換えただけです・・・。&lt;/p&gt;
&lt;h3 id="型"&gt;型&lt;/h3&gt;
&lt;p&gt;この演算子の何が面白いかと言うと、&lt;strong&gt;入力&lt;/strong&gt;と&lt;strong&gt;出力&lt;/strong&gt;をそれぞれ変換できるんですね！&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="ot"&gt;(^&amp;gt;&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Arrow&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a c d &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b d&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;&lt;span class="ot"&gt;(&amp;gt;&amp;gt;^) ::&lt;/span&gt; &lt;span class="dt"&gt;Arrow&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a b c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b d&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;(&amp;lt;&amp;lt;^) ::&lt;/span&gt; &lt;span class="dt"&gt;Arrow&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; a c d &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b d&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;&lt;span class="ot"&gt;(^&amp;lt;&amp;lt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Arrow&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b d&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先程の例は &lt;code&gt;Arrow a&lt;/code&gt; の &lt;code&gt;a&lt;/code&gt; を関数型 &lt;code&gt;(-&amp;gt;)&lt;/code&gt; として具体化したものになります。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="ot"&gt;(^&amp;gt;&amp;gt;) ::&lt;/span&gt; &lt;span class="dt"&gt;Arrow&lt;/span&gt; a &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a c d &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; a b d&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;  &lt;span class="co"&gt;-- a = (-&amp;gt;) として具体化した&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;    (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;) c d &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt;) b d&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引数の順番を逆にすれば関数合成の型と同じですね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;  &lt;span class="co"&gt;-- 引数を逆にした&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;  (c &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; d)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;  &lt;span class="co"&gt;-- 変数名の変更&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" title="5"&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" title="7"&gt;&lt;span class="ot"&gt;(.) ::&lt;/span&gt; (b &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; c)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;現実世界で Arrow をバリバリ使っているコードをみかけることは (僕は) 全く無いです。(Hakyll は過去に Arrow ベースで定義されていたようですが、Monad ベースに切り替わりました)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;たぶん使うことは無いですが、パズルみたいで楽しい。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/07-31-yesodsecurity.html</id><title type="text">Yesod には脆弱性があるのかな？</title><updated>2018-07-31T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/07-31-yesodsecurity.html"/><summary type="html">&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.yesodweb.com/"&gt;Yesod&lt;/a&gt; は Haskell で書かれた Web アプリケーションフレームワークです。&lt;/p&gt;
&lt;p&gt;WordPress や Drupal と違って、セキュリティはかなり万全です。(ユーザが気にしなければならない部分が非常に少ないです)&lt;/p&gt;
&lt;p&gt;最近、&lt;a href="https://www.sbcr.jp/products/4797393163.html"&gt;体系的に学ぶ 安全なWebアプリケーションの作り方 第2版 (通称: 徳丸本)&lt;/a&gt; が発売されました。&lt;/p&gt;
&lt;p&gt;勉強のため、本書の内容を Yesod で確認しているのですが、その中で面白い例を見つけました。&lt;/p&gt;
&lt;p&gt;今回はその内容について紹介したいと思います。(セキュリティの専門家ではないので間違いがあればご指摘ください)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="脆弱性のあるコード"&gt;脆弱性のあるコード&lt;/h2&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-12.4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings     #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="ot"&gt;{-# LANGUAGE QuasiQuotes           #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell       #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeFamilies          #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Yesod&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;App&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;App&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;mkYesod &lt;span class="st"&gt;&amp;quot;App&amp;quot;&lt;/span&gt; [parseRoutes|&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;/ HomeR GET&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;|]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Yesod&lt;/span&gt; &lt;span class="dt"&gt;App&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" title="17"&gt;&lt;span class="ot"&gt;getHomeR ::&lt;/span&gt; &lt;span class="dt"&gt;Handler&lt;/span&gt; &lt;span class="dt"&gt;Html&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" title="18"&gt;getHomeR &lt;span class="fu"&gt;=&lt;/span&gt; defaultLayout &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" title="19"&gt;  mname &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lookupGetParam &lt;span class="st"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" title="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" title="21"&gt;  [whamlet|&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" title="22"&gt;    &lt;span class="kw"&gt;$maybe&lt;/span&gt; name &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mname&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" title="23"&gt;      &lt;span class="kw"&gt;&amp;lt;img&lt;/span&gt;&lt;span class="ot"&gt; onload=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;#{name}&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; src=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;https://www.yesodweb.com/static/logo-home2-no-esod-smaller2.png&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" title="24"&gt;    &lt;span class="kw"&gt;$nothing&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" title="25"&gt;      パラメータが設定されていません。&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" title="26"&gt;  |]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" title="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" title="28"&gt;  toWidget [julius|&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" title="29"&gt;    &lt;span class="kw"&gt;function&lt;/span&gt; &lt;span class="at"&gt;init&lt;/span&gt;(text) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" title="30"&gt;      &lt;span class="co"&gt;// 何かしらの処理&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-31" title="31"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-32" title="32"&gt;  |]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-33" title="33"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-34" title="34"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-35" title="35"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; warp &lt;span class="dv"&gt;3000&lt;/span&gt; &lt;span class="dt"&gt;App&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このコードには脆弱性があります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yesod&lt;/strong&gt; の変数展開 &lt;code&gt;#{..}&lt;/code&gt; は、このような &lt;strong&gt;JavaScript&lt;/strong&gt; の動的生成でも大丈夫だろうと思っていたのですが、そうではありませんでした。&lt;/p&gt;
&lt;h3 id="正常系"&gt;正常系&lt;/h3&gt;
&lt;p&gt;期待する動作として、例えば &lt;code&gt;http://localhost/?name=bigmoon&lt;/code&gt; いう形式の &lt;strong&gt;URL&lt;/strong&gt; にアクセスすると、以下のような URL が組み立てられます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode html"&gt;&lt;code class="sourceCode html"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="kw"&gt;&amp;lt;img&lt;/span&gt;&lt;span class="ot"&gt; onload=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;bigmoon&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; src=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これは予定通りです。&lt;/p&gt;
&lt;h3 id="異常系"&gt;異常系&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;URL&lt;/strong&gt; の形式を &lt;code&gt;http://localhost/?name=%27),alert(XSS)//&lt;/code&gt; とするとインジェクションが発生します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode html"&gt;&lt;code class="sourceCode html"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;&amp;lt;img&lt;/span&gt;&lt;span class="ot"&gt; onload=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;%27),alert(XSS)//&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; src=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;読みやすさのため、パーセントエンコーディングを元に戻します。&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode html"&gt;&lt;code class="sourceCode html"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="kw"&gt;&amp;lt;img&lt;/span&gt;&lt;span class="ot"&gt; onload=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;&amp;#39;),alert(XSS)//&amp;#39;)&amp;quot;&lt;/span&gt;&lt;span class="ot"&gt; src=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&lt;span class="kw"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;alert&lt;/code&gt; が出てきてしまいましたね・・・。&lt;/p&gt;
&lt;p&gt;余談ですが &lt;strong&gt;Yesod&lt;/strong&gt; ではパラメータ中に出現する &lt;code&gt;;&lt;/code&gt; をパラメータの区切り文字として認識するようです。そのため &lt;code&gt;http://localhost/?name=%27);alert(XSS)//&lt;/code&gt; ではインジェクションは発生しません。&lt;/p&gt;
&lt;h2 id="原因"&gt;原因&lt;/h2&gt;
&lt;p&gt;問題はどこにあるのでしょうか？&lt;/p&gt;
&lt;p&gt;パラメータを取得しているコードはこの部分です。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;mname &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; lookupGetParam &lt;span class="st"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/haddock/lts-12.4/yesod-core-1.6.6/Yesod-Core-Handler.html#v:lookupGetParam"&gt;lookupGetParam&lt;/a&gt; の型は以下の通りです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="ot"&gt;lookupGetParam ::&lt;/span&gt; &lt;span class="dt"&gt;MonadHandler&lt;/span&gt; m &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;つまり、&lt;code&gt;mname :: Maybe Text&lt;/code&gt; 型となってしまいます。ここが問題の原因です。&lt;/p&gt;
&lt;p&gt;ただの &lt;strong&gt;Text&lt;/strong&gt; 型なので変数展開時に &lt;strong&gt;HTMLのエスケープ処理&lt;/strong&gt; が行われます。本来ならば &lt;strong&gt;JavaScript&lt;/strong&gt; 用のエスケープ処理が必要なのです。&lt;/p&gt;
&lt;h2 id="展開部分を改良してみる"&gt;展開部分を改良してみる&lt;/h2&gt;
&lt;p&gt;では &lt;strong&gt;Javascript&lt;/strong&gt; 型に変換すれば問題は解決するのでしょうか？&lt;/p&gt;
&lt;p&gt;試しに以下のようにコードを変更してみました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;img onload&lt;span class="fu"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;#{renderJavascript $ toJavascript $ rawJS $ name}&amp;#39;)&amp;quot;&lt;/span&gt; src&lt;span class="fu"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ですが、やはり結果は同じです。&lt;/p&gt;
&lt;h2 id="エスケープ処理"&gt;エスケープ処理&lt;/h2&gt;
&lt;p&gt;ソースコードを追いかけてみるとどうやら &lt;strong&gt;Value&lt;/strong&gt; の値については &lt;a href="https://www.stackage.org/haddock/lts-12.4/shakespeare-2.0.15/src/Text.Julius.html#string"&gt;string&lt;/a&gt; というサニタイザーが適用されるようです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;string ::&lt;/span&gt; &lt;span class="dt"&gt;T.Text&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Builder&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;string s &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="ot"&gt;{-# SCC &amp;quot;string&amp;quot; #-}&lt;/span&gt; singleton &lt;span class="ch"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; quote s &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; singleton &lt;span class="ch"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;  &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;    quote q &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; T.uncons t &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;                &lt;span class="dt"&gt;Nothing&lt;/span&gt;      &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; fromText h&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" title="6"&gt;                &lt;span class="dt"&gt;Just&lt;/span&gt; (&lt;span class="fu"&gt;!&lt;/span&gt;c,t&amp;#39;) &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; fromText h &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; escape c &lt;span class="fu"&gt;&amp;lt;&amp;gt;&lt;/span&gt; quote t&amp;#39;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" title="7"&gt;        &lt;span class="kw"&gt;where&lt;/span&gt; (h,t) &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="ot"&gt;{-# SCC &amp;quot;break&amp;quot; #-}&lt;/span&gt; T.break isEscape q&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" title="8"&gt;    isEscape c &lt;span class="fu"&gt;=&lt;/span&gt; c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" title="9"&gt;                 c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\\&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" title="10"&gt;                 c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" title="11"&gt;                 c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" title="12"&gt;                 c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" title="13"&gt;                 c &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\x20&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" title="14"&gt;    escape &lt;span class="ch"&gt;&amp;#39;\&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" title="15"&gt;    escape &lt;span class="ch"&gt;&amp;#39;\\&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\\&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-16" title="16"&gt;    escape &lt;span class="ch"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\n&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-17" title="17"&gt;    escape &lt;span class="ch"&gt;&amp;#39;\r&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\r&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-18" title="18"&gt;    escape &lt;span class="ch"&gt;&amp;#39;\t&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\t&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-19" title="19"&gt;    escape &lt;span class="ch"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u003c&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-20" title="20"&gt;    escape &lt;span class="ch"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u003e&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-21" title="21"&gt;    escape &lt;span class="ch"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u0026&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-22" title="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-23" title="23"&gt;    escape c&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-24" title="24"&gt;        &lt;span class="fu"&gt;|&lt;/span&gt; c &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\x20&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; fromString &lt;span class="fu"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; &lt;span class="fu"&gt;replicate&lt;/span&gt; (&lt;span class="dv"&gt;4&lt;/span&gt; &lt;span class="fu"&gt;-&lt;/span&gt; &lt;span class="fu"&gt;length&lt;/span&gt; h) &lt;span class="ch"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;++&lt;/span&gt; h&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-25" title="25"&gt;        &lt;span class="fu"&gt;|&lt;/span&gt; &lt;span class="fu"&gt;otherwise&lt;/span&gt;  &lt;span class="fu"&gt;=&lt;/span&gt; singleton c&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-26" title="26"&gt;        &lt;span class="kw"&gt;where&lt;/span&gt; h &lt;span class="fu"&gt;=&lt;/span&gt; showHex (&lt;span class="fu"&gt;fromEnum&lt;/span&gt; c) &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なので、先程のコードを少し修正してこの &lt;code&gt;string&lt;/code&gt; を適用してみました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="fu"&gt;&amp;lt;&lt;/span&gt;img onload&lt;span class="fu"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;init(&amp;#39;#{renderJavascript $ toJavascript $ rawJS $ string $ name}&amp;#39;)&amp;quot;&lt;/span&gt; src&lt;span class="fu"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;しかし、これでもやっぱりだめです。なぜなら &lt;code&gt;'&lt;/code&gt; に対してはサニタイズしていないからだと思います。&lt;/p&gt;
&lt;h3 id="string-関数の修正"&gt;string 関数の修正&lt;/h3&gt;
&lt;p&gt;以下のように &lt;code&gt;'&lt;/code&gt; のエスケープ処理を追加したところ、インジェクションが発生しなくなりました。&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;isEscape c &lt;span class="fu"&gt;=&lt;/span&gt; c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;             c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\\&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;             c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;             c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" title="5"&gt;             c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt;  &lt;span class="fu"&gt;||&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" title="6"&gt;             c &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;||&lt;/span&gt; &lt;span class="co"&gt;-- 追記&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" title="7"&gt;             c &lt;span class="fu"&gt;&amp;lt;&lt;/span&gt; &lt;span class="ch"&gt;&amp;#39;\x20&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" title="9"&gt;escape &lt;span class="ch"&gt;&amp;#39;\&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" title="10"&gt;escape &lt;span class="ch"&gt;&amp;#39;\\&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\\&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" title="11"&gt;escape &lt;span class="ch"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\n&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" title="12"&gt;escape &lt;span class="ch"&gt;&amp;#39;\r&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\r&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" title="13"&gt;escape &lt;span class="ch"&gt;&amp;#39;\t&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\t&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" title="14"&gt;escape &lt;span class="ch"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u003c&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" title="15"&gt;escape &lt;span class="ch"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u003e&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" title="16"&gt;escape &lt;span class="ch"&gt;&amp;#39;&amp;amp;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\u0026&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" title="17"&gt;&lt;span class="co"&gt;-- 追記&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" title="18"&gt;escape &lt;span class="ch"&gt;&amp;#39;\&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;\\\&amp;#39;&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript&lt;/strong&gt; を動的に組み立てない&lt;/li&gt;
&lt;li&gt;ユーザが気をつけなけば &lt;strong&gt;Yesod&lt;/strong&gt; でも脆弱性が発生する&lt;/li&gt;
&lt;li&gt;変数展開で全てがエスケープされると思っていたが、場所によってはそれだけでは不十分な場合がある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://haskell.e-bigmoon.com/posts/2018/07-24-quiz-15.html</id><title type="text">二分木 (Haskell Quiz No.15)</title><updated>2018-07-24T00:00:00Z</updated><author><name>e-bigmoon</name></author><link href="https://haskell.e-bigmoon.com/posts/2018/07-24-quiz-15.html"/><summary type="html">&lt;h2 id="haskell-quiz-no.15"&gt;Haskell Quiz No.15&lt;/h2&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;葉に&lt;strong&gt;だけ&lt;/strong&gt;値を持つような&lt;strong&gt;二分木&lt;/strong&gt;を定義してみてください！&lt;/p&gt;
&lt;p&gt;図で書くとこんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/2018/07-24/tree.svg" alt="木の図" width="50%"&gt;&lt;/p&gt;
&lt;p&gt;答えは&lt;a href="./08-12-quiz-16.html"&gt;次回&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;この図は &lt;strong&gt;mermaid&lt;/strong&gt; というツールを使って書きました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://mermaidjs.github.io/"&gt;mermaid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbkEoKE5vZGUpKVxuQSAtLT4gQjEoKE5vZGUpKVxuQjEgLS0-IEMxW0xlYWYgMV1cbkIxIC0tPiBEMSgoTm9kZSkpXG5EMSAtLT4gRTFbTGVhZiAyXVxuRDEgLS0-IEUyW0xlYWYgM11cblxuQSAtLT4gQjIoKE5vZGUpKVxuQjIgLS0-IEMyW0xlYWYgNF1cbkIyIC0tPiBDM1tMZWFmIDVdIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9fQ"&gt;Mermaid Live Editor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id="はじめに"&gt;はじめに&lt;/h2&gt;
&lt;p&gt;&lt;a href="./07-16-quiz-14.html"&gt;前回&lt;/a&gt;の問題と答えは以下の通りです。&lt;/p&gt;
&lt;h3 id="問題"&gt;問題&lt;/h3&gt;
&lt;p&gt;難易度: λ&lt;/p&gt;
&lt;p&gt;&lt;code&gt;utf8.txt&lt;/code&gt; と &lt;code&gt;shift-jis.txt&lt;/code&gt; はそれぞれ &lt;code&gt;utf8&lt;/code&gt; と &lt;code&gt;shift-jis&lt;/code&gt; で保存されたテキストファイルです。&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="ot"&gt;bad ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;bad &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;readFile&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;./shift-jis.txt&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="ot"&gt;good ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;good &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;readFile&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;./utf8.txt&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上記のプログラムを実行すると、こんな感じでエラーになってしまいます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; good&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;はすける&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;span class="fu"&gt;*&lt;/span&gt;&lt;span class="dt"&gt;Main&lt;/span&gt;&lt;span class="fu"&gt;&amp;gt;&lt;/span&gt; bad&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;span class="fu"&gt;***&lt;/span&gt; &lt;span class="dt"&gt;Exception&lt;/span&gt;&lt;span class="fu"&gt;:&lt;/span&gt; &lt;span class="fu"&gt;./&lt;/span&gt;shift&lt;span class="fu"&gt;-&lt;/span&gt;jis&lt;span class="fu"&gt;.&lt;/span&gt;txt&lt;span class="fu"&gt;:&lt;/span&gt; hGetContents&lt;span class="fu"&gt;:&lt;/span&gt; invalid argument (invalid byte &lt;span class="fu"&gt;sequence&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;shift-jis&lt;/code&gt; で保存されたテキストファイルを読むにはどうしたら良いでしょうか？&lt;/p&gt;
&lt;h3 id="こたえ"&gt;こたえ&lt;/h3&gt;
&lt;p&gt;色々ありそうですが、ここでは &lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/GHC-IO-Handle.html#v:hSetEncoding"&gt;hSetEncoding&lt;/a&gt; を使う方法を解答の一例としておきます。&lt;/p&gt;
&lt;p&gt;ここでは Windows で保存された &lt;strong&gt;shift-jis&lt;/strong&gt; を扱うために &lt;code&gt;cp932&lt;/code&gt; にしていますが、通常の &lt;strong&gt;shift-jis&lt;/strong&gt; であれば &lt;code&gt;mkTextEncoding &amp;quot;shift-jis&amp;quot;&lt;/code&gt; で大丈夫です。(たぶん)&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-12.2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" title="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.IO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" title="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" title="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" title="8"&gt;  h &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; openFile &lt;span class="st"&gt;&amp;quot;./shift-jis.txt&amp;quot;&lt;/span&gt; &lt;span class="dt"&gt;ReadMode&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" title="9"&gt;  cp932 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mkTextEncoding &lt;span class="st"&gt;&amp;quot;cp932&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" title="10"&gt;  hSetEncoding h cp932&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" title="11"&gt;  content &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; hGetContents h&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" title="13"&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; content&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="shell"&gt;&lt;code&gt;$ ./Ans1.hs
はすける&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/package/extra"&gt;extra&lt;/a&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-12.2/extra-1.6.9/System-IO-Extra.html#v:readFileEncoding"&gt;readFileEncoding&lt;/a&gt; を使えばもっとすっきり書くことができます。&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="ot"&gt;#!/usr/bin/env stack&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="co"&gt;-- stack script --resolver lts-12.2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;System.IO.Extra&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" title="8"&gt;  cp932 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mkTextEncoding &lt;span class="st"&gt;&amp;quot;cp932&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" title="9"&gt;  content &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readFileEncoding cp932 &lt;span class="st"&gt;&amp;quot;./shift-jis.txt&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" title="10"&gt;  &lt;span class="fu"&gt;putStrLn&lt;/span&gt; content&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="解説"&gt;解説&lt;/h3&gt;
&lt;p&gt;理解を深めるために &lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/Prelude.html#v:readFile"&gt;readFile&lt;/a&gt; 関数がどのように定義されているか確認してみましょう！&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="fu"&gt;readFile&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;&lt;span class="fu"&gt;readFile&lt;/span&gt; name &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;  h &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; openFile name &lt;span class="dt"&gt;ReadMode&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;  hGetContents h&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なるほど。&lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:ReadMode"&gt;ReadMode&lt;/a&gt; でファイルハンドルを取得し、&lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:hGetContents"&gt;hGetContents&lt;/a&gt; でファイルの内容を返しているようです。&lt;/p&gt;
&lt;p&gt;解答例ではこの処理の間に &lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:mkTextEncoding"&gt;mkTextEncoding&lt;/a&gt; と &lt;a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:hSetEncoding"&gt;hSetEncoding&lt;/a&gt; を使った処理を挟んでいましたね。&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;  cp932 &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; mkTextEncoding &lt;span class="st"&gt;&amp;quot;cp932&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;  hSetEncoding h cp932&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この処理によって、&lt;strong&gt;shift-jis&lt;/strong&gt; で保存されたファイルの内容を &lt;strong&gt;String&lt;/strong&gt; 型の文字列として扱うことができるようになります。&lt;/p&gt;
&lt;h4 id="readfileencoding"&gt;readFileEncoding&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.stackage.org/package/extra"&gt;extra&lt;/a&gt; パッケージの &lt;a href="https://www.stackage.org/haddock/lts-12.2/extra-1.6.9/System-IO-Extra.html#v:readFileEncoding"&gt;readFileEncoding&lt;/a&gt; の定義は以下のようになっています。&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="ot"&gt;readFileEncoding ::&lt;/span&gt; &lt;span class="dt"&gt;TextEncoding&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;FilePath&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;readFileEncoding enc file &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;  h &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; openFile file &lt;span class="dt"&gt;ReadMode&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;  hSetEncoding h enc&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;  hGetContents h&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;便利ですね！&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mkTextEncoding&lt;/strong&gt; で &lt;strong&gt;TextEncoding&lt;/strong&gt; 型の値を作ることができる&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hSetEncoding&lt;/strong&gt; を利用すればエンコードを指定してファイルの内容を読み込むことができる&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra&lt;/strong&gt; パッケージで提供されている &lt;strong&gt;readFileEncoding&lt;/strong&gt; はそれらの処理を良い感じにまとめてくれる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実際の開発において &lt;strong&gt;readFile&lt;/strong&gt; のような (&lt;strong&gt;getContents&lt;/strong&gt; 系の関数) を使うことは少ないと思います。しかし、何か動くものを &lt;strong&gt;Haskell&lt;/strong&gt; で作ってみたいと思っている人は、とりあえず気にせず使いましょう。(ストリーミングライブラリの知識があればそっちを使った方が良いです)&lt;/p&gt;
&lt;p&gt;Haskell はリファクタリングの得意な言語ですから、問題として認識したときに修正すれば良いと思います。&lt;/p&gt;
&lt;p&gt;IO の処理については &lt;a href="http://gihyo.jp/book/2017/978-4-7741-9237-6"&gt;Haskell入門 関数型プログラミング言語の基礎と実践&lt;/a&gt; の4章, &lt;a href="https://www.oreilly.co.jp/books/9784873114231/"&gt;Read World Haskell&lt;/a&gt; の7章で詳しく解説されているので、興味を持った方はそちらも参照してみると良いかもしれません。&lt;/p&gt;
&lt;p&gt;以上です。&lt;/p&gt;</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html</id><title type="text">Ruby Hack Challenge ＃4 に参加してきた</title><updated>2018-07-01T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-07-01-join-ruby-hack-challenge4.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Ruby Hack Challenge ＃4 に参加してきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-07-01" itemprop="datePublished"&gt;
        Jul 1, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Ruby.html"&gt;Ruby&lt;/a&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先週 &lt;a href="https://cookpad.connpass.com/event/88471/"&gt;Ruby Hack Cavalage #4&lt;/a&gt; に参加してきたので，そのメモ書きです．&lt;/p&gt;
&lt;p&gt;ちなみに，Ruby は自分が最初に触ったスクリプト言語で，現在仕事で使っているメインの言語です． 推し言語(Haskell)とは異なり，動的型付けではありますが，「&lt;a href="http://i.loveruby.net/ja/rhg/book/"&gt;Rubyソースコード完全解説&lt;/a&gt;」や「&lt;a href="https://tatsu-zine.com/books/ruby-under-a-microscope-ja"&gt;Rubyのしくみ&lt;/a&gt;」のような処理系内部を紹介してる読み物も多く，かなり好きな方な言語です.&lt;/p&gt;
&lt;h2 id="ruby-hack-challenge"&gt;Ruby Hack Challenge&lt;/h2&gt;
&lt;p&gt;Ruby 処理系をハックしようというイベントで，コアコミッタの &lt;a href="https://github.com/mame"&gt;mame&lt;/a&gt; 氏と &lt;a href="https://github.com/ko1"&gt;ko1&lt;/a&gt; 氏が講師として企画してくれている． ふたりが在籍しているということで，会場はクックパッドで行っている．&lt;/p&gt;
&lt;p&gt;毎回，前半に講義的なものがあり，後半で実際に手を動かして Ruby にコミットするといった感じらしい． ただし，2日開催だったり，半日だったり時間はまちまち(今回は半日だった)． イベント名的に Ruby のハッカソンみたいだが，Ruby 処理系はC言語で書かれているためC言語を書くことになる(笑)&lt;/p&gt;
&lt;h3 id="カバレッジ特別会"&gt;カバレッジ特別会&lt;/h3&gt;
&lt;p&gt;しかし，4回目(となっているが3回目が見当たらないので3回目かも？？)となる今回は，カバレッジ特別会ということで多くの人たちが Ruby を読み書きしていた． なぜかというと，標準ライブラリは Ruby で書かれており，今回は標準ライブラリのテストカバレッジをあげても良かったからだ． というか，C で書かれているコア部分は mame 氏が昔に大分カバレッジをあげてしまったため，そっちをやるのは難しいと言っていた．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;C言語の部分で残っているとすれば本質的に難しい部分(副作用とか並行並列とか)か最近追加された部分か(JITとか？)だそうだ．&lt;/p&gt;
&lt;h3 id="資料"&gt;資料&lt;/h3&gt;
&lt;p&gt;今までのも含め，資料は(いくつか？)公開されているので誰でも見れる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ko1/rubyhackchallenge"&gt;ko1/rubyhackchallenge - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.slideshare.net/mametter/ruby-hack-challenge-4"&gt;Ruby Hack Challenge #4 カバレッジ特別回 資料 - SlideShare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また Gitter で連絡を取り合っており，実は誰でも参加できる(たぶん)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitter.im/rubyhackchallenge/Lobby"&gt;rubyhackchallenge/Lobby - Gitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，ボクはもともとこのイベントは参加したいなぁと思っていた(言語好きなので)．&lt;/p&gt;
&lt;h2 id="ruby-のテストカバレッジ"&gt;Ruby のテストカバレッジ&lt;/h2&gt;
&lt;p&gt;Ruby のテストカバレッジは Web から確認できる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://rubyci.s3.amazonaws.com/debian8-coverage/ruby-trunk/lcov/index.html"&gt;LCOV - code coverage report&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを見てカバレッジの低いところにねらい目を付けてテストを追加する(ないしは不要な実装なら削る)． 標準ライブラリのいくつかは個別に GitHub で管理されているので，GitHub で管理されてる場合はそっちに PR を投げれば良いようだ(今回は事情が共有されてたせいかすぐマージされた)．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，&lt;a href="https://github.com/ruby/ruby/blob/trunk/doc/maintainers.rdoc"&gt;ココ&lt;/a&gt;を見ると誰がメンテナーで，どこに報告すれば良いかが書いてある．&lt;/p&gt;
&lt;h3 id="環境構築"&gt;環境構築&lt;/h3&gt;
&lt;p&gt;は事前にやっとくと，当日はすんなりコミットできた(構築方法はスライドに書いてある)． 事前にって言ってもぼくは行きの電車でやったけど(笑)&lt;/p&gt;
&lt;p&gt;Windows と Mac を持ってるけど，どっちも素でやるのは難しいので，Debian の Docker コンテナの上で構築した． Docker ありがとう！ ビルドがめっちゃ遅いけどね！&lt;/p&gt;
&lt;h2 id="当日やったこと"&gt;当日やったこと&lt;/h2&gt;
&lt;p&gt;すっっっごい簡単にカバレッジをあげれそうなのがあったのサクッと直して PR をだした．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ruby/cmath/pull/2"&gt;Add test for coverage by matsubara0507 · Pull Request #2 · ruby/cmath&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CMath&lt;/code&gt; モジュールは &lt;code&gt;Math&lt;/code&gt; モジュールをラップして複素数(Complex number)にまで対応させたものだ． そのため，虚数を含む複素数に関するテストしかなく，実数に関するテストが無かったためカバレッジが低かった． 愚直に全部書いたら100%まで行きましたちゃんちゃんってだけです．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，他にも4,5個ほど PR が出ていた． すごいね！&lt;/p&gt;
&lt;h2 id="もくもく会"&gt;もくもく会&lt;/h2&gt;
&lt;p&gt;あと，Ruby Hack Challenge もくもく会というのがあるらしいので行ってみたい(&lt;a href="https://connpass.com/event/93131/"&gt;次回はこれ&lt;/a&gt;)． MJIT のコードとか読んでみたいよね． それと型検査(はどうなるかまだ分からないらしいけど)．&lt;/p&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;そういえば，ko1 氏がお子さんと奥さんを連れてきていた(たぶん)． そういう事に理解のある会社っていいなぁと感じた．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html</id><title type="text">rust-reversi やってみた</title><updated>2018-06-21T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-21-challenge-rust-reversi.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;rust-reversi やってみた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-21" itemprop="datePublished"&gt;
        Jun 21, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Rust.html"&gt;Rust&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;現在，会社の同期と週一で Rust の勉強会をやっていまして，普段は &lt;a href="https://y-yu.github.io/trpl-2nd-pdf/book.pdf"&gt;The Rust Programming Language: 2nd Edition の日本語版&lt;/a&gt; を輪読しているのですが，3月ぐらいにあった &lt;a href="https://internship.cookpad.com/2018/spring/"&gt;Cookpad Spring 1day Internship 2018&lt;/a&gt; の Rust コースの資料が公開されたため，皆でハッカソンしてみました．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/KOBA789/rust-reversi"&gt;KOBA789/rust-reversi: Cookpad Spring 1day Internship 2018 Rust プログラミングコースで使用された講義資料 - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は実際にやってみてのメモ書きです． 主に躓いたとこのメモです．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，ぼくの Rust の経験値は上記の本を17章まで読んだだけで，ほとんど書いたことないですね(輪読は7章，自分で少し先を読んでいる)． あと，&lt;a href="https://github.com/matsubara0507/rust-reversi/tree/reversi-impl"&gt;回答はフォークしてあげてあります&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="躓いたところ"&gt;躓いたところ&lt;/h3&gt;
&lt;p&gt;めちゃくちゃしょーーーーもないところばっかです(笑)&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;固定長配列の map&lt;/li&gt;
&lt;li&gt;パターンマッチの変数&lt;/li&gt;
&lt;li&gt;index の x と y が逆&lt;/li&gt;
&lt;li&gt;既に置いてあるかの検査&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="何を作っているか"&gt;何を作っているか&lt;/h3&gt;
&lt;p&gt;そもそも課題は何かというと，オセロ(リバーシ)です． 試しに実行してみるとこんな感じ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo run
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
     Running `target/debug/reversi`
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | | |O|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 2 - 2 W
Turn: Black
  a b c d e f g h
 +-+-+-+-+-+-+-+-+
1| | | | | | | | |
 +-+-+-+-+-+-+-+-+
2| | | | | | | | |
 +-+-+-+-+-+-+-+-+
3| | | | | | | | |
 +-+-+-+-+-+-+-+-+
4| | |X|X|X| | | |
 +-+-+-+-+-+-+-+-+
5| | | |X|O| | | |
 +-+-+-+-+-+-+-+-+
6| | | | | | | | |
 +-+-+-+-+-+-+-+-+
7| | | | | | | | |
 +-+-+-+-+-+-+-+-+
8| | | | | | | | |
 +-+-+-+-+-+-+-+-+

B 4 - 1 W
Turn: White
0) c3
1) c5
2) e3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部一から作れではなく，リポジトリをクローンして &lt;code&gt;src/coord.rs&lt;/code&gt; と &lt;code&gt;src/board.rs&lt;/code&gt; の &lt;code&gt;unimplemented!();&lt;/code&gt; となっている個所の実装を与えるだけ． ご丁寧なことにテストも用意してあるので，&lt;code&gt;cargo test&lt;/code&gt; を実行しまくってオールグリーンになれば出来上がり(たぶん)．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;ちなみに，クライアントの同期が &lt;code&gt;unimplemented();&lt;/code&gt; に感動していたので，調子に乗って &lt;a href="https://matthew.brecknell.net/post/hole-driven-haskell/"&gt;Hole driven Programming&lt;/a&gt; について語ってしまった．&lt;/p&gt;
&lt;h3 id="関数が呼べない"&gt;0. 関数が呼べない&lt;/h3&gt;
&lt;p&gt;ゼロ引数関数は &lt;code&gt;xxx.method&lt;/code&gt; はダメで，&lt;code&gt;xxx.method()&lt;/code&gt; しなきゃいけないってのが何度もあった(笑) 普段は Haskell を書いているせいですね．&lt;/p&gt;
&lt;h3 id="固定長配列の-map"&gt;1. 固定長配列の map&lt;/h3&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, &lt;span class="kw"&gt;mut&lt;/span&gt; pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;    ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたときの `Move` を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;&lt;span class="co"&gt;/// 戻り値の `Move` には8方向分の `get_flip` の結果が含まれる&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_move(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord) -&amp;gt; Move &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;    &lt;span class="pp"&gt;unimplemented!&lt;/span&gt;();&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" data-line-number="10"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とあり&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="kw"&gt;struct&lt;/span&gt; Move &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;    &lt;span class="kw"&gt;pub&lt;/span&gt; pos: Coord,&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;    flips: &lt;span class="op"&gt;[&lt;/span&gt;&lt;span class="dt"&gt;u8&lt;/span&gt;; &lt;span class="dv"&gt;8&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" data-line-number="4"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" data-line-number="6"&gt;&lt;span class="kw"&gt;const&lt;/span&gt; DIRECTIONS: &lt;span class="op"&gt;[&lt;/span&gt;Coord; &lt;span class="dv"&gt;8&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt; = &lt;span class="op"&gt;[&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" data-line-number="7"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;), &lt;span class="co"&gt;//左上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" data-line-number="8"&gt;    Coord(&lt;span class="dv"&gt;0&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//真上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" data-line-number="9"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, -&lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//右上&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" data-line-number="10"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;),  &lt;span class="co"&gt;//真左&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" data-line-number="11"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;),   &lt;span class="co"&gt;//真右&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" data-line-number="12"&gt;    Coord(-&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),  &lt;span class="co"&gt;//左下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" data-line-number="13"&gt;    Coord(&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),   &lt;span class="co"&gt;//真下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" data-line-number="14"&gt;    Coord(&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;),   &lt;span class="co"&gt;//右下&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" data-line-number="15"&gt;&lt;span class="op"&gt;]&lt;/span&gt;;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;なので，&lt;code&gt;move.flips = DIRECTIONS.map (|dir| self.get_flip(piece, pos, dir))&lt;/code&gt; って具合にいけそうだと思ったのだ． しかし，悲しいことに組み込みでは &lt;strong&gt;固定長配列に対するこのような操作はないようだ&lt;/strong&gt;(間違っていたらゴメンナサイ…)． なので結局諦めて for 文を回した…&lt;/p&gt;
&lt;p&gt;何か良い方法があったら教えて欲しい.&lt;/p&gt;
&lt;h3 id="パターンマッチの変数"&gt;2. パターンマッチの変数&lt;/h3&gt;
&lt;p&gt;すごい間抜けな話です．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// 指定の色の石を指定の位置に置いたとき、指定の方向へひっくり返せる石の数を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;&lt;span class="co"&gt;///&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;&lt;span class="co"&gt;/// * `piece` - 置く石の色&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;&lt;span class="co"&gt;/// * `pos` - 石を置く位置&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;&lt;span class="co"&gt;/// * `dir` - ひっくり返せる石を探す方向。`DIRECTIONS` の要素のいずれかが渡される&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" data-line-number="6"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, &lt;span class="kw"&gt;mut&lt;/span&gt; pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; opponent = piece.opponent();&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" data-line-number="8"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="kw"&gt;mut&lt;/span&gt; cnt = &lt;span class="dv"&gt;0&lt;/span&gt;;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;loop&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" data-line-number="10"&gt;        pos += dir;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" data-line-number="11"&gt;        &lt;span class="kw"&gt;match&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;pos&lt;span class="op"&gt;]&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-12" data-line-number="12"&gt;            &lt;span class="cn"&gt;None&lt;/span&gt;           =&amp;gt; &lt;span class="kw"&gt;return&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-13" data-line-number="13"&gt;            &lt;span class="cn"&gt;Some&lt;/span&gt;(piece)    =&amp;gt; &lt;span class="kw"&gt;return&lt;/span&gt; cnt,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-14" data-line-number="14"&gt;            &lt;span class="cn"&gt;Some&lt;/span&gt;(opponent) =&amp;gt; cnt += &lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-15" data-line-number="15"&gt;        &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-16" data-line-number="16"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-17" data-line-number="17"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とか書いていたが，全然テストが通らない． それもそのはずで &lt;strong&gt;パターンマッチの中の変数は代入になる&lt;/strong&gt; だけで，&lt;code&gt;if self.matrix[target] == Some(piece) { ... }&lt;/code&gt; とは異なる． シャーディングぅぅぅぅぅとか思ったけど，きっと警告出てたよね…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: unreachable pattern
   --&amp;gt; src/board.rs:165:17
    |
165 |                 Some(opponent) =&amp;gt; cnt += 1,
    |                 ^^^^^^^^^^^^^^
    |
    = note: #[warn(unreachable_patterns)] on by default

warning: unused variable: `opponent`
   --&amp;gt; src/board.rs:158:13
    |
158 |         let opponent = piece.opponent();
    |             ^^^^^^^^ help: consider using `_opponent` instead
    |
    = note: #[warn(unused_variables)] on by default

warning: unused variable: `piece`
   --&amp;gt; src/board.rs:164:22
    |
164 |                 Some(piece)    =&amp;gt; return cnt,
    |                      ^^^^^ help: consider using `_piece` instead

warning: unused variable: `opponent`
   --&amp;gt; src/board.rs:165:22
    |
165 |                 Some(opponent) =&amp;gt; cnt += 1,
    |                      ^^^^^^^^ help: consider using `_opponent` instead&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出てたね…&lt;/p&gt;
&lt;h3 id="index-の-x-と-y-が逆"&gt;3. index の x と y が逆&lt;/h3&gt;
&lt;p&gt;普段二重配列とかやんないからさ…&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="co"&gt;/// ベクトルを表現する構造体&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="kw"&gt;struct&lt;/span&gt; Coord(&lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="dt"&gt;i8&lt;/span&gt;, &lt;span class="kw"&gt;pub&lt;/span&gt; &lt;span class="dt"&gt;i8&lt;/span&gt;);&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;&lt;span class="co"&gt;/// `[]` 演算子のオーバーロード&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;&lt;span class="kw"&gt;impl&lt;/span&gt; Index&amp;lt;Coord&amp;gt; &lt;span class="kw"&gt;for&lt;/span&gt; Matrix &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;type&lt;/span&gt; Output = &lt;span class="dt"&gt;Option&lt;/span&gt;&amp;lt;Piece&amp;gt;;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;    &lt;span class="co"&gt;/// 第一引数に与えられた座標の状態を返す&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;    &lt;span class="co"&gt;/// 座標が盤面の範囲外であった場合は None が返る。&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;    &lt;span class="kw"&gt;fn&lt;/span&gt; index(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, index: Coord) -&amp;gt; &amp;amp;&lt;span class="kw"&gt;Self&lt;/span&gt;::Output &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;        &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.is_in_range(index) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;            &amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;.&lt;span class="dv"&gt;0&lt;/span&gt;&lt;span class="op"&gt;[&lt;/span&gt;index.&lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;usize&lt;/span&gt;&lt;span class="op"&gt;][&lt;/span&gt;index.&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;usize&lt;/span&gt;&lt;span class="op"&gt;]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;        &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;            &amp;amp;&lt;span class="cn"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" data-line-number="14"&gt;        &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" data-line-number="15"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" data-line-number="16"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;とか最初書いていた． &lt;code&gt;Coord&lt;/code&gt; 型はひとつ目が X 座標でふたつ目が Y 座標． &lt;code&gt;&amp;amp;self.0[index.0 as usize][index.1 as usize]&lt;/code&gt; のところが逆ですね…&lt;/p&gt;
&lt;h3 id="既に置いてあるかの検査"&gt;4. 既に置いてあるかの検査&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;moves&lt;/code&gt; のテストが何故かとおらない． &lt;code&gt;moves&lt;/code&gt; は盤上の全ての合法手，“手” を表す &lt;code&gt;Move&lt;/code&gt; 型は手を打つ場所(&lt;code&gt;Coord&lt;/code&gt; 型)と各方向のひっくり返す数を持っている，を列挙する関数．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---- board::tests::test_board_moves stdout ----
	thread &amp;#39;board::tests::test_board_moves&amp;#39; panicked at &amp;#39;assertion failed: `(left == right)`
  left: `6`,
 right: `37`&amp;#39;, src/board.rs:366:9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;めちゃくちゃ多い． テストを読んでイロイロと出力させてみたところ，既にピースが置いてある場合のチェックを忘れていた(バカ)．&lt;/p&gt;
&lt;h3 id="オールグリーン"&gt;オールグリーン&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cargo test
   Compiling reversi v0.1.0 (file:///Users/nobutada.matsubara/git/rust/rust-reversi)
    Finished dev [unoptimized + debuginfo] target(s) in 1.27 secs
     Running target/debug/deps/reversi-ae2013b8997f878b

running 12 tests
test board::tests::test_board_count_mut ... ok
test board::tests::test_board_get_move ... ok
test board::tests::test_board_get_flip ... ok
test board::tests::test_board_do_move ... ok
test board::tests::test_do_flip ... ok
test board::tests::test_matrix_index ... ok
test board::tests::test_board_moves ... ok
test board::tests::test_matrix_index_mut ... ok
test board::tests::test_matrix_is_in_range ... ok
test board::tests::test_move_is_legal ... ok
test coord::tests::test_coord_add ... ok
test coord::tests::test_coord_add_assign ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="感想"&gt;感想&lt;/h2&gt;
&lt;p&gt;基本構文を覚えてないので，とりあえず雑に書いてビルドして怒られたら直す，的なことをしながら，静的検査さいこ～とか言いながらやってた(疲れてる)． おかげで &lt;code&gt;&amp;amp;&lt;/code&gt; とか &lt;code&gt;*&lt;/code&gt; を雑にあつかってて良くないですね． まぁ楽しかったからいいけど．&lt;/p&gt;
&lt;h2 id="おまけ"&gt;おまけ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;get_flip&lt;/code&gt; 関数のところ，関数型プログラマーらしく(?)再帰にして見た. 速度は変わるんかな？&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode rust"&gt;&lt;code class="sourceCode rust"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;u8&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;    &lt;span class="kw"&gt;self&lt;/span&gt;.go_get_flip(piece, pos, dir).unwrap_or(&lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;&lt;span class="kw"&gt;fn&lt;/span&gt; go_get_flip(&amp;amp;&lt;span class="kw"&gt;self&lt;/span&gt;, piece: Piece, pos: Coord, dir: Coord) -&amp;gt; &lt;span class="dt"&gt;Option&lt;/span&gt;&amp;lt;&lt;span class="dt"&gt;u8&lt;/span&gt;&amp;gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; target = pos + dir;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;target&lt;span class="op"&gt;]&lt;/span&gt; == &lt;span class="cn"&gt;Some&lt;/span&gt;(piece.opponent()) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" data-line-number="8"&gt;        &lt;span class="kw"&gt;self&lt;/span&gt;.go_get_flip(piece, target, dir).map(|x| x + &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" data-line-number="9"&gt;    &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="kw"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;self&lt;/span&gt;.matrix&lt;span class="op"&gt;[&lt;/span&gt;target&lt;span class="op"&gt;]&lt;/span&gt; == &lt;span class="cn"&gt;Some&lt;/span&gt;(piece) &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" data-line-number="10"&gt;        &lt;span class="cn"&gt;Some&lt;/span&gt;(&lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" data-line-number="11"&gt;    &lt;span class="op"&gt;}&lt;/span&gt; &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" data-line-number="12"&gt;        &lt;span class="cn"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" data-line-number="13"&gt;    &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" data-line-number="14"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;Haskell 版でも作ってみようかしらん．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html</id><title type="text">Earlang ＆ Elixir Fest 2018 に参加してきた</title><updated>2018-06-18T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-18-join-elixir-festa-2108.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Earlang ＆ Elixir Fest 2018 に参加してきた&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-18" itemprop="datePublished"&gt;
        Jun 18, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt; &lt;a href="/tags/event.html"&gt;event&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;先日(6/16)，&lt;a href="https://elixir-fest.jp/"&gt;Earlang &amp;amp; Elixir Fest 2018&lt;/a&gt; に参加してきたので，そのメモ書きです． ちなみに，Elixir は普段たいして使ってないけど LT もしてきました．&lt;/p&gt;
&lt;h4 id="追記2018.06.21"&gt;追記(2018.06.21)&lt;/h4&gt;
&lt;p&gt;本稿公開後に公開してくださった発表スライドのリンクを追記しました．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;今年で2回目らしく，去年は Elixir の作者の &lt;a href="https://twitter.com/josevalim"&gt;Jose Valim&lt;/a&gt; 氏を呼んで Keynote してもらい，全体のセッション内容としては Elixir を導入し始めた・挑戦中という話がメインだったようだ． 今年はどっちかっていうとプロダクトに実践導入・運用してみてどうだったかという話がメインだそうだ． また，並行してハンズオンがあったらしいが，行ってないのでそっちは良く分からない． ハンズオンの資料は GitHub に公開してあるので，いずれやってみたい(同期とかとハンズオンしてみてもいいかも)．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ohr486/ErlangElixirFestHandsOn"&gt;ohr486/ErlangElixirFestHandsOn - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あと &lt;a href="https://togetter.com/li/1238110"&gt;Togetter にまとめてみました&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id="メモ"&gt;メモ&lt;/h2&gt;
&lt;p&gt;各企業での導入した話が多かったので簡単なメモばっかです．&lt;/p&gt;
&lt;h4 id="らくらく連絡網が-elixir-でリアルタイムメッセージング基盤を刷新した話"&gt;「らくらく連絡網」が Elixir でリアルタイムメッセージング基盤を刷新した話&lt;/h4&gt;
&lt;p&gt;(ネットワーク設定にバタバタしてたのでメモが少ない)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/rinosamakanata"&gt;rinosamakanata&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://eole-repos.github.io/public/elixirfest/2018/elixirfest2018-eole-rinosamakanata.pdf"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;もともとは RoR らしい&lt;/li&gt;
&lt;li&gt;技術的課題
&lt;ul&gt;
&lt;li&gt;分散の問題&lt;/li&gt;
&lt;li&gt;長い目で見たときの保守・運用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;フロントエンドは Elm
&lt;ul&gt;
&lt;li&gt;「関数型良いよね」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;負荷テストのために不可掛けの Docker コンテナを作った&lt;/li&gt;
&lt;li&gt;Elixir のバージョンアップが多い(リリースしてから9回もあった)
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/asdf-vm/asdf-elixir"&gt;asdf&lt;/a&gt; で難なく&lt;/li&gt;
&lt;li&gt;Ruby や RoR よりぜんぜん簡単&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;実質的にメンテナンスフリー&lt;/li&gt;
&lt;li&gt;Erlang は書けなくても導入できる
&lt;ul&gt;
&lt;li&gt;ただし BEAM の知識はいる&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/happi/theBeamBook"&gt;The BEAM Book&lt;/a&gt; おすすめ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近 Ruby や Ruby のライブラリのバージョンアップで苦しんでいるのを見てたのでバージョンアップがシームレスなの羨ましい．&lt;/p&gt;
&lt;h4 id="初めてのerlangサーバ開発と運用"&gt;初めてのErlangサーバ開発と運用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/mookjp"&gt;mookjp&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/mookjp/chu-metefalseerlangsahakai-fa-toyun-yong?slide=1"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Erlang をどう勉強したかや失敗談などの話&lt;/li&gt;
&lt;li&gt;Node.js から Erlang へ (たぶん)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://erlang.org/doc/man/observer.html"&gt;observer&lt;/a&gt; という Erlang プロセスの可視化ツールが便利&lt;/li&gt;
&lt;li&gt;Erlang サーバーをプロダクションに導入するときの設定
&lt;ul&gt;
&lt;li&gt;思想の記事ばっか！&lt;/li&gt;
&lt;li&gt;実際の設定に関する記事が少ない！！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不必要なプロセスやその監視プロセスが微妙に残ってじわじわ CPU 使用率が上がってしまった&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.erlang-in-anger.com/"&gt;Erlang in Anger&lt;/a&gt; を絶対に読む
&lt;ul&gt;
&lt;li&gt;運用に役立ちそうなことがたくさん書いてある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://erlang-slack.herokuapp.com/"&gt;Erlang の Slack ワークスペース&lt;/a&gt;がおススメ！
&lt;ul&gt;
&lt;li&gt;紹介した監視の VMStats もここで教えてもらった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思想の記事が多い話，なんとなく Haskell にも似たようなところがあって笑った&lt;/p&gt;
&lt;h4 id="keep-phoenix-app-productivity"&gt;Keep Phoenix App Productivity&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/kanmo_ak"&gt;kanmo_ak&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/kanmo/keep-phoenix-app-productivity?slide=1"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Phoenix Application 開発1年・運用1年してみた結果の話&lt;/li&gt;
&lt;li&gt;&lt;a href="https://elixirschool.com/en/lessons/advanced/umbrella-projects/"&gt;Umbrella&lt;/a&gt; によって Project を分割
&lt;ul&gt;
&lt;li&gt;肥大化してきた&lt;/li&gt;
&lt;li&gt;複数のサービスをひとつのリポジトリで別々に開発&lt;/li&gt;
&lt;li&gt;サービス間でコードを共有できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ひとつのファイルを書き換えるだけでコンパイル対象が膨大…
&lt;ul&gt;
&lt;li&gt;ファイル間の依存関係がひどいので切っていく&lt;/li&gt;
&lt;li&gt;マクロを変更するとやり直し&lt;/li&gt;
&lt;li&gt;構造体を変更するとやばい&lt;/li&gt;
&lt;li&gt;プロトコルも依存がある&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hexdocs.pm/mix/Mix.Tasks.Xref.html"&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; タスクが便利&lt;/li&gt;
&lt;li&gt;モジュール名を動的に組み立てて依存を無理やり切る黒魔術(使わない方がいい)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang プロセスだと remsh で起動中のプロセスに接続して調査できる&lt;/li&gt;
&lt;li&gt;Elixir バージョンアップは追いやすい
&lt;ul&gt;
&lt;li&gt;RoR に比べて(笑)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Type Spec を書いておくとドキュメントになる
&lt;ul&gt;
&lt;li&gt;Dializer は使ってない(時間が無かった)&lt;/li&gt;
&lt;li&gt;spec ないとつらいと感じたの私自身です&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;昔 Type Spec が書いてあったが間違ってるおかげで痛い目にあったので書いたやつを静的にチェックしたいですよね…&lt;/p&gt;
&lt;h4 id="from-python-to-elixir"&gt;from Python to Elixir&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/kenichirow"&gt;kenichirow&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;Python から Elixir に移行
&lt;ul&gt;
&lt;li&gt;Python 2020 年問題(2系のサポートが終わる)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Phoenix は最初は使わないつもりだった
&lt;ul&gt;
&lt;li&gt;Django からだと暗黙的な何某が多い印象(マクロ)&lt;/li&gt;
&lt;li&gt;PubSub いらない&lt;/li&gt;
&lt;li&gt;なので自作 FW を作ってた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;突然 Phoenix 宣言
&lt;ul&gt;
&lt;li&gt;「お前 Dis れるほど Phoenix 知ってるのかよ」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ecto にはいくつかの問題&lt;/li&gt;
&lt;li&gt;なのでライブラリを作った &lt;a href="https://github.com/gumi/yacto"&gt;Yacto&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;DB分割・XAトランザクションなど&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各ゲームの基盤を Template にしていたがバージョン管理がつらいのでライブラリに&lt;/li&gt;
&lt;li&gt;Elixir のサポートチーム
&lt;ul&gt;
&lt;li&gt;ググる前に聞け&lt;/li&gt;
&lt;li&gt;最近しんどいので Stack Overflow Team を導入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;言語変えて解決した問題は少しだけ
&lt;ul&gt;
&lt;li&gt;ただ整備するきっかけにはなった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基盤チームカッコいい&lt;/p&gt;
&lt;h4 id="ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる"&gt;ステートフルで大規模アクセスのあるsoft-realtimeなゲームサーバーをeasyにつくる&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ne-sachirou"&gt;さっちゃん&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/ne_sachirou/sutetohurudeda-gui-mo-akusesufalsearusoft-realtimenagemusabawoeasynitukuru"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Phoenix でゲーム作って運用したはなし&lt;/li&gt;
&lt;li&gt;AWS + Kube + Phoenix&lt;/li&gt;
&lt;li&gt;Real time PvP がメインなのに RoR は大変&lt;/li&gt;
&lt;li&gt;どっちみちイロイロ知見が無いので新しい技術使っても苦労はするでしょ
&lt;ul&gt;
&lt;li&gt;Elixir の知見はある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hexdocs.pm/inner_cotton/readme.html"&gt;InnerCotton&lt;/a&gt; を作った&lt;/li&gt;
&lt;li&gt;FP は知ってた&lt;/li&gt;
&lt;li&gt;Channel と Redis で PvP&lt;/li&gt;
&lt;li&gt;ホットデプロイはあきらめた&lt;/li&gt;
&lt;li&gt;優先度付きキューを自作 &lt;a href="https://hex.pm/packages/pqueue2"&gt;queue2&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;既存のモノは間違ってるものが多かったので&lt;/li&gt;
&lt;li&gt;スタックになっているものもあった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hub.docker.com/r/nesachirou/elixir/"&gt;docker image&lt;/a&gt; を作った(Elixir と Erlang の両方が指定できる)&lt;/li&gt;
&lt;li&gt;Elixir の監視つらい&lt;/li&gt;
&lt;li&gt;もっと publish していこうぜ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;社内でやったことドンドン Publish できるのいいなぁ．&lt;/p&gt;
&lt;h4 id="channel先生-pubsubがしたいです"&gt;Channel先生…!! PubSubがしたいです…&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ohr486"&gt;ohrdev&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/ohr486/erlangelixirfest2018-ohr486-session"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;~Erlang in Anger~ PubSub in Channel&lt;/li&gt;
&lt;li&gt;「PubSub しない Phoenix はただの Rails だ」&lt;/li&gt;
&lt;li&gt;Phoenix Channel + PubSub&lt;/li&gt;
&lt;li&gt;PubSub は2種類ある
&lt;ul&gt;
&lt;li&gt;ローカル PubSub ・リモート PubSub&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「これカッコよくないっすか、見るたびにすごいぞくぞくする」&lt;/li&gt;
&lt;li&gt;PubSub バックエンドは選択できる&lt;/li&gt;
&lt;li&gt;どれだけ知っといた方がいいか？
&lt;ul&gt;
&lt;li&gt;基本は知らなくても&lt;/li&gt;
&lt;li&gt;新しい Adaptar を作る場合は知ってないといけない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PubSub 完全に理解した(嘘)&lt;/p&gt;
&lt;h4 id="antikythera-framework-an-elixir-framework-for-multiple-web-services"&gt;Antikythera Framework: An Elixir framework for multiple web services&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/skirino"&gt;skirino&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://skirino.github.io/slides/antikythera_framework.html#/"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;社内で作ったフレームワークの紹介 : &lt;a href="https://github.com/access-company/antikythera"&gt;antikythera&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Antikythera メカニズム
&lt;ul&gt;
&lt;li&gt;ギリシャ時代のオーパーツ&lt;/li&gt;
&lt;li&gt;なにかよくわからない&lt;/li&gt;
&lt;li&gt;星の動き？？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;複数のサービスをひとつのフレームワークで管理&lt;/li&gt;
&lt;li&gt;Gear : Webサービスの単位・他の Gear に依存しうる
&lt;ul&gt;
&lt;li&gt;instance より細かい単位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コア機能
&lt;ul&gt;
&lt;li&gt;リソースコントロール&lt;/li&gt;
&lt;li&gt;自動オペレーション(ホットデプロイなど)&lt;/li&gt;
&lt;li&gt;ログなどビルドインに&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Gear はマイクロサービスで疎結合だが管理は統一&lt;/li&gt;
&lt;li&gt;リソース管理は ErlangVM なので一長一短&lt;/li&gt;
&lt;li&gt;DB はどうするか？
&lt;ul&gt;
&lt;li&gt;DB は知らない(Gear にしない)&lt;/li&gt;
&lt;li&gt;ふつうに Ecto とかで&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;なぜ Erlang じゃないか？
&lt;ul&gt;
&lt;li&gt;mix が優秀&lt;/li&gt;
&lt;li&gt;mix compiler でフックできる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mix すごいのはよくわかる．&lt;/p&gt;
&lt;h4 id="任意のbeam系言語でプラグインを書ける安定したフレームワークの作りかた"&gt;任意のBEAM系言語でプラグインを書ける安定したフレームワークの作りかた&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/niku"&gt;niku&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://niku.name/2018/06/16/slide.html"&gt;発表スライドはコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BEAM系プラグインを作る上でのノウハウ&lt;/li&gt;
&lt;li&gt;また PubSub の話ですいません&lt;/li&gt;
&lt;li&gt;フレームワークとプラグイン&lt;/li&gt;
&lt;li&gt;プラグイン機構を持つ FW には登場人物が3人
&lt;ul&gt;
&lt;li&gt;フレームワークとプラグインを使う人&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;プラグインでエラーが起きたときフレームワークはどうするか&lt;/li&gt;
&lt;li&gt;「絵にかくとこんな感じ」&lt;/li&gt;
&lt;li&gt;Supervisor は他の言語ではあまりない
&lt;ul&gt;
&lt;li&gt;こいつのおかげで別粒度間のプロセス管理が楽&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ゆかいに学ぼうの Supervisor の章は良くできている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;絵に書くとこんな感じってのがじわじわ来る．&lt;/p&gt;
&lt;h4 id="erlang-事例紹介-メディアストリーム中継システム"&gt;Erlang 事例紹介: メディアストリーム中継システム&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/amutake"&gt;amutake&lt;/a&gt; 氏の発表&lt;/li&gt;
&lt;li&gt;&lt;a href="https://niconare.nicovideo.jp/watch/kn3115"&gt;発表スライドはコチラ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;ニコニコのスライド置き場あったんだ(笑)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ニコ生で使われる(予定)のシステムの話(Erlang 製)&lt;/li&gt;
&lt;li&gt;生放送の中継ツリー&lt;/li&gt;
&lt;li&gt;生放送に求められる性質&lt;/li&gt;
&lt;li&gt;ストリーム中継システム : sluicegate の作成
&lt;ul&gt;
&lt;li&gt;いつか OSS になる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;学術的に研究されたアルゴリズム(独自ではなく)
&lt;ul&gt;
&lt;li&gt;HyParView&lt;/li&gt;
&lt;li&gt;Plumtree&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;簡単にできるけど無駄にメッセージパッシングすると遅くなる
&lt;ul&gt;
&lt;li&gt;軽い処理をメッセージパッシングするとだめ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang クラスタは組まない&lt;/li&gt;
&lt;li&gt;Plumtree の性質があれだった
&lt;ul&gt;
&lt;li&gt;なので自分たちで改造&lt;/li&gt;
&lt;li&gt;根幹なので定理証明(Coq で実装)
&lt;ul&gt;
&lt;li&gt;PPLにて発表した&lt;/li&gt;
&lt;li&gt;生放送ストリーム中継システムのCoqによる形式化と検証&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ぱぶさぶくん(検証ツール)&lt;/li&gt;
&lt;li&gt;水道局(可視化ツール)
&lt;ul&gt;
&lt;li&gt;水路という自作ライブラリを使っている&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分散アルゴリズムを書きやすい&lt;/li&gt;
&lt;li&gt;調査しやすい
&lt;ul&gt;
&lt;li&gt;reduction の取得のしやすさは Erlang in Anger&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Coq のコードから Erlang に変換するものがある&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんか研究の話聞いてるみたいで聞きやすかった(笑)&lt;/p&gt;
&lt;h3 id="lt"&gt;LT&lt;/h3&gt;
&lt;p&gt;自分も LT したので細かいメモは無い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NOC の話
&lt;ul&gt;
&lt;li&gt;朝にアクシデントがあったようで…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;個人で Elixir してきた話(日本一 Elixir 本を書いている)&lt;/li&gt;
&lt;li&gt;Elixir 完全に理解した(ちょっとできる人がいればいい)&lt;/li&gt;
&lt;li&gt;Elixir Programming with Type checking (自分)&lt;/li&gt;
&lt;li&gt;ElixirScript の話&lt;/li&gt;
&lt;li&gt;PubSub Redis
&lt;ul&gt;
&lt;li&gt;phoenix_pubusu_redis_z&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dialyzer のすすめ&lt;/li&gt;
&lt;li&gt;Erlang on ARM サーバー
&lt;ul&gt;
&lt;li&gt;未発表のもの&lt;/li&gt;
&lt;li&gt;秒間40まんリクエストをさばいてる&lt;/li&gt;
&lt;li&gt;ミドルウェアの世界に来い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやら MVP は「Elixirを2週間で完全に理解した」新卒の子．&lt;/p&gt;
&lt;h3 id="keynote"&gt;Keynote&lt;/h3&gt;
&lt;h4 id="共有からメッセージパッシングへ-erlangotpやelixirと歩んだこの10年"&gt;共有からメッセージパッシングへ: Erlang/OTPやElixirと歩んだこの10年&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/jj1bdx"&gt;力武健次&lt;/a&gt;氏&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/jj1bdx/erlang-and-elixir-fest-2018-keynote?slide=1"&gt;発表資料はコチラ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BIND ??? 脆弱性の多い DNS サーバーについて昔やってた
&lt;ul&gt;
&lt;li&gt;1000行マクロ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Erlang に出会う
&lt;ul&gt;
&lt;li&gt;うるう秒の修正パッチを送る&lt;/li&gt;
&lt;li&gt;SSH のセキュリティの研究&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ICFP’11 の Erlang Workshop の実行委員長&lt;/li&gt;
&lt;li&gt;Erlang in Anger のサイン本もらった&lt;/li&gt;
&lt;li&gt;Elixir のロゴは商標登録されている&lt;/li&gt;
&lt;li&gt;Catalyze Changes
&lt;ul&gt;
&lt;li&gt;Erlang は読みにくい！&lt;/li&gt;
&lt;li&gt;レコードが難しい！&lt;/li&gt;
&lt;li&gt;ドキュメントがない！&lt;/li&gt;
&lt;li&gt;何とかっしようぜ！&lt;/li&gt;
&lt;li&gt;by Dave Tomas&lt;/li&gt;
&lt;li&gt;大変だった…(jose)&lt;/li&gt;
&lt;li&gt;有言実行しててElixir本を7冊も出版している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ruby コミュニティをちらほら見かけるようになった&lt;/li&gt;
&lt;li&gt;2018/2 大事件&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codesync.global/conferences/code-beam-sf-2018/"&gt;Code BEAM 2018&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Open Erlang 20周年&lt;/li&gt;
&lt;li&gt;BEAM コミュニティの融合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;共通してどこがおいしいのか&lt;/li&gt;
&lt;li&gt;Immutability ディープコピー 参照を使わない
&lt;ul&gt;
&lt;li&gt;自分が思う Erlang のすばらしさ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;従来は実態を共有(はやい？)&lt;/li&gt;
&lt;li&gt;「安全よりも効率」&lt;/li&gt;
&lt;li&gt;C++ の愚痴
&lt;ul&gt;
&lt;li&gt;参照なの？値なの？&lt;/li&gt;
&lt;li&gt;const の話が大変&lt;/li&gt;
&lt;li&gt;コンストラクタいつ動く？？&lt;/li&gt;
&lt;li&gt;shared_ptr と unique_ptr (参照カウンタと所有権)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;例外: ETSやプロセス辞書&lt;/li&gt;
&lt;li&gt;「効率より安全」
&lt;ul&gt;
&lt;li&gt;とても遅い&lt;/li&gt;
&lt;li&gt;型検査は無いけど非常に厳格&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Joe (Erlang の作者)「processes messgae and links が重要な部分(gen_server は後から)」
&lt;ul&gt;
&lt;li&gt;他はどうでもいい&lt;/li&gt;
&lt;li&gt;軽量並行プロセスとエラーハンドリング&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;綺麗に落とすのは大変
&lt;ul&gt;
&lt;li&gt;プロセスキューが詰まると終了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;link and monitor
&lt;ul&gt;
&lt;li&gt;昔のSDの自分の記事を読み返した&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;今後
&lt;ul&gt;
&lt;li&gt;基本理念 「ほどほどなのが一番良い」&lt;/li&gt;
&lt;li&gt;手を抜かずに高速化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Code BEAM で話題にあがったもの
&lt;ul&gt;
&lt;li&gt;組込み分野えの応用&lt;/li&gt;
&lt;li&gt;大規模クラスタ&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/josefs/Gradualizer"&gt;Gradual Type System&lt;/a&gt; (ツールの発表があった)&lt;/li&gt;
&lt;li&gt;Language Server Protcol&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;英語圏で発表しよう
&lt;ul&gt;
&lt;li&gt;Code BEAM 2018 は日本人一人&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クライアントの同期の子が，不変性のすばらしさの話を指して「Rust や Elixir を勉強したとに同じことを感じた！」と喜んでいた．&lt;/p&gt;
&lt;h2 id="自分の話"&gt;自分の話&lt;/h2&gt;
&lt;p&gt;Elchemy の紹介話をしてきました． スライドはこちら&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/ocbuQdsbw2EmG5" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;実は前日(6/15)に別の LT で Elchemy の Docker image を作る話をしてきた． その時のスライドはこちら．&lt;/p&gt;
&lt;h2 id="section-3"&gt;&lt;/h2&gt;
&lt;iframe src="//www.slideshare.net/slideshow/embed_code/key/al30fSfPGB5HGN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;
&lt;/iframe&gt;
&lt;h2 id="section-4"&gt;&lt;/h2&gt;
&lt;p&gt;実は以下の記事でもっと詳しくまとめてあるので，プレゼンを見る必要は無いんです(笑)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"&gt;Elchemy 入門 : その１&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html"&gt;Elchemy 入門 : その２&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;来年はもっと型のハナシができるといいなぁ．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html</id><title type="text">Elchemy 入門 : その２</title><updated>2018-06-16T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-16-introduce-elchemy-part2.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Elchemy 入門 : その２&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-16" itemprop="datePublished"&gt;
        Jun 16, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elchemy.html"&gt;Elchemy&lt;/a&gt; &lt;a href="/tags/Elm.html"&gt;Elm&lt;/a&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;Elm から Elixir のトランスパイラ，&lt;a href="https://github.com/wende/elmchemy"&gt;Elchemy&lt;/a&gt; についてイロイロと調べたのでまとめていきます． &lt;a href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"&gt;前回はコチラ&lt;/a&gt;． 今回は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-2-our-own-rpg-character-module-cedbf7da138d"&gt;Tutorial その２&lt;/a&gt;をやってみた&lt;/li&gt;
&lt;li&gt;Phoenix で ToDo アプリを作る&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の2本立てです． ちなみに，現在のバージョンは 0.7.4 です．&lt;/p&gt;
&lt;h2 id="tutorial-そのをやってみた"&gt;Tutorial その２をやってみた&lt;/h2&gt;
&lt;p&gt;Tutorial その２では Elchemy を利用した独自ライブラリを作成する． 以下の手順で行うそうだ．&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;エイリアス型を定義&lt;/li&gt;
&lt;li&gt;ユニオン型を定義&lt;/li&gt;
&lt;li&gt;関数としてエイリアスやタグを用いる&lt;/li&gt;
&lt;li&gt;ユニオン型でのパターンマッチ&lt;/li&gt;
&lt;li&gt;関数として演算子を使う・独自の演算子を定義する&lt;/li&gt;
&lt;li&gt;別のモジュールから型やエイリアス型をインポートする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本的に Elm の書き方講座みたいなものなので，最悪っ困ったら Elm を勉強してください(丸投げ)． ちなみに，元記事の全てを細かく追従せず，ざっくりと掻い摘んで書き出している． なので細かくは元記事を読んでね．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;あと，&lt;a href="https://github.com/wende/elmchemy-article-example"&gt;このコードは全て作者さんが GitHub に挙げている&lt;/a&gt;．&lt;/p&gt;
&lt;h3 id="その前に"&gt;その前に&lt;/h3&gt;
&lt;p&gt;テストを書こう，ということでテストを Elixir で書いている． 今回の作成するライブラリはどうやら，ゲームか何かのキャラを制御する物らしい&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="co"&gt;# character_test.exs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;CharacterTest&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ExUnit&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" data-line-number="6"&gt;  test &lt;span class="st"&gt;&amp;quot;Character has name, last name and such&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" data-line-number="7"&gt;      gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" data-line-number="9"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;name &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" data-line-number="10"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;surname &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" data-line-number="11"&gt;      assert gordon&lt;span class="op"&gt;.&lt;/span&gt;gender &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;:male&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" data-line-number="14"&gt;  test &lt;span class="st"&gt;&amp;quot;Has stats&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" data-line-number="15"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" data-line-number="17"&gt;    stats &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="va"&gt;:strength&lt;/span&gt;, &lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="va"&gt;:vitality&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" data-line-number="18"&gt;    &lt;span class="kw"&gt;for&lt;/span&gt; s &lt;span class="op"&gt;&amp;lt;-&lt;/span&gt; stats &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" data-line-number="19"&gt;      assert is_integer(gordon&lt;span class="op"&gt;.&lt;/span&gt;stats[s]), &lt;span class="st"&gt;&amp;quot;No &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;s&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt; stat in &lt;/span&gt;&lt;span class="ot"&gt;#{&lt;/span&gt;inspect gordon&lt;span class="ot"&gt;}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" data-line-number="20"&gt;    &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" data-line-number="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" data-line-number="22"&gt;    assert &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;stats&lt;span class="op"&gt;.&lt;/span&gt;vitality &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" data-line-number="23"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" data-line-number="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" data-line-number="25"&gt;  test &lt;span class="st"&gt;&amp;quot;Boosting visality boosts health&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" data-line-number="26"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" data-line-number="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-28" data-line-number="28"&gt;    { hp, packed_gordon_max } &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;health&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-29" data-line-number="29"&gt;    { _, weak_gordon_max }    &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:vitality&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, gordon)&lt;span class="op"&gt;.&lt;/span&gt;health&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-30" data-line-number="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-31" data-line-number="31"&gt;    assert packed_gordon_max &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; weak_gordon_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-32" data-line-number="32"&gt;    assert hp &lt;span class="op"&gt;==&lt;/span&gt; packed_gordon_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-33" data-line-number="33"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-34" data-line-number="34"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-35" data-line-number="35"&gt;  test &lt;span class="st"&gt;&amp;quot;Can equip weapon only if intelligence is enough&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-36" data-line-number="36"&gt;    gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Gordon&amp;quot;&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Freemonad&amp;quot;&lt;/span&gt;, &lt;span class="va"&gt;:male&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-37" data-line-number="37"&gt;    weapon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Weapon&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;new(&lt;span class="st"&gt;&amp;quot;Sci fi blaster thingy&amp;quot;&lt;/span&gt;, &lt;span class="dv"&gt;9&lt;/span&gt; ,&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-38" data-line-number="38"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-39" data-line-number="39"&gt;    dumb_gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-40" data-line-number="40"&gt;    smart_gordon &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;set_stat(&lt;span class="va"&gt;:intelligence&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;, gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-41" data-line-number="41"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-42" data-line-number="42"&gt;    assert {&lt;span class="va"&gt;:error&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;Too dumb&amp;quot;&lt;/span&gt;} &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;equip(weapon, dumb_gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-43" data-line-number="43"&gt;    assert {&lt;span class="va"&gt;:ok&lt;/span&gt;, equipped_gordon} &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="cn"&gt;Character&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;equip(weapon, smart_gordon)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-44" data-line-number="44"&gt;    assert equipped_gordon&lt;span class="op"&gt;.&lt;/span&gt;arm &lt;span class="op"&gt;==&lt;/span&gt; {weapon}&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-45" data-line-number="45"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-46" data-line-number="46"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="キャラクターを定義"&gt;キャラクターを定義&lt;/h3&gt;
&lt;h4 id="型エイリアス"&gt;1. 型エイリアス&lt;/h4&gt;
&lt;p&gt;関数型なのでまずはドメインモデルの型を定義する． テストより，&lt;code&gt;name&lt;/code&gt; &lt;code&gt;surname&lt;/code&gt; &lt;code&gt;gender&lt;/code&gt; をフィールドとして持っているのが分かるので次のような型を定義した．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Character exposing (..)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;何故エイリアスなのかというと，構造的サブタイピイングが出来るようにだと思う(たぶん)．&lt;/p&gt;
&lt;h4 id="ユニオン型"&gt;2. ユニオン型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Gender&lt;/code&gt; 型が無いので定義する． こっちは列挙型みたいなのが欲しいので、ユニオン型を用いる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type Gender
    = Male
    | Female
    | Other&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="関数としての型エイリアス"&gt;3. 関数としての型エイリアス&lt;/h4&gt;
&lt;p&gt;Elixir っぽい &lt;code&gt;new&lt;/code&gt; 関数を定義してやろう． Elm の場合，エイリアス型を定義すれば同名の値コンストラクタができるので，それをラップすればよい&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="キャラクターにステータスを持たせる"&gt;キャラクターにステータスを持たせる&lt;/h3&gt;
&lt;p&gt;キャラクターにいくつかのステータスを持たせよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    }

type alias Stats =
    { strength : Int
    , intelligence : Int
    , vitality : Int
    }

new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;health&lt;/code&gt; はどうやら HP みたいなものらしい(現在のHPと上限)．&lt;/p&gt;
&lt;h3 id="パターンマッチ"&gt;4. パターンマッチ&lt;/h3&gt;
&lt;p&gt;ステータスを更新する関数を定義しよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type Stat
    = Strength
    | Intelligence
    | Vitality

setStat : Stat -&amp;gt; Int -&amp;gt; Character -&amp;gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        Strength -&amp;gt;
            { character | stats = { stats | strength = value } }
        Intelligence -&amp;gt;
            { character | stats = { stats | intelligence = value } }
        Vitality -&amp;gt;
            { character | stats = { stats | vitality = value } }        &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;残念ながらこの &lt;code&gt;setStat&lt;/code&gt; は正しくない． テストを見ればわかるが &lt;code&gt;Vitality&lt;/code&gt; を更新した場合は &lt;code&gt;health&lt;/code&gt; も更新する必要がある．&lt;/p&gt;
&lt;h4 id="演算子"&gt;5. 演算子&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;health&lt;/code&gt; はタプル型だ． タプルの更新をいい感じにするために，カスタム演算子を定義してみよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;(&amp;lt;$) : (a, b) -&amp;gt; (a -&amp;gt; c) -&amp;gt; (c, b)
(&amp;lt;$) tuple f = Tuple.mapFirst f tuple

($&amp;gt;) : (a, b) -&amp;gt; (b -&amp;gt; c) -&amp;gt; (a, c)
($&amp;gt;) tuple f = Tuple.mapSecond f tuple&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを使って &lt;code&gt;setStat&lt;/code&gt; の &lt;code&gt;Vitality&lt;/code&gt; の部分を正しく修正する．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;setStat : Stat -&amp;gt; Int -&amp;gt; Character -&amp;gt; Character
setStat stat value character =
    let
      stats = character.stats
    in
    case stat of
        ...
        Vitality -&amp;gt;
            { character
                | stats = { stats | vitality = value }
                , health =
                    character.health
                      &amp;lt;$ (+) ((value - stats.vitality) * 10)
                      $&amp;gt; always (100 + 10 * value)
            }                &lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ウェポンを持たせる"&gt;ウェポンを持たせる&lt;/h3&gt;
&lt;h4 id="インポート"&gt;インポート&lt;/h4&gt;
&lt;p&gt;新しく &lt;code&gt;Weapon.elm&lt;/code&gt; ファイルを作り，新しいモジュール定義する．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Weapon exposing (..)

type alias Weapon =
    { name : String
    , level : Int
    , damage : Int
    }

new : String -&amp;gt; Int -&amp;gt; Int -&amp;gt; Weapon
new name level damage = Weapon name level damage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このモジュールをインポートして &lt;code&gt;Character&lt;/code&gt; 型を拡張しよう&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;import Weapon exposing (Weapon)

type alias Character =
    { name : String
    , surname : String
    , gender : Gender
    , health : (Int, Int)
    , stats : Stats
    , arm : Maybe Weapon
    }

new : String -&amp;gt; String -&amp;gt; Gender -&amp;gt; Character
new name surname gender =
    Character
      name
      surname
      gender
      (100,100)
      (Stats 0 0 0)
      Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後に &lt;code&gt;equip&lt;/code&gt; 関数を作って完成． これで全てのテストが通るはずだ．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;equip : Weapon -&amp;gt; Character -&amp;gt; Result String Character
equip weapon character =
    if weapon.level &amp;lt; character.status.intelligence then
        Ok { character | arm = Just weapon }
    else
        Err &amp;quot;Too dumb&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「頭悪すぎ」ってひどい(笑)&lt;/p&gt;
&lt;h2 id="phoenix-で-todo-アプリを作る"&gt;Phoenix で ToDo アプリを作る&lt;/h2&gt;
&lt;p&gt;Elchemy が実際にどの程度有用かを感じるために，Elchemy + Elm + Phoenix で超簡易的な Todo アプリを作ってみた．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app"&gt;MATSUBARA Nobutada / elchemy_todo_app · GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過去に &lt;a href="https://github.com/matsubara0507/patissier-test"&gt;Elm + Phoenix で社内ツールを作ったり&lt;/a&gt;，&lt;a href="https://matsubara0507.github.io/posts/2017-12-13-elm-and-haskell-for-elmer.html"&gt;Elm + Haskell で Todo アプリを書いてみたり&lt;/a&gt;したので，その辺りからコードや構成はパクッて来てます． GitLab に置いてるのは，モノは試しってやつ(笑)．&lt;/p&gt;
&lt;h3 id="phoenix-をインストール"&gt;Phoenix をインストール&lt;/h3&gt;
&lt;p&gt;Elchemy (および Elixir・Elm・npm) はインストールされているとする． &lt;a href="https://hexdocs.pm/phoenix/installation.html"&gt;Phoenix のサイト&lt;/a&gt;にある通りにやればよい．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix archive.install https://github.com/phoenixframework/archives/raw/master/phx_new.ez&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="project-を作成"&gt;Project を作成&lt;/h3&gt;
&lt;p&gt;こんな時のために &lt;code&gt;elchemy init&lt;/code&gt; というコマンドがある(？)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix phx.new elchemy_todo_app --no-ecto
$ cd elchemy_todo_app
$ elchemy init&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;elchemy new&lt;/code&gt; との違いは，&lt;code&gt;mix.exs&lt;/code&gt; の Elixir のバージョンが古いのと &lt;code&gt;.formatter.exs&lt;/code&gt; ぐらいかな？ 今回は DB をわざわざ使うのがめんどくさいので，ストレージっぽい GenServer を定義する(なので &lt;code&gt;--no-ecto&lt;/code&gt;)．&lt;/p&gt;
&lt;h3 id="crud-を作る"&gt;CRUD を作る&lt;/h3&gt;
&lt;p&gt;Phoenix に CRUD を追加するには，まず&lt;code&gt;router.ex&lt;/code&gt; にルーティングを足す.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Router&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:router&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" data-line-number="6"&gt;  pipeline &lt;span class="va"&gt;:api&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" data-line-number="7"&gt;    plug(&lt;span class="va"&gt;:accepts&lt;/span&gt;, [&lt;span class="st"&gt;&amp;quot;json&amp;quot;&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" data-line-number="10"&gt;  scope &lt;span class="st"&gt;&amp;quot;/api&amp;quot;&lt;/span&gt;, &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" data-line-number="11"&gt;    pipe_through(&lt;span class="va"&gt;:api&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" data-line-number="12"&gt;    resources(&lt;span class="st"&gt;&amp;quot;/todos&amp;quot;&lt;/span&gt;, &lt;span class="cn"&gt;TodoController&lt;/span&gt;, &lt;span class="va"&gt;only:&lt;/span&gt; [&lt;span class="va"&gt;:index&lt;/span&gt;, &lt;span class="va"&gt;:create&lt;/span&gt;, &lt;span class="va"&gt;:update&lt;/span&gt;, &lt;span class="va"&gt;:delete&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" data-line-number="14"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次にコントロラーを定義し，&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;TodoController&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;  &lt;span class="im"&gt;alias&lt;/span&gt; &lt;span class="cn"&gt;Models&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Todo&lt;/span&gt;, &lt;span class="va"&gt;as:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:controller&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; index(conn, _params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; create(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; update(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; delete(conn, %{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; id}), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt; })&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;...&lt;/code&gt; の部分は後で埋める) そして View を定義する。&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;TodoView&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTodoAppWeb&lt;/span&gt;, &lt;span class="va"&gt;:view&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; render(&lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; todos}), &lt;span class="kw"&gt;do&lt;/span&gt;: todos&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;さてここから　Elchemy だ。 モデルを Elchemy で定義する. というかモデル以外はマクロ色が強過ぎてうまくいかなかった.&lt;/p&gt;
&lt;h3 id="elchemy-でモデルを"&gt;Elchemy でモデルを&lt;/h3&gt;
&lt;p&gt;まずは型を定義.&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Data.Todo exposing (..)
import Dict

type alias Todo =
    { id : String
    , title : String
    , done : Bool
    }

type alias Todos =
    Dict.Dict String Todo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここはフロント共有したいので別途切り出しておく. DBをサボるために GenServer なモデルを定義する.&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Models.Todo exposing (..)

import Data.Todo exposing (Todo, Todos)
import Dict
import Elchemy exposing (..)

{- ex
   use GenServer

   def start_link(init \\ %{ todos: %{}, cnt: 0 }), do: GenServer.start_link(__MODULE__, init, name: :todos)

   def init(state), do: {:ok, state}

   def handle_call(:get, _client, state), do: {:reply, state, state}

   def handle_cast({:set, new_state}, _state), do: {:noreply, new_state}

   def gen_(params) do
     %{
       id: params[&amp;quot;id&amp;quot;],
       title: params[&amp;quot;title&amp;quot;],
       done: params[&amp;quot;done&amp;quot;]
     }
   end
-}

type alias State =
    { todos : Todos
    , cnt : Int
    }

type Name
    = Todos

type Action
    = Get
    | Set State

gen : params -&amp;gt; Todo
gen = ffi &amp;quot;Models.Todo&amp;quot; &amp;quot;gen_&amp;quot;

getState : State
getState = call_ Todos Get

setState : State -&amp;gt; State
setState state = cast_ Todos (Set state) |&amp;gt; always state

call_ : Name -&amp;gt; Action -&amp;gt; a
call_ = ffi &amp;quot;GenServer&amp;quot; &amp;quot;call&amp;quot;

cast_ : Name -&amp;gt; Action -&amp;gt; a
cast_ = ffi &amp;quot;GenServer&amp;quot; &amp;quot;cast&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Todos&lt;/code&gt; と削除された &lt;code&gt;Todo&lt;/code&gt; も含めた総数を表した &lt;code&gt;Int&lt;/code&gt; を持った &lt;code&gt;State&lt;/code&gt; 型を状態として GenServer に保持して欲しい． 出力した Elixir コードにだけモジュールをインポートさせたり，うまく型付けできない関数を Elixir コードに張り付けるには，コメントアウト &lt;code&gt;{- ex ... -}&lt;/code&gt; 使う． この中に書いた Elixir コードはそのまま出力先に貼り付けられる(濫用厳禁！)．&lt;/p&gt;
&lt;p&gt;Elixir モジュールの関数を呼び出すには &lt;code&gt;Elchemy&lt;/code&gt; モジュールにある &lt;code&gt;ffi&lt;/code&gt; 関数を使う． ただし，&lt;code&gt;ffi&lt;/code&gt; 関数をファーストクラスには扱えない． 次のようなエラーが出る．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ffi inside function body is deprecated since Elchemy 0.3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Name&lt;/code&gt; 型や &lt;code&gt;Action&lt;/code&gt; 型は Elchemy が代数的データ型をアトムとタプルに変換することと，GenServer の使い方を知っていれば意図するところが分かるだろう． 逆にそれらを知っていなければ読みとれないと思う…&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;コントローラーから呼ばれるインターフェースは &lt;code&gt;getState&lt;/code&gt; と &lt;code&gt;setState&lt;/code&gt; を用いることで簡単に書けた．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;gets : List Todo
gets = Dict.values (.todos getState)

add : Todo -&amp;gt; List Todo
add todo =
    let
        { todos, cnt } = getState
        newId   = toString cnt
        newTodo = { todo | id = newId }
        state   = { todos = Dict.insert newId newTodo todos, cnt = cnt + 1 }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values

update : Todo -&amp;gt; List Todo
update todo =
    let
        { todos, cnt } = getState
        state = { todos = Dict.update todo.id (Maybe.map &amp;lt;| always todo) todos, cnt = cnt }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values

remove : String -&amp;gt; List Todo
remove todoId =
    let
        { todos, cnt } =
            getState
        state =
            { todos = Dict.remove todoId todos, cnt = cnt }
    in
    setState state
        |&amp;gt; .todos
        |&amp;gt; Dict.values&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;コントローラーの &lt;code&gt;...&lt;/code&gt; を書き換えてやれば完成だ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb21-1" data-line-number="1"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; index(conn, _params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gets()})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" data-line-number="2"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; create(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;add(&lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gen(params))})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" data-line-number="3"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; update(conn, params), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;update(&lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;gen(params))})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; delete(conn, %{&lt;span class="st"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="op"&gt;=&amp;gt;&lt;/span&gt; id}), &lt;span class="kw"&gt;do&lt;/span&gt;: render(conn, &lt;span class="st"&gt;&amp;quot;todos.json&amp;quot;&lt;/span&gt;, %{&lt;span class="va"&gt;todos:&lt;/span&gt; &lt;span class="cn"&gt;Todo&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;remove(id)})&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" data-line-number="5"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ちなみに出力された Elixir コードは&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/data/todo.elchemy.ex"&gt;ココ&lt;/a&gt;と&lt;a href="https://gitlab.com/matsubara0507/elchemy_todo_app/blob/443777cee3e8435ee15f04ada6437e41e3af064b/lib/models/todo.elchemy.ex"&gt;ココ&lt;/a&gt;です． 興味がある人は見てください．&lt;/p&gt;
&lt;h3 id="elm-brunch"&gt;Elm Brunch&lt;/h3&gt;
&lt;p&gt;Brunch 設定が難しかったので，本質的には Elchemy と関係ないけど残しておく．&lt;/p&gt;
&lt;p&gt;Phoenix 1.3 系ではトップレベルに &lt;code&gt;assets&lt;/code&gt; というディレクトリがあり，HTML/JS/CSS/画像 のような静的ファイルはここに置いておく． Brunch を使って複数の JS や CSS を合わせることが出来る． &lt;a href="https://github.com/madsflensted/elm-brunch"&gt;elm-brunch&lt;/a&gt; を使うことで Elm を JS にコンパイルしてくれる．&lt;/p&gt;
&lt;p&gt;branch-config に次のような設定を書き加えてあげる． Elm のフロントコードは &lt;code&gt;lib/web/elm&lt;/code&gt; に置いてある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode javascript"&gt;&lt;code class="sourceCode javascript"&gt;&lt;a class="sourceLine" id="cb22-1" data-line-number="1"&gt;&lt;span class="va"&gt;exports&lt;/span&gt;.&lt;span class="at"&gt;config&lt;/span&gt; &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" data-line-number="2"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" data-line-number="3"&gt;  &lt;span class="dt"&gt;paths&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" data-line-number="4"&gt;    &lt;span class="dt"&gt;watched&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;static&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;css&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;js&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;vendor&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../lib/web/elm&amp;quot;&lt;/span&gt;]&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" data-line-number="5"&gt;    &lt;span class="dt"&gt;public&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../priv/static&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-6" data-line-number="6"&gt;  &lt;span class="op"&gt;},&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-8" data-line-number="8"&gt;  &lt;span class="dt"&gt;plugins&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-9" data-line-number="9"&gt;    &lt;span class="dt"&gt;elmBrunch&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="op"&gt;{&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-10" data-line-number="10"&gt;      &lt;span class="dt"&gt;elmFolder&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;../lib/web/elm&amp;quot;&lt;/span&gt;&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-11" data-line-number="11"&gt;      &lt;span class="dt"&gt;mainModules&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; [&lt;span class="st"&gt;&amp;quot;Main.elm&amp;quot;&lt;/span&gt;]&lt;span class="op"&gt;,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-12" data-line-number="12"&gt;      &lt;span class="dt"&gt;outputFolder&lt;/span&gt;&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;vendor&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-13" data-line-number="13"&gt;    &lt;span class="op"&gt;},&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-14" data-line-number="14"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-15" data-line-number="15"&gt;  &lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-16" data-line-number="16"&gt;  ...&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-17" data-line-number="17"&gt;&lt;span class="op"&gt;}&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="フロント部分"&gt;フロント部分&lt;/h3&gt;
&lt;p&gt;ほんの少しだがコードを再利用できる． API クライアントは以下のようになる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module TodoAPI exposing (..)

import Data.Todo exposing (Todo)
import Http

getTodos : Http.Request (List Todo)
getTodos =
    Http.request
        { method =
            &amp;quot;GET&amp;quot;
        , headers =
            []
        , url =
            String.join &amp;quot;/&amp;quot;
                [ baseUrl
                , &amp;quot;todos&amp;quot;
                ]
        , body =
            Http.emptyBody
        , expect =
            Http.expectJson (list decodeTodo)
        , timeout =
            Nothing
        , withCredentials =
            False
        }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ホントはこの当たりも Elchemy を使って生成できるとよいのだが… もしかして &lt;a href="https://github.com/saschatimme/elm-phoenix"&gt;elm-phoenix&lt;/a&gt; なるものを使えばよかったのかな？ また，The Elm Architecture 部分は長いので割愛．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;ホントは assets 回りが他にもたくさんあるが,本質的な部分はこれで完成． あとはモロモロインストールして &lt;code&gt;mix phx.server&lt;/code&gt; とすれば動作するはずだ．&lt;/p&gt;
&lt;h3 id="感想"&gt;感想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;うれしみ&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;静的検査は神&lt;/li&gt;
&lt;li&gt;フロントとコードを共有できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;つらみ&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Phoenix のいくつかは型付けできない
&lt;ul&gt;
&lt;li&gt;ルーティングの引数&lt;/li&gt;
&lt;li&gt;へテロリストのようなモノ&lt;/li&gt;
&lt;li&gt;結局ここで良く分からんエラーに…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンパイルが遅い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;今度は処理系の中身でも追ってみようかな．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html</id><title type="text">Elchemy 入門 : その１</title><updated>2018-06-15T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-06-15-introduce-elchemy-part1.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Elchemy 入門 : その１&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-06-15" itemprop="datePublished"&gt;
        Jun 15, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Elchemy.html"&gt;Elchemy&lt;/a&gt; &lt;a href="/tags/Elm.html"&gt;Elm&lt;/a&gt; &lt;a href="/tags/Elixir.html"&gt;Elixir&lt;/a&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;Elm から Elixir のトランスパイラ，&lt;a href="https://github.com/wende/elmchemy"&gt;Elchemy&lt;/a&gt; についてイロイロと調べたのでまとめていきます． 今回は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wende/elchemy/blob/9184d758dc1d5d5d3209302f9742c11fe01aa92c/README.md"&gt;README&lt;/a&gt; の意訳&lt;/li&gt;
&lt;li&gt;Dockerイメージ作成&lt;/li&gt;
&lt;li&gt;Tutorial その１をやってみた&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の3本立てです． ちなみに，現在のバージョンは 0.7.4 です．&lt;/p&gt;
&lt;h2 id="readme-意訳"&gt;README 意訳&lt;/h2&gt;
&lt;p&gt;Elchemy は，Elixir の強力なエコシステムと Elm の型安全によって，より簡潔に高速に高品質で型安全なコードを記述するために作られた処理系です．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://elchemy-live.herokuapp.com"&gt;Elchemy のオンライン環境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wende.gitbooks.io/elchemy/content/"&gt;Elchemy の公式ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d"&gt;Elchemy のチュートリアル&lt;/a&gt; (今のところ Part1 と Part2 がある)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なにか質問がある場合は &lt;a href="https://github.com/wende/elchemy/labels/Q%26A"&gt;&lt;code&gt;Q&amp;amp;A&lt;/code&gt; ラベルを付けて Issue を書いて&lt;/a&gt;，だそうだ．&lt;/p&gt;
&lt;h3 id="features"&gt;Features&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;型推論:&lt;/strong&gt; 強力な型推論によって型注釈を付けることはめったにない． コンパイラによって全て検査される．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簡単で型安全な呼び出し:&lt;/strong&gt; 余計なボイラープレートなしに Elixir/Erlang のプログラムを呼び出すことが出来る． Elixir の typespec に基づいて可能な限り徹底的に型安全の観点から全ての呼び出しを検査する．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Elm と Elixir のいいとこどり:&lt;/strong&gt; Elchemy は Elm の型安全性と強力な型推論，素晴らしい表現力を継承し，Elixir の Doc-test とツール群，そして BEAM プラットフォームを継承している．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ほとんどないランタイムエラー:&lt;/strong&gt; Elchemy の型システムは &lt;strong&gt;ほぼ全てのランタイムエラーを排除する&lt;/strong&gt; ． エッジケースが少なくなることで，Elchemy のコードそのものは安全になる． ランタイムエラーが発生した場合，おそらく Elixir のところが起こしているのだろう．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;美しくて可読性の高い出力:&lt;/strong&gt; 生成されたコードは慣習的で効率的で元のコードが無くとも読みやすく分析可能である．&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="faq"&gt;FAQ&lt;/h3&gt;
&lt;h4 id="どういう人にお勧めか"&gt;どういう人にお勧めか？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;型が好きな人&lt;/li&gt;
&lt;li&gt;実行時エラーよりコンパイルエラーの方が好みな人&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defp add(a, b), do: b + c&lt;/code&gt; より &lt;code&gt;add b c = b + c&lt;/code&gt; な書き方の方が好みな人&lt;/li&gt;
&lt;li&gt;カリー化が好きな人&lt;/li&gt;
&lt;li&gt;さっさと失敗させるより全て失敗しない方が賢いと思う人&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="どういう人にお勧めじゃないか"&gt;どういう人にお勧めじゃないか？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;もしあなたのプロジェクトが徹底的にテストされたライブラリに依存しておりかつ，あなたが 0 から始まるバージョンを嫌う場合&lt;/li&gt;
&lt;li&gt;モナドを学ぶことで口ひげが伸び視力が弱くなることを恐れる場合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="既にある-elixir-プロジェクトを置き換えるのは可能か"&gt;既にある Elixir プロジェクトを置き換えるのは可能か？&lt;/h4&gt;
&lt;p&gt;可能です． しかし，ナイスでダンディーなコンパイルツールは開発中です．&lt;/p&gt;
&lt;h4 id="上司に-elchemy-に現を抜かしていることがばれるだろうか"&gt;上司に Elchemy に現を抜かしていることがばれるだろうか？&lt;/h4&gt;
&lt;p&gt;Elchemy の出力はコードの可読性を第一級市民として扱っている． コードは適切にインデントされ，コメントは省略されず，できるだけ最適化されている(例えば，case 節は関数のオーバーロードになる)．&lt;/p&gt;
&lt;h4 id="elchemy-1.0.0-はまだ"&gt;Elchemy 1.0.0 はまだ？&lt;/h4&gt;
&lt;p&gt;終わったらね．&lt;/p&gt;
&lt;h4 id="コントリビュートしてもいい"&gt;コントリビュートしてもいい？&lt;/h4&gt;
&lt;p&gt;絶対にしてください．&lt;/p&gt;
&lt;h4 id="型はどのように表される"&gt;型はどのように表される？&lt;/h4&gt;
&lt;p&gt;Elchemy の全ての値コンストラクタはスネークケースのアトムとして表現され，コンストラクタの引数はタプルで表わされる． つまり，Elchemy で &lt;code&gt;MyType 42 &amp;quot;Forty two&amp;quot; Error&lt;/code&gt; という値は &lt;code&gt;{:my_type, 42, &amp;quot;Forty two&amp;quot;, :error}&lt;/code&gt; という Elixir の値となる．&lt;/p&gt;
&lt;p&gt;(Type constructor と書いてあるが正しくは Data constructor あるいは value constructor のはずで，Type application も間違いだと思われる)&lt;/p&gt;
&lt;h4 id="elm-の既存のライブラリを-elchemy-で使えるの"&gt;Elm の既存のライブラリを Elchemy で使えるの？&lt;/h4&gt;
&lt;p&gt;Native モジュールや Port，Elm ランタイムを使わない限りは，それらを安全にインポートして使うことが出来る．&lt;/p&gt;
&lt;h4 id="elixir-の既存のライブラリを-elchemy-で使えるの"&gt;Elixir の既存のライブラリを Elchemy で使えるの？&lt;/h4&gt;
&lt;p&gt;使える． 任意のモジュールの任意の関数を FFI 呼び出しすることが出来る． Elixir モジュール，Erlang モジュール，あるいはマクロであってしても自身の Elchemy コードに含むことが出来る． FFI 呼び出しは Elchemy 内で特別扱いされる． そして，&lt;code&gt;@spec&lt;/code&gt; に基づいた型の解析を行うテストが生成されるため，Elixir コードの型安全性を損なうことは無い． 可読性を向上させるためにも FFI 呼び出しは可能な限り避け，常にドキュメント化と &lt;code&gt;doctest&lt;/code&gt; をすることをお勧めする．&lt;/p&gt;
&lt;h4 id="テストのような-elixir-のマクロは使えるの"&gt;テストのような Elixir のマクロは使えるの？&lt;/h4&gt;
&lt;p&gt;残念ながら，&lt;code&gt;do...end&lt;/code&gt; ブロックのような任意のマクロを書くことはまだできない． 替わりとして，任意の関数に対して次のような Elixir のインラインコードを書くことが出来る．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;{- ex
  code_here
-}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;しかし，それは最後の手段であり，乱用すべきではない．&lt;/p&gt;
&lt;h4 id="elchemy-の-.elm-ファイルをコンパイルするのに-elm-処理系をインストールする必要がある"&gt;Elchemy の &lt;code&gt;.elm&lt;/code&gt; ファイルをコンパイルするのに Elm 処理系をインストールする必要がある？&lt;/h4&gt;
&lt;p&gt;(なんとなく解答的に Elixir 処理系だけで完結できないの？という意味っぽい)&lt;/p&gt;
&lt;p&gt;あなたは Elm のようなコードを書いて Elixir のコードを生成したいのに， Elixir コードの生成を Elixir コードを書いて作りたいですか？&lt;/p&gt;
&lt;h4 id="elchemy-プロジェクト"&gt;Elchemy プロジェクト&lt;/h4&gt;
&lt;p&gt;作者はこの Elchemy プロジェクトそのものを可能な限り Elm で構築したいらしい． &lt;a href="https://github.com/wende/elchemy#maturity-of-the-project"&gt;README にはその達成度が書かれている&lt;/a&gt;． 処理系そのものは，ほとんど Elm になっているようだ(結果として世にも珍しい Elm で書かれたコンパイラが出来ている)． エフェクトや ErlangVM 回りが厳しいらしい．&lt;/p&gt;
&lt;h2 id="dockerイメージ作成"&gt;Dockerイメージ作成&lt;/h2&gt;
&lt;p&gt;ココからが本題．&lt;/p&gt;
&lt;p&gt;新しい言語を軽く試すのに最適なのはやはり Docker だ． Elchemy の Docker イメージは見当たらなかったので作った．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hub.docker.com/r/matsubara0507/elchemy"&gt;matsubara0507/elchemy - Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="できるまで"&gt;できるまで&lt;/h3&gt;
&lt;p&gt;本家の README を読むとわかるように Elchemy でビルドするのに必要なモノは以下の4つ．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node (npm)&lt;/li&gt;
&lt;li&gt;Elixir (ErlangVM)&lt;/li&gt;
&lt;li&gt;Elm&lt;/li&gt;
&lt;li&gt;elm-github-install&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのうち，もっともめんどくさいのは Elixir もとい ErlangVM だと思う． なので base イメージを Elixir にし，ひとつずつ入れていった．&lt;/p&gt;
&lt;p&gt;base イメージにした &lt;a href="https://hub.docker.com/_/elixir/"&gt;Elixir の Docker イメージは公式のモノ&lt;/a&gt;を使う． &lt;a href="https://github.com/erlang/docker-erlang-otp/blob/99ab1e150c3708ce81bc08073cf5793ef67c6a1c/20/Dockerfile#L1"&gt;OSは Debian9 だ&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;Debian への Node のインストールには以下の記事を参考にした．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://atomiyama.com/linux/page/debian-9-2-node-npm/"&gt;debian9.2にNode.jsとnpmをインストールする｜atominux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;こんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode dockerfile"&gt;&lt;code class="sourceCode dockerfile"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; curl -sL https://deb.nodesource.com/setup_${NODE_VERSION} | bash - \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;  &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install -y nodejs \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;  &amp;amp;&amp;amp; apt-get clean \&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;  &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;後は簡単で Elm，elm-github-install，Elchemy は npm からインストールできる． ただし，Elm と elm-github-install には &lt;code&gt;--unsafe-perm=true --allow-root&lt;/code&gt; という&lt;a href="https://github.com/gdotdesign/elm-github-install/issues/21#issuecomment-332827661"&gt;オプションを付けないといけない&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode dockerfile"&gt;&lt;code class="sourceCode dockerfile"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elm@${ELM_VERSION} --unsafe-perm=true --allow-root&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elm-github-install@${ELM_GITHUB_INSTALL_VERSION} --unsafe-perm=true --allow-root&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="kw"&gt;RUN&lt;/span&gt; npm i -g elchemy@${ELCHEMY_VERSION}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="auto-build"&gt;Auto Build&lt;/h3&gt;
&lt;p&gt;Elchemy のリリースを眺めてると想像より開発スピードが速かったので，Elchemy の更新を観測して自動ビルドしてくれる仕組みを作ることにした． シェル芸を駆使すればなんとかなりそうだったが，サクッと Haskell 芸をかまして CLI を作った．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/matsubara0507/dockwright"&gt;matsubara0507/dockwright - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(船大工が &lt;code&gt;shipwright&lt;/code&gt; なので Dockerfile 大工ってことで &lt;code&gt;dockwright&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;以下のような設定を書いておくと &lt;code&gt;dockwright&lt;/code&gt; ってコマンドで GitHub の &lt;code&gt;release&lt;/code&gt; API を叩いてリリースタグを取ってきてくれる． それを Docker 内の環境変数としてテンプレートに書き込む．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="fu"&gt;env:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" data-line-number="2"&gt;  &lt;span class="fu"&gt;elchemy_version:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" data-line-number="3"&gt;    &lt;span class="fu"&gt;github:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" data-line-number="4"&gt;      &lt;span class="fu"&gt;repo:&lt;/span&gt;&lt;span class="at"&gt; wende/elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" data-line-number="5"&gt;      &lt;span class="fu"&gt;hook:&lt;/span&gt;&lt;span class="at"&gt; release&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;あとは git diff で更新をみて更新があればコミットする(コミットさえすれば Docker Hub が自動ビルドしてくれる)． 定期実行は例の如く TravisCI で回す．&lt;/p&gt;
&lt;h2 id="tutorial-そのをやってみた"&gt;Tutorial その１をやってみた&lt;/h2&gt;
&lt;p&gt;以下の記事をやってみる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/elmchemy-write-type-safe-elixir-code-with-elms-syntax-part-1-introduction-8968b76d721d"&gt;Elmchemy — Write type-safe Elixir code with Elm’s syntax — part 1 — Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まずは &lt;code&gt;article_example_elchemy&lt;/code&gt; というプロジェクトを作る． 記事内では &lt;code&gt;mix new&lt;/code&gt; をして &lt;code&gt;elchemy init&lt;/code&gt; をしろと書いてあるが，最新の Elchemy では &lt;code&gt;elchemy new&lt;/code&gt; をすることで一気にやってくれる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ elchemy new article_example_elchemy&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elchemy をコンパイルするためには，&lt;code&gt;mix.exs&lt;/code&gt; を次のように&lt;a href="https://wende.gitbooks.io/elchemy/content/INSTALLATION.html"&gt;書き換える必要がある&lt;/a&gt;．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;MyProject&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Mixfile&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Mix&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Project&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; project &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" data-line-number="5"&gt;    [&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" data-line-number="6"&gt;      &lt;span class="va"&gt;app:&lt;/span&gt; &lt;span class="va"&gt;:my_project&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" data-line-number="7"&gt;      &lt;span class="va"&gt;version:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" data-line-number="8"&gt;      &lt;span class="va"&gt;elixir:&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;~&amp;gt; 1.5&amp;quot;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" data-line-number="9"&gt;      &lt;span class="va"&gt;start_permanent:&lt;/span&gt; &lt;span class="cn"&gt;Mix&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;env &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;:prod&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" data-line-number="10"&gt;      &lt;span class="va"&gt;deps:&lt;/span&gt; deps()&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" data-line-number="11"&gt;    ] &lt;span class="op"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="cn"&gt;Code&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;eval_file(&lt;span class="st"&gt;&amp;quot;elchemy.exs&amp;quot;&lt;/span&gt;)&lt;span class="op"&gt;.&lt;/span&gt;init &lt;span class="co"&gt;# ココ!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" data-line-number="12"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" data-line-number="13"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;|&amp;gt; Code.eval_file(&amp;quot;elchemy.exs&amp;quot;).ini&lt;/code&gt; の部分を書き加えている．&lt;/p&gt;
&lt;h3 id="ディレクトリ構成"&gt;ディレクトリ構成&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;elchemy new&lt;/code&gt; した結果はこんな感じ(バージョンによっては違うかもしれない)．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;projrct_name
  |- .elchemy.exs
  |- .formatter.exs
  |- .gitignore
  |- README.md
  |- config
  |   \- config.exs
  |- elm
  |   \- Hello.elm
  |- elm-package.json
  |- lib
  |   \- project_name.ex
  |- mix.exs
  \- test
      |- elchemy_test.exs
      |- project_name_test.exs
      \- test_helper.exs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.elchemy.exs&lt;/code&gt; は &lt;code&gt;mix&lt;/code&gt; コマンドを Elchemy で上書きするための &lt;code&gt;mix&lt;/code&gt; 設定ファイルで，残りは Elixir と Elm のプロジェクトファイルが混ざっている． ちなみに &lt;code&gt;.formatter.exs&lt;/code&gt; は Elixir 1.6 で追加された Elixir のフォーマッターの設定ファイルだ．&lt;/p&gt;
&lt;h3 id="関数を定義してみる"&gt;関数を定義してみる&lt;/h3&gt;
&lt;p&gt;試しに，総和を求める &lt;code&gt;sum&lt;/code&gt; 関数を書いてみる． &lt;code&gt;elm/Hello.elm&lt;/code&gt; に書き加えるとして，まずはユニットテストを &lt;code&gt;test\elchemy_test.exs&lt;/code&gt; に Elixir の文脈で書き加えてみる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb8-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;ElchemyTest&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;ExUnit&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;&lt;span class="cn"&gt;Case&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" data-line-number="3"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" data-line-number="4"&gt;  doctest &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" data-line-number="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" data-line-number="6"&gt;  test &lt;span class="st"&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" data-line-number="7"&gt;    assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;hello() &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;world!&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" data-line-number="8"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" data-line-number="10"&gt;  test &lt;span class="st"&gt;&amp;quot;Sum of lists&amp;quot;&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" data-line-number="11"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" data-line-number="12"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([&lt;span class="dv"&gt;2&lt;/span&gt;]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" data-line-number="13"&gt;     assert &lt;span class="cn"&gt;Hello&lt;/span&gt;&lt;span class="op"&gt;.&lt;/span&gt;sum([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;-1&lt;/span&gt;, &lt;span class="dv"&gt;-2&lt;/span&gt;, &lt;span class="dv"&gt;-3&lt;/span&gt;]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" data-line-number="14"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-15" data-line-number="15"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次に &lt;code&gt;elm/Hello.elm&lt;/code&gt; に以下の関数を書き加える．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;sum : List a -&amp;gt; Int
sum list =
    case list of
        first :: rest -&amp;gt;
            first + sum rest

        [] -&amp;gt;
            0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とりあえずビルドしてみる．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix test
warning: redefining module ElchemyInit (current version defined in memory)
  elchemy.exs:1

==&amp;gt; elchemy
Compiling 24 files (.ex)
warning: unused alias XMaybe
  lib/Elchemy/XRegex.elchemy.ex:28

warning: unused import Elchemy.XBasics
  lib/Elchemy/XChar.elchemy.ex:25

warning: unused import Elchemy.XBasics
  lib/Elchemy/XBitwise.elchemy.ex:6

warning: unused import Elchemy.Macros
  lib/Elchemy/Plugins/Ex_unit.elchemy.ex:7

warning: unused import Elchemy.Macros
  lib/Elchemy/Tests/Ex_unit_test.elchemy.ex:7

Generated elchemy app
==&amp;gt; article_example_elchemy
/usr/bin/elchemy
-- Copying Elixir native files --
-- Compiling Elm files --
----------
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The left argument of (+) is causing a type mismatch.

21|             first + sum rest
                ^^^^^
(+) is expecting the left argument to be a:

    number

But the left argument is:

    a

Hint: Your type annotation uses type variable `a` which means any type of value
can flow through. Your code is saying it CANNOT be anything though! Maybe change
your type annotation to be more specific? Maybe the code has a problem? More at:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&amp;gt;

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;いろいろ出ているが重要なのは &lt;code&gt;The left argument of (+) is causing a type mismatch.&lt;/code&gt; の部分． 型検査した結果，型が合わなかったのだ． 念のため型検査器の言い分を補足しておくと，&lt;code&gt;sum&lt;/code&gt; 関数の引数として &lt;code&gt;List a&lt;/code&gt; 型の値 &lt;code&gt;list&lt;/code&gt; の要素である &lt;code&gt;first&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; 型と推論されるが，加算 &lt;code&gt;(+)&lt;/code&gt; は &lt;code&gt;number&lt;/code&gt; 型じゃないといけない，ということだ(&lt;code&gt;number&lt;/code&gt; 型は加算や乗算が実装されている多相型)．&lt;/p&gt;
&lt;p&gt;言われた通りに変えてみよう．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;sum : List number -&amp;gt; Int
sum list = ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ビルドする．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mix test
...
Type Checking elm/Hello.elm
-- TYPE MISMATCH ------------------------------------------------- elm/Hello.elm

The right side of (+) is causing a type mismatch.

21|             first + sum rest
                        ^^^^^^^^
(+) is expecting the right side to be a:

    number

But the right side is:

    Int

Hint: Your type annotation uses type variable `number` which means any type of
value can flow through. Your code is saying it CANNOT be anything though! Maybe
change your type annotation to be more specific? Maybe the code has a problem?
More at:
&amp;lt;https://github.com/elm-lang/elm-compiler/blob/0.18.0/hints/type-annotations.md&amp;gt;

Hint: With operators like (+) I always check the left side first. If it seems
fine, I assume it is correct and check the right side. So the problem may be in
how the left and right arguments interact.

Detected errors in 1 module.
Type Check failed
** (Mix) Elchemy failed the compilation with an error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;(+) is expecting the right side to be a&lt;/code&gt; というエラーメッセージに変わった． これは &lt;code&gt;sum&lt;/code&gt; 関数の返り値の型が &lt;code&gt;Int&lt;/code&gt; なので &lt;code&gt;sum rest&lt;/code&gt; の型は &lt;code&gt;Int&lt;/code&gt; と推論されたが，&lt;code&gt;first&lt;/code&gt; の型が &lt;code&gt;number&lt;/code&gt; なので &lt;code&gt;(+)&lt;/code&gt; 演算子の左右の型が合わない，ということだ． なので， &lt;code&gt;sum : List Int -&amp;gt; Int&lt;/code&gt; とすると無事ビルドが通る．&lt;/p&gt;
&lt;h3 id="変換された-elixir-コード"&gt;変換された Elixir コード&lt;/h3&gt;
&lt;p&gt;ちなみに，次のような Elixir コードに変換されている．&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb13-1" data-line-number="1"&gt;&lt;span class="kw"&gt;defmodule&lt;/span&gt; &lt;span class="cn"&gt;Hello&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" data-line-number="2"&gt;  &lt;span class="im"&gt;use&lt;/span&gt; &lt;span class="cn"&gt;Elchemy&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" data-line-number="3"&gt;  &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" data-line-number="4"&gt;  &lt;span class="ot"&gt;@spec&lt;/span&gt; sum(list(integer)) :: integer&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" data-line-number="5"&gt;  curry sum&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" data-line-number="6"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; sum(list) &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" data-line-number="7"&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; list &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" data-line-number="8"&gt;      [first &lt;span class="op"&gt;|&lt;/span&gt; rest] &lt;span class="op"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" data-line-number="9"&gt;        (first &lt;span class="op"&gt;+&lt;/span&gt; sum(rest))&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" data-line-number="10"&gt;      [] &lt;span class="op"&gt;-&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" data-line-number="11"&gt;        &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" data-line-number="12"&gt;    &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" data-line-number="13"&gt;  &lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" data-line-number="14"&gt;&lt;span class="kw"&gt;end&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="doctest"&gt;doctest&lt;/h3&gt;
&lt;p&gt;また，次のように書くことで doctest も変換してくれる．&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;{-| Returns a sum of every integer int the function

    sum [1,2,3] == 6
    sum [10] == 10
    sum [] == 0

-}
sum : List Int -&amp;gt; Int
sum list = ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;変換先はこうだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode elixir"&gt;&lt;code class="sourceCode elixir"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;  &lt;span class="ot"&gt;@doc &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;&lt;span class="co"&gt;  Returns a sum of every integer int the function&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" data-line-number="4"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" data-line-number="5"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([1, 2, 3])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-6" data-line-number="6"&gt;&lt;span class="co"&gt;      6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-7" data-line-number="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-8" data-line-number="8"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-9" data-line-number="9"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([10])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-10" data-line-number="10"&gt;&lt;span class="co"&gt;      10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-11" data-line-number="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-12" data-line-number="12"&gt;&lt;span class="co"&gt;      iex&amp;gt; import Hello&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-13" data-line-number="13"&gt;&lt;span class="co"&gt;      iex&amp;gt; sum([])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-14" data-line-number="14"&gt;&lt;span class="co"&gt;      0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-15" data-line-number="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-16" data-line-number="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-17" data-line-number="17"&gt;&lt;span class="co"&gt;  &lt;/span&gt;&lt;span class="ot"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-18" data-line-number="18"&gt;  &lt;span class="ot"&gt;@spec&lt;/span&gt; sum(list(integer)) :: integer&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-19" data-line-number="19"&gt;  curry sum&lt;span class="op"&gt;/&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-20" data-line-number="20"&gt;  &lt;span class="kw"&gt;def&lt;/span&gt; sum(list) &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-21" data-line-number="21"&gt;    &lt;span class="op"&gt;...&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="おしまい"&gt;おしまい&lt;/h2&gt;
&lt;p&gt;次はアプリケーションを作りたい．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html</id><title type="text">[linux][cygwin] unzipコマンドで "error:  invalid compressed data to inflate" というエラーメッセージがでたら？</title><updated>2018-06-06T01:11:48.468+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/06/linuxcygwin-unzip-error-invalid.html"/><summary type="text">zipアーカイブの中に長さが0のファイルが含まれていると、unzipコマンドでは以下のようなエラーメッセージが表示されて、解凍することができません。アーカイブが壊れていなくてもエラーになります。
% unzip hoge.zip
  error:  invalid compressed data to inflate

このような場合には、-tzipオプションを指定して7zコマンドを実行することで、エラーを回避して解凍できます。パスワード保護されているzipアーカイブも問題なく解凍できました。

% 7z x -tzip hoge.zip


manページによると、以下のフォーマットがサポートされていて、デフォルトは7zとのこと。

The program supports 7z (that implements  LZMA  compression  algorithm),  
ZIP</summary></entry><entry><id>https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html</id><title type="text">Haskell で型安全に YAML ファイルをビルド時に埋め込む</title><updated>2018-05-13T00:00:00Z</updated><author><name>matsubara0507</name></author><link href="https://matsubara0507.github.io/posts/2018-05-13-yaml-th.html"/><summary type="html">&lt;article class="post card" itemscope itemtype="http://schema.org/BlogPosting"&gt;
 &lt;div class="card-content"&gt;
  &lt;header class="post-header"&gt;
    &lt;h1 class="post-title" itemprop="name headline"&gt;Haskell で型安全に YAML ファイルをビルド時に埋め込む&lt;/h1&gt;
    &lt;p class="post-meta"&gt;
      &lt;time datetime="2018-05-13" itemprop="datePublished"&gt;
        May 13, 2018
      &lt;/time&gt;
      
      
      &lt;div class="tags"&gt;
          &lt;i class="fa fa-tags"&gt;&lt;/i&gt; &lt;a href="/tags/Haskell.html"&gt;Haskell&lt;/a&gt; &lt;a href="/tags/extensible-package.html"&gt;extensible-package&lt;/a&gt;
      &lt;/div&gt;
      
    &lt;/p&gt;
  &lt;/header&gt;

  &lt;div class="post-content" itemprop="articleBody"&gt;
    &lt;p&gt;ザックリ言えば「&lt;a href="https://ryota-ka.hatenablog.com/entry/2018/02/14/103000"&gt;Template Haskell でコード中に JSON を埋め込んだりコンパイル時にファイルから型安全に読み込んだりする - ryota-ka’s blog&lt;/a&gt;」という記事の YAML 版です．&lt;/p&gt;
&lt;p&gt;ただし，ryota さんの記事では Template Haskell を解説しながら JSON を読み込む関数を定義していますが， YAML 版は &lt;a href="https://hackage.haskell.org/package/yaml"&gt;yaml&lt;/a&gt; パッケージに同様の関数が既にあるので特に解説はしません． あくまでも Haskell の型システムとメタプログラミングを感じてもらえたらなぁと．&lt;/p&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;p&gt;ソースコードは全てこの&lt;a href="https://github.com/matsubara0507/sample-yaml-th"&gt;リポジトリ&lt;/a&gt;にまとめてある．&lt;/p&gt;
&lt;h1 id="yaml-を埋め込む"&gt;YAML を埋め込む&lt;/h1&gt;
&lt;p&gt;次のような設定ファイルに関する型があったとします．&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb1-1" data-line-number="1"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" data-line-number="2"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" data-line-number="3"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" data-line-number="4"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yaml パッケージで YAML にデコードするためには &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; の &lt;a href="https://hackage.haskell.org/package/aeson-1.3.1.1/docs/Data-Aeson.html#t:FromJSON"&gt;&lt;code&gt;FromJSON&lt;/code&gt;&lt;/a&gt; 型クラスのインスタンスである必要がある． &lt;code&gt;FromJSON&lt;/code&gt; のインスタンスに凝ってもしょうがないので，今回は &lt;code&gt;Generics&lt;/code&gt; を使って適当に定義する．&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb2-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="dt"&gt;GHC.Generics&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" data-line-number="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" data-line-number="9"&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;FromJSON&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Config&lt;/code&gt; 型のデフォルト値を YAML ファイルで記述したいとする．&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb3-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" data-line-number="3"&gt;&lt;span class="fu"&gt;languageExtensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これをコンパイル時に埋め込んでかつ型検査も行いたい． そのためには Template Haskell と yaml パッケージの &lt;a href="https://hackage.haskell.org/package/yaml-0.8.30/docs/Data-Yaml-TH.html#v:decodeFile"&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt;&lt;/a&gt; 関数を用いる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb4-1" data-line-number="1"&gt;&lt;span class="ot"&gt;decodeFile ::&lt;/span&gt; (&lt;span class="dt"&gt;Lift&lt;/span&gt; a, &lt;span class="dt"&gt;FromJSON&lt;/span&gt; a) &lt;span class="ot"&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; (&lt;span class="dt"&gt;TExp&lt;/span&gt; a)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;TExp a&lt;/code&gt; 型というのは型付きの &lt;code&gt;Exp&lt;/code&gt; 型らしいが，ぼくはあまりよく分からないので割愛． 型を見ればわかるように，&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにもなってなきゃいけない． &lt;code&gt;DerivingLift&lt;/code&gt; 言語拡張を使えば簡単に定義できる．&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb5-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DeriveLift #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" data-line-number="2"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; import &lt;span class="dt"&gt;Language.Haskell.TH.Syntax&lt;/span&gt; &lt;span class="co"&gt;-- template-haskell package&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" data-line-number="4"&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" data-line-number="5"&gt;  {&lt;span class="ot"&gt; columns ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" data-line-number="6"&gt;  ,&lt;span class="ot"&gt; languageExtensions ::&lt;/span&gt; [&lt;span class="dt"&gt;String&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" data-line-number="7"&gt;  } &lt;span class="kw"&gt;deriving&lt;/span&gt; (&lt;span class="dt"&gt;Show&lt;/span&gt;, &lt;span class="dt"&gt;Eq&lt;/span&gt;, &lt;span class="dt"&gt;Generic&lt;/span&gt;, &lt;span class="dt"&gt;Lift&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使い方は簡単で，次のようにすればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb6-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" data-line-number="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" data-line-number="3"&gt;&lt;span class="ot"&gt;defaultConfig ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" data-line-number="4"&gt;defaultConfig &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;$$&lt;/span&gt;(decodeFile &lt;span class="st"&gt;&amp;quot;./template/.config.yaml&amp;quot;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点として，Template Haskell の制約より &lt;code&gt;Config&lt;/code&gt; 型の定義と &lt;code&gt;defaultConfig&lt;/code&gt; 関数の定義は別ファイルに分けなければいけない．&lt;/p&gt;
&lt;h2 id="試す"&gt;試す&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; defaultConfig
Config {columns = 80, languageExtensions = []}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;試しに間違えてみよう&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat template/.config.yaml
column: 80
languageExtensions: []
$ stack build
sample-yaml-th-0.1.0.0: build (lib)
Preprocessing library for sample-yaml-th-0.1.0.0..
Building library for sample-yaml-th-0.1.0.0..
[1 of 2] Compiling Sample.Config.Internal ( src\Sample\Config\Internal.hs, .stack work\dist\5c8418a7\build\Sample\Config\Internal.o )
[2 of 2] Compiling Sample.Config    ( src\Sample\Config.hs, .stack-work\dist\5c8418a7\build\Sample\Config.o )

C:\Users\hoge\haskell\sample-yaml-th\src\Sample\Config.hs:14:20: error:
    • Aeson exception:
Error in $: key &amp;quot;columns&amp;quot; not present
    • In the Template Haskell splice
        $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In the expression: $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
      In an equation for ‘defaultConfig’:
          defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |
14 | defaultConfig = $$(Y.decodeFile &amp;quot;./template/.config.yaml&amp;quot;)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="おまけ-with-extensible"&gt;おまけ : with Extensible&lt;/h1&gt;
&lt;p&gt;さぁココからが本題！ &lt;a href="https://hackage.haskell.org/package/extensible"&gt;extensible&lt;/a&gt; という神パッケージを使ってリファクタリングをしてみよう！！&lt;/p&gt;
&lt;h2 id="問題点"&gt;問題点&lt;/h2&gt;
&lt;p&gt;大した問題ではないんだけど&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;ファイルを分けなければいけないのが悲しい&lt;/li&gt;
&lt;li&gt;YAML のキーがキャメルケース(&lt;code&gt;languageExtensions&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="extensible-パッケージ"&gt;extensible パッケージ&lt;/h2&gt;
&lt;p&gt;言わずもがな，拡張可能なレコードやバリアントを提供するパッケージだ． (詳しくは，最近急ピッチで充実されている&lt;a href="https://wiki.hask.moe/"&gt;攻略Wiki&lt;/a&gt;を読むといいんじゃないんかな？)&lt;/p&gt;
&lt;p&gt;例えば，さっきから使っている &lt;code&gt;Config&lt;/code&gt; 型を &lt;code&gt;extensible&lt;/code&gt; レコード型で書くと次のように書ける&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb9-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE DataKinds     #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE TypeOperators #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" data-line-number="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" data-line-number="4"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" data-line-number="5"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" data-line-number="6"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" data-line-number="7"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;地味にうれしいことに，extensible であれば関数名では許されないハイフンが含んだフィールド名も定義できるのだ．&lt;/p&gt;
&lt;h2 id="リファクタリング"&gt;リファクタリング&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Data.Yaml.TH.decodeFile&lt;/code&gt; を使うには &lt;code&gt;FromJSON&lt;/code&gt; 型クラスと &lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスにしなければいけない． でも安心して欲しい． どちらも最新の extensible-0.4.9 では定義済みだ(そして extensible のレコードは &lt;code&gt;type&lt;/code&gt; 宣言なので追加でインスタンスを定義する必要は無い)．&lt;/p&gt;
&lt;p&gt;ただし，extensible-0.4.9 はまだ Stackage の LTS にも nightly にも追加されていないので &lt;code&gt;stack.yaml&lt;/code&gt; に追加する必要がある．&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb10-1" data-line-number="1"&gt;&lt;span class="fu"&gt;resolver:&lt;/span&gt;&lt;span class="at"&gt; lts-11.9&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" data-line-number="2"&gt;&lt;span class="fu"&gt;packages:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" data-line-number="3"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; .&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" data-line-number="4"&gt;&lt;span class="fu"&gt;extra-deps:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" data-line-number="5"&gt;&lt;span class="kw"&gt;-&lt;/span&gt; extensible-0.4.9&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Lift&lt;/code&gt; 型クラスのインスタンスは extensible で定義済みなので1つ目のファイルを分けるはクリアーだ． 実は2つもクリアーしている． 拡張可能レコードの &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスは &lt;code&gt;&amp;quot;path-format&amp;quot;&lt;/code&gt; のようなハイフンを含んだ文字列もそのまま扱ってくれる．&lt;/p&gt;
&lt;p&gt;以下が extensible 版の &lt;code&gt;Config&lt;/code&gt; 型に対応する YAML ファイルだ．&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode yaml"&gt;&lt;code class="sourceCode yaml"&gt;&lt;a class="sourceLine" id="cb11-1" data-line-number="1"&gt;&lt;span class="co"&gt;# template/.extensible-config.yaml&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" data-line-number="2"&gt;&lt;span class="fu"&gt;columns:&lt;/span&gt;&lt;span class="at"&gt; 80&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" data-line-number="3"&gt;&lt;span class="fu"&gt;language-extensions:&lt;/span&gt;&lt;span class="at"&gt; &lt;/span&gt;&lt;span class="kw"&gt;[]&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;試しに実行してみよう！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack ghci
&amp;gt;&amp;gt; Sample.Extensible.Config.defaultConfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="デフォルトで置き換える"&gt;デフォルトで置き換える&lt;/h2&gt;
&lt;p&gt;最後に簡単な実行ファイルを実装してみる． 設定ファイルのパスを与えると読みに行き，足りない部分は先ほどから埋め込んでるデフォルト値に置き換えて出力するモノだ．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &amp;quot;./template/.example.yaml&amp;quot;
columns: 100
$ stack exec -- pconfig &amp;quot;./template/.example.yaml&amp;quot;
columns @= 100 &amp;lt;: language-extensions @= [] &amp;lt;: nil
$ stack exec -- pconfig
columns @= 80 &amp;lt;: language-extensions @= [] &amp;lt;: nil&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;もちろんパスにファイルが無ければデフォルトのモノを出力するだけだ．&lt;/p&gt;
&lt;h2 id="section-1"&gt;&lt;/h2&gt;
&lt;p&gt;さてどうすれば良いだろうか？ 例えば，&lt;code&gt;FromJSON&lt;/code&gt; 型クラスの &lt;code&gt;Meybe a&lt;/code&gt; 型のインスタンスはフィールドが無い場合に &lt;code&gt;Nothing&lt;/code&gt; を与えてくれるので， &lt;code&gt;Config&lt;/code&gt; 型の各フィールドを &lt;code&gt;Maybe&lt;/code&gt; でラップするというのはどうだろう．&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb14-1" data-line-number="1"&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Record&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" data-line-number="2"&gt;  &lt;span class="ch"&gt;&amp;#39;[ &amp;quot;root&amp;quot; &amp;gt;: Maybe Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" data-line-number="3"&gt;   , &lt;span class="st"&gt;&amp;quot;path-format&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="dt"&gt;Maybe&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" data-line-number="4"&gt;   ]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;フィールドが2つなら良いが多くなってきたら辛そうだ…&lt;/p&gt;
&lt;h3 id="必殺-nullable"&gt;必殺 Nullable&lt;/h3&gt;
&lt;p&gt;全てを &lt;code&gt;Meybe&lt;/code&gt; でラップする場合は &lt;a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Nullable.html"&gt;&lt;code&gt;Nullable&lt;/code&gt;&lt;/a&gt; を使うと良いだろう(ないしは &lt;code&gt;RecordOf Maybe&lt;/code&gt;)．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nullable h :* xs&lt;/code&gt; も既に &lt;code&gt;FromJson&lt;/code&gt; 型クラスのインスタンスになっているのでそのまま YAML を読み込める． あとは次のようなデフォルト値と &lt;code&gt;Nullable&lt;/code&gt; を与えたら &lt;code&gt;Nothing&lt;/code&gt; の部分だけデフォルト値で置き換えた値を返す関数を実装してやればよい．&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb15-1" data-line-number="1"&gt;&lt;span class="ot"&gt;fromNullable ::&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;Nullable&lt;/span&gt; (&lt;span class="dt"&gt;Field&lt;/span&gt; h) &lt;span class="fu"&gt;:*&lt;/span&gt; xs &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;RecordOf&lt;/span&gt; h xs&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" data-line-number="2"&gt;fromNullable def &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" data-line-number="3"&gt;  hmapWithIndex &lt;span class="fu"&gt;$&lt;/span&gt; \m x &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; fromMaybe (hlookup m def) (getNullable x)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;extensible ならこうやって全てのフィールドに対し走査する関数が使える．&lt;/p&gt;
&lt;h2 id="section-2"&gt;&lt;/h2&gt;
&lt;p&gt;あとはこんな感じ&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode haskell"&gt;&lt;code class="sourceCode haskell"&gt;&lt;a class="sourceLine" id="cb16-1" data-line-number="1"&gt;&lt;span class="ot"&gt;{-# LANGUAGE NoImplicitPrelude #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" data-line-number="2"&gt;&lt;span class="ot"&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" data-line-number="3"&gt;&lt;span class="ot"&gt;{-# LANGUAGE PolyKinds         #-}&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" data-line-number="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" data-line-number="5"&gt;&lt;span class="kw"&gt;module&lt;/span&gt; &lt;span class="dt"&gt;Main&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" data-line-number="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" data-line-number="7"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" data-line-number="8"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;RIO.Directory&lt;/span&gt;      (doesFileExist)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" data-line-number="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" data-line-number="10"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;Data.Extensible&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" data-line-number="11"&gt;&lt;span class="kw"&gt;import&lt;/span&gt; &lt;span class="kw"&gt;qualified&lt;/span&gt; &lt;span class="dt"&gt;Data.Yaml&lt;/span&gt;          &lt;span class="kw"&gt;as&lt;/span&gt; &lt;span class="dt"&gt;Y&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" data-line-number="12"&gt;&lt;span class="kw"&gt;import&lt;/span&gt;           &lt;span class="dt"&gt;System.Environment&lt;/span&gt; (getArgs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" data-line-number="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" data-line-number="14"&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" data-line-number="15"&gt;main &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" data-line-number="16"&gt;  path &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; fromMaybe &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="fu"&gt;.&lt;/span&gt; listToMaybe &lt;span class="fu"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getArgs&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-17" data-line-number="17"&gt;  config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readConfigWith defaultConfig path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-18" data-line-number="18"&gt;  hPutBuilder stdout &lt;span class="fu"&gt;$&lt;/span&gt; encodeUtf8Builder (tshow config)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-19" data-line-number="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-20" data-line-number="20"&gt;&lt;span class="ot"&gt;readConfigWith ::&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;Config&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-21" data-line-number="21"&gt;readConfigWith def path &lt;span class="fu"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-22" data-line-number="22"&gt;  file &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; readFileBinaryWith &lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt; path&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-23" data-line-number="23"&gt;  &lt;span class="kw"&gt;if&lt;/span&gt; Y.decodeEither file &lt;span class="fu"&gt;==&lt;/span&gt; &lt;span class="dt"&gt;Right&lt;/span&gt; &lt;span class="dt"&gt;Y.Null&lt;/span&gt; &lt;span class="kw"&gt;then&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-24" data-line-number="24"&gt;    pure def&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-25" data-line-number="25"&gt;  &lt;span class="kw"&gt;else&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-26" data-line-number="26"&gt;    config &lt;span class="ot"&gt;&amp;lt;-&lt;/span&gt; either (error &lt;span class="fu"&gt;.&lt;/span&gt; show) pure &lt;span class="fu"&gt;$&lt;/span&gt; Y.decodeEither&amp;#39; file&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-27" data-line-number="27"&gt;    pure &lt;span class="fu"&gt;$&lt;/span&gt; fromNullable def config&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-28" data-line-number="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-29" data-line-number="29"&gt;&lt;span class="ot"&gt;readFileBinaryWith ::&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt; &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; FilePath &lt;span class="ot"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; &lt;span class="dt"&gt;ByteString&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-30" data-line-number="30"&gt;readFileBinaryWith def path &lt;span class="fu"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-31" data-line-number="31"&gt;  doesFileExist path &lt;span class="fu"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; bool (pure def) (readFileBinary path)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;いろいろとインポートするのがめんどくさくて &lt;code&gt;rio&lt;/code&gt; ライブラリを使っているが，あんまり気にしないで．&lt;/p&gt;
&lt;h1 id="おしまい"&gt;おしまい&lt;/h1&gt;
&lt;p&gt;ちなみに，&lt;a href="https://matsubara0507.github.io/posts/2018-05-10-make-cli-with-haskell-in-2018.html"&gt;前回の記事&lt;/a&gt;に書いた &lt;a href="https://github.com/matsubara0507/taskpad"&gt;&lt;code&gt;taskpad&lt;/code&gt;&lt;/a&gt; にこの機能を追加してる．&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/article&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180316/1521169933</id><title type="text">TLS 1.3 開発日記 その27 ID 25/26</title><updated>2018-03-16T03:12:13Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180316/1521169933"/><summary type="html">
&lt;div class="section"&gt;
&lt;h4&gt;ドラフト25&lt;/h4&gt;
&lt;p&gt;ドラフト24までは、AEADに使う additonal_data は空文字列だった。ドラフト25からは、&lt;a href="https://github.com/tlswg/tls13-spec/pull/1158" target="_blank"&gt;正しいレコードヘッダが使われることを遵守させるため&lt;/a&gt;に、additonal_dataが以下のように定義された。&lt;/p&gt;
&lt;pre&gt;
       additional_data = TLSCiphertext.opaque_type ||
                         TLSCiphertext.legacy_record_version ||
                         TLSCiphertext.length
&lt;/pre&gt;
&lt;p&gt;以下の TLSCiphertext の構造と見比べれば、これがレコードヘッダそのものであることが分かるだろう。&lt;/p&gt;
&lt;pre&gt;
       struct {
           ContentType opaque_type = application_data; /* 23 */
           ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
           uint16 length;
           opaque encrypted_record[TLSCiphertext.length];
       } TLSCiphertext;
&lt;/pre&gt;
&lt;p&gt;注意したいのは、TLSCiphertext.lengthである。復号化の際は TLSCiphertext.length は、入力の長さを図ればよい。しかし、暗号化の際は AEAD-Encrypt を呼び出す前に、結果の暗号文の長さを計算する必要がある。&lt;/p&gt;
&lt;p&gt;TLS 1.3のAEAD-Encryptは、暗号文+認証タグを生成する。暗号文の長さは、平文の長さに等しい。よって、以下のように計算できる。&lt;/p&gt;
&lt;pre&gt;
      暗号文の長さ = 平文の長さ + 認証タグの長さ
&lt;/pre&gt;
&lt;p&gt;一方 TLS 1.2 では、&lt;a href="http://d.hatena.ne.jp/kazu-yamamoto/20170426/1493186127" target="_blank"&gt;additonal_data に平文(本当は圧縮文)のレコードヘッダを使う&lt;/a&gt;。すなわち、復号化の際にあらかじめ平文の長さを計算しておく必要がある。TLS 1.2 の ADEAD では explicit IV が利用されるので、以下のように平文の長さを計算できる。&lt;/p&gt;
&lt;pre&gt;
      平文の長さ = 暗号文の長さ - explicit IV の長さ - 認証タグの長さ
&lt;/pre&gt;
&lt;h4&gt;ドラフト26&lt;/h4&gt;
&lt;p&gt;supported_versions拡張では、TLS 1.2 以前のバージョンを交渉してはいけないことが明記された。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180306/1520314185</id><title type="text">[Haskell]あなたの知らないSemigroupの世界</title><updated>2018-03-06T05:29:45Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180306/1520314185"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;自分で定義するデータの中には、足し算したくなるようなデータがある。たとえば、送信と受信のカウンターを定義したとしよう。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synType"&gt;data&lt;/span&gt; Metrics &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics {
    rx &lt;span class="synStatement"&gt;::&lt;/span&gt; Int
  , ts &lt;span class="synStatement"&gt;::&lt;/span&gt; Int
  } &lt;span class="synType"&gt;deriving&lt;/span&gt; (Eq, Show)
&lt;/pre&gt;

&lt;p&gt;これは以下のように足し算できると嬉しいだろう。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;+&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;しかしこれは Num のインスタンスにすべきではない。このデータ型に掛け算は定義できないからだ。かといって、addMetrics みたいな関数を定義するのはかっこ悪い。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;`addMetrics`&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;このように演算子が一個だけ欲しいと思ったら、それは多分 Monoid だ。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synPreProc"&gt;import&lt;/span&gt; Data.Monoid

&lt;span class="synType"&gt;instance&lt;/span&gt; Monoid Metrics &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;0&lt;/span&gt; &lt;span class="synConstant"&gt;0&lt;/span&gt;
    Metrics r1 t1 &lt;span class="synStatement"&gt;`mappend`&lt;/span&gt; Metrics r2 t2 &lt;span class="synStatement"&gt;=&lt;/span&gt; Metrics (r1 &lt;span class="synStatement"&gt;+&lt;/span&gt; r2) (t1 &lt;span class="synStatement"&gt;+&lt;/span&gt; t2)
&lt;/pre&gt;

&lt;p&gt;GHC 7.10までは、(&amp;#60;&amp;#62;) が mappend の別名であるので、以下のようなコードが書ける。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synStatement"&gt;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;1&lt;/span&gt; &lt;span class="synConstant"&gt;2&lt;/span&gt; &lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt; Metrics &lt;span class="synConstant"&gt;3&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;
Metrics {rx &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;4&lt;/span&gt;, ts &lt;span class="synStatement"&gt;=&lt;/span&gt; &lt;span class="synConstant"&gt;6&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;やったね！&lt;/p&gt;
&lt;h4&gt;GHC 8.4へようこそ&lt;/h4&gt;
&lt;p&gt;上記のコードを GHC 8.4 で読み込むと以下のようなエラーが出る。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
Example.hs&lt;span class="synStatement"&gt;:&lt;/span&gt;&lt;span class="synConstant"&gt;8&lt;/span&gt;&lt;span class="synStatement"&gt;:&lt;/span&gt;&lt;span class="synConstant"&gt;10&lt;/span&gt;&lt;span class="synStatement"&gt;:&lt;/span&gt; error&lt;span class="synStatement"&gt;:&lt;/span&gt;
    ・ No &lt;span class="synType"&gt;instance&lt;/span&gt; for (Semigroup Metrics)
        arising from the superclasses &lt;span class="synStatement"&gt;of&lt;/span&gt; an &lt;span class="synType"&gt;instance&lt;/span&gt; declaration
    ・In the &lt;span class="synType"&gt;instance&lt;/span&gt; declaration for ‘Monoid Metrics’
  &lt;span class="synStatement"&gt;|&lt;/span&gt;
&lt;span class="synConstant"&gt;8&lt;/span&gt; &lt;span class="synStatement"&gt;|&lt;/span&gt; &lt;span class="synType"&gt;instance&lt;/span&gt; Monoid Metrics &lt;span class="synType"&gt;where&lt;/span&gt;
  &lt;span class="synStatement"&gt;|&lt;/span&gt;          &lt;span class="synStatement"&gt;^^^^^^^^^^^^^^&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;これはどういうことだろう？ その疑問に答えるのがこの記事の主旨である。&lt;/p&gt;
&lt;p&gt;mappendよりも(&amp;#60;&amp;#62;)の方がかっこいいのに、長い間 (&amp;#60;&amp;#62;) はMonoidのメソッドにはしてもらえなかった。あくまで別名であった。それは一部の人に、SemigroupをMonoidのスーパークラスにするという野望があったからだ。&lt;/p&gt;
&lt;p&gt;数学での定義を思い出そう：&lt;/p&gt;
&lt;h5&gt; 半群 (Semigroup)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt; モノイド (Monoid)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;li&gt; 単位元：e &amp;#60;&amp;#62; a = a &amp;#60;&amp;#62; e = a&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt; 群 (Group)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt; 結合則: (a &amp;#60;&amp;#62; b) &amp;#60;&amp;#62; c = a &amp;#60;&amp;#62; (b &amp;#60;&amp;#62; c)&lt;/li&gt;
&lt;li&gt; 単位元：e &amp;#60;&amp;#62; a = a &amp;#60;&amp;#62; e = a&lt;/li&gt;
&lt;li&gt; 逆元：a &amp;#60;&amp;#62; inv a = e&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっきの疑問に答えると、GHC 8.4ではSemigroupがMonoidのスーパークラスとなり、Metricsに対する(&amp;#60;&amp;#62;)の定義がないために、エラーが出たという訳だ。&lt;/p&gt;
&lt;h4&gt;状況把握&lt;/h4&gt;
&lt;p&gt;今後どのようなコードを書けばよいかという疑問に答えるためには、GHCの各バージョンでの状況を把握しなければならない。&lt;/p&gt;
&lt;h5&gt;GHC 7.10 (base 4.8)&lt;/h5&gt;
&lt;p&gt;GHC 7.10 では、みなさんご存知のように base パッケージに Data.Monoid モジュールがある：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- base : Data.Monoid&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
    mappend &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend
&lt;/pre&gt;

&lt;p&gt;Monoid型自体はPreludeの仲間入りを果たしたが、(&amp;#60;&amp;#62;)は明示的にimportする必要がある。&lt;/p&gt;
&lt;p&gt;Data.Semigroupは、semigroupsパッケージで定義されている：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- semigroup : Data.Semigroup&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
    (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

&lt;span class="synType"&gt;default&lt;/span&gt; (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; Monoid a &lt;span class="synStatement"&gt;=&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
  (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend
&lt;/pre&gt;

&lt;p&gt;最後の default は、DefaultSignatures という拡張で、Monoidの制約を持てば Semigroupの方の (&amp;#60;&amp;#62;) は mappend で代用できると読む。親子関係がひっくり返っていて、なんだかなぁという感じである。&lt;/p&gt;
&lt;h5&gt;GHC 8.0 (base 4.9)&lt;/h5&gt;
&lt;p&gt;Data.Semigroupがsemigroupパッケージからbaseパッケージへ移った：&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- base : Data.Monoid&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
    mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
    mappend &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
(&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;=&lt;/span&gt; mappend

&lt;span class="synComment"&gt;--base : Data.Semigroup&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
    (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a
&lt;/pre&gt;

&lt;p&gt;親子関係はない。&lt;/p&gt;
&lt;p&gt;フラグ -Wnoncanonical-monoid-instances が定義された。これは、MonoidのインスタンスなのにSemigroupのインスタンスになってないと警告を出すフラグである。デフォルトは off。上位互換性に関するフラグ -Wcompat を付けても、警告が出る。&lt;/p&gt;
&lt;p&gt;まだ GHC 8.4 を使えない人は、-Wall の横に -Wcompat を書き足して遊んでみるとよい。&lt;/p&gt;
&lt;h5&gt; GHC 8.2 (base 4.10)&lt;/h5&gt;
&lt;p&gt;何も変更なし。嵐の前の静けさだ。&lt;/p&gt;
&lt;h5&gt; GHC 8.4 (base 4.11)&lt;/h5&gt;
&lt;p&gt;なんとなんと、MonoidとSemigroupがPreludeの仲間に入った。そして、SemigroupがMonoidのスーパークラスとなった。&lt;/p&gt;
&lt;pre class="syntax-highlight"&gt;
&lt;span class="synComment"&gt;-- Prelude&lt;/span&gt;
&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synType"&gt;where&lt;/span&gt;
  (&lt;span class="synStatement"&gt;&amp;#60;&amp;#62;&lt;/span&gt;) &lt;span class="synStatement"&gt;::&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a &lt;span class="synStatement"&gt;-&amp;#62;&lt;/span&gt; a

&lt;span class="synType"&gt;class&lt;/span&gt; Semigroup a &lt;span class="synStatement"&gt;=&amp;#62;&lt;/span&gt; Monoid a &lt;span class="synType"&gt;where&lt;/span&gt;
  mempty &lt;span class="synStatement"&gt;::&lt;/span&gt; a
&lt;/pre&gt;

&lt;p&gt;訂正：SemigroupがMonoidのスパークラスになったために、(&amp;#60;&amp;#62;) を定義してないとエラーが出るようになった。嵐がやってきたのだ。&lt;/p&gt;
&lt;h4&gt;対処方法&lt;/h4&gt;
&lt;p&gt;ここまで解説すれば、対処方法は明らかであろう。&lt;a href="https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid" target="_blank"&gt;Semigroup (as superclass of) Monoid Proposal&lt;/a&gt;の最後に、semigroupsパッケージを使う方法と使わない方法が載っているので、よく眺めてほしい。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html</id><title type="text">[haskell] http-clientライブラリを利用してHaskellでHTTPクライアント機能を実装する</title><updated>2018-03-05T09:34:57.715+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/03/haskell-http-clienthaskellhttp.html"/><summary type="text">Haskellでは、http-clientライブラリを用いることで、HTTPクライアント機能を簡単に実装できます。http-client以外にも何種類かライブラリがありますが、今回はhttp-client, http-client-tlsの機能と使い方をまとめておきます。

本エントリで紹介するhttp-client, http-client-tlsライブラリの機能：

単純なHTTP GETリクエスト

主要な型の説明 

Managerのカスタマイズ 

https
proxy設定 
タイムアウト値の設定

Requestのカスタマイズ

ベーシック認証 
リクエストヘッダ 

Responseの操作

ストリーミング受信 
レスポンスヘッダの参照 

エラーハンドリング 






単純なHTTP GETリクエスト
{-# LANGUAGE OverloadedStrings #</summary></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v6</id><title type="text">test6</title><updated>2018-03-03T13:44:46Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v6"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v5</id><title type="text">test5</title><updated>2018-03-03T12:20:13Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v5"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v4</id><title type="text">test4</title><updated>2018-03-03T05:46:33Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v4"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v3</id><title type="text">test3</title><updated>2018-03-03T05:05:52Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v3"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v2</id><title type="text">test2</title><updated>2018-03-03T04:59:34Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v2"/></entry><entry><id>https://github.com/matsubara0507/test-rss/releases/tag/v1</id><title type="text">test1</title><updated>2018-03-03T04:55:52Z</updated><author><name>matsubara0507</name></author><link href="https://github.com/matsubara0507/test-rss/releases/tag/v1"/></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180302/1519966635</id><title type="text">TLS 1.3 開発日記 その26 ID 24</title><updated>2018-03-02T04:57:15Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180302/1519966635"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;TLS 1.3 ドラフト24で重要な変更は1つだけ。レコードのバージョン。&lt;/p&gt;
&lt;p&gt;ドラフト23では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に定められた。これはこれでよい。&lt;/p&gt;
&lt;p&gt;しかし、サーバから HelloRetryRequest なる ServerHello が返され場合はどうなるだろう？ ある実装では&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello (HRR) のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となるだろう。また別の実装では、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0301 (TLS 1.0)&lt;/li&gt;
&lt;li&gt; ServerHello (HRR) のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ClientHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;li&gt; ServerHello のレコードバージョンは 0x0303 (TLS 1.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となるだろう。&lt;/p&gt;
&lt;p&gt;どちらがミドルボックスを騙せるかというと、後者である。前者はレコードのバージョンがころころ変わるから、ミドルボックスが怪しいと思って通信を遮断するかもしれない。&lt;/p&gt;
&lt;p&gt;というわけで、2回目の ClientHello のレコードバージョンは、0x0303 に定められた。なお、実装者間の合意ではドラフト 24 に対応しても、supported_versions 拡張に指定するTLSのバージョンにはドラフト 23 の値を使うことで合意が取れている。&lt;/p&gt;
&lt;p&gt;個人的には、レコードの書式にバージョンフィールドがあるのはプロトコルの設計ミスだと思う。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html</id><title type="text">[haskell] stack install cryptoniteがno such instruction: `rdrand %r8'エラーで失敗する問題の対処方法</title><updated>2018-02-25T15:34:07.378+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2018/02/haskell-stack-install-cryptoniteno-such.html"/><summary type="text">手許の環境（mac）で、cryptoniteライブラリのビルドがエラーになる問題が発生したが、ネットの情報を元に解決できたので、その症状と手順をblogに残しておく。



エラーの症状：
stack install cryptoniteで以下のようなエラーが発生。
% stack install cryptonite
--  While building custom Setup.hs for package cryptonite-0.24 using:
      /Users/xxx/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.0.1.0 build --ghc-options " </summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180214/1518587871</id><title type="text">[TLS][Haskell]TLS 1.3 開発日記 その25 picotls</title><updated>2018-02-14T05:57:51Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180214/1518587871"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;kazuho さんが実装を進めている picotls を使う方法のまとめ。picotls は TLS 1.3 のみを実装している。またデフォルトで利用できる ECDHE は P256 のみである。&lt;/p&gt;
&lt;h4&gt; インストール&lt;/h4&gt;
&lt;p&gt;cmakeが必要なので、あらかじめインストールしておく。master ブランチが draft 23。&lt;/p&gt;
&lt;pre&gt;
% git clone https://github.com/h2o/picotls
% cd picotls
% git submodule init
% git submodule update
% cmake .
% make
&lt;/pre&gt;

&lt;p&gt;これで、トップディレクトリに "cli" というコマンドができる。"cli" は、サーバにもクライアントにもなる。&lt;/p&gt;
&lt;h4&gt; picotls サーバ&lt;/h4&gt;
&lt;pre&gt;
% ./cli -k $SOMEWHERE/key.pem -c $SOMEWHERE/certificate.pem 127.0.0.1 13443
&lt;/pre&gt;

&lt;h4&gt; picotls クライアント&lt;/h4&gt;
&lt;p&gt;Full:&lt;/p&gt;
&lt;pre&gt;
% ./cli 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;HRR: &lt;/p&gt;
&lt;p&gt;最初はkey_shareを空にして送るという裏技を使う&lt;/p&gt;
&lt;pre&gt;
% ./cli -n 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;PSK:&lt;/p&gt;
&lt;p&gt;最初の -s オプションでチケットを保存し、次の -s オプションでチケットを読み込む。&lt;/p&gt;
&lt;pre&gt;
% rm ticket
% cli -s ticket 127.0.0.1 443
% cli -s ticket 127.0.0.1 443
&lt;/pre&gt;

&lt;p&gt;0RTT:&lt;/p&gt;
&lt;pre&gt;
% rm ticket
% cli -s ticket 127.0.0.1 443
% cat early-data.txt - | cli -s ticket -e 127.0.0.1 443
&lt;/pre&gt;

&lt;/div&gt;
</summary></entry><entry><id>http://d.hatena.ne.jp/kazu-yamamoto/20180116/1516075029</id><title type="text">[TLS][Haskell]TLS 1.3 開発日記 その24 ID23</title><updated>2018-01-16T03:57:09Z</updated><author><name>kazu-yamamoto</name></author><link href="http://d.hatena.ne.jp/kazu-yamamoto/20180116/1516075029"/><summary type="html">
&lt;div class="section"&gt;
&lt;p&gt;ID23での変更点：&lt;/p&gt;
&lt;h4&gt; key_share拡張&lt;/h4&gt;
&lt;p&gt;Canonのプリンターが40を使っていることが判明したので、key_share拡張の値を40から51へ変更。&lt;/p&gt;
&lt;h4&gt; signature_algorithms_cert拡張&lt;/h4&gt;
&lt;p&gt;signature_algorithmsに加えてsignature_algorithms_cert拡張を新設した。CertificateVerify用がsignature_algorithms、証明書用がsignature_algorithms_cert。signature_algorithms_certがなければsignature_algorithmsで代用する。&lt;/p&gt;
&lt;p&gt;PSSを分割した。たとえばrsa_pss_sha256は、rsaEncryption用のrsa_pss_rsae_sha256とRSASSA-PSS用のrsa_pss_pss_sha256に分かれた。&lt;/p&gt;
&lt;h4&gt; 不変条件&lt;/h4&gt;
&lt;p&gt;不変条件が加筆された：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クライアントは提案したものは必ず実装してないといけない&lt;/li&gt;
&lt;li&gt;サーバはわからないものは単に無視(異常終了してはいけない)&lt;/li&gt;
&lt;li&gt;TLSを終端するミドルボックスはその両方を満たせ&lt;/li&gt;
&lt;li&gt;単にリレーするミドルボックスは中身を触るな&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt; CSS&lt;/h4&gt;
&lt;p&gt;状態を持たないサーバは、一番目と二番目のClientHelloの間に到着するCSSを無視すること。&lt;/p&gt;
&lt;h4&gt; 静的なRSA&lt;/h4&gt;
&lt;p&gt;静的なRSAは、Bleichenbacher-type攻撃を防止するために使用不可にすべき。&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html</id><title type="text">[haskell][yesod] TypedContentを利用してクライアントが要求するフォーマットでレスポンスを返す</title><updated>2016-12-17T15:16:26.835+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/12/haskellyesod-typedcontent.html"/><summary type="text">Yesod Advent Calendar 2016の6日目の記事です。

RESTfulなAPIを提供する場合、クライアントの都合にあわせて、フォーマットを変えてレスポンスを返したいケースがあります。サーバー上で管理しているDBから、表現だけをHTML, JSON, XML, CSVなどに変更して返すイメージです。例えば、人物情報（名前、年齢、性別など）の一覧を返す際には以下のようなデータが返されることになります。

HTML
&lt;table border&gt;
  &lt;tr&gt;
    &lt;th&gt;name&lt;/th&gt;    &lt;th&gt;sex&lt;/th&gt;    &lt;th&gt;age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Taro Yamada&lt;/td&gt;    &lt;td&gt;Male&lt;/td&gt;    &lt;td&gt;18&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Hanako Yamada&lt;/</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html</id><title type="text">[haskell][yesod] stackのnewコマンドで指定できるyesod関連templateの説明</title><updated>2016-12-03T23:37:28.283+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/yesodhaskell-stack-new-xxx-project.html"/><summary type="text">現状、stackで指定できるyesod関連のtemplatesには以下のものがあります。どのtemplateに何が用意されているのか、知りたかったのですがどこにも説明されていないようなので、調べてまとめてみました。
% stack templates | grep yesod
yesod-hello-world （←現時点では削除されています）
yesod-minimal
yesod-mongo
yesod-mysql
yesod-postgres
yesod-postgres-fay
yesod-simple
yesod-sqlite


以下、各テンプレートの説明です。後に出てくるテンプレートほど内容が複雑になっています。テンプレートを指定して新しいプロジェクトを生成する場合は以下のコマンドを実行します。
% stack new プロジェクト名 yesod-???




</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html</id><title type="text">[emacs] emacs上のgrep関連機能、複数ファイルの一括置換手順のまとめ</title><updated>2016-11-30T10:03:25.873+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/11/emacs-emacsgrep.html"/><summary type="text">emacs上でgrep関連の機能を利用する際のTIPSをまとめておきます（よく忘れて調べ直すので…）。


grepコマンドのオプション

指定ディレクトリ以下のファイルを再帰的に検索

-R DIR    シンボリックリンクを辿る
-r  DIR    シンボリックリンクは辿らない

検索対象をファイル名でフィルタする

--include=GLOB    GLOBにファイル名を指定する。"*.cpp"のようにワイルドカード（*,?,[...]）を指定可能

検索対象から指定ファイル・ディレクトリを除外する

--exclude=GLOB   GLOBに除外するファイルのファイル名を指定する（ワイルドカード指定可能）。
--exclude-dir=DIR DIRに指定されたディレクトリをスキップ


使用例：

docディレクトリ以下の.txtを拡張子に持つ全てのファイルを対象に"</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html</id><title type="text">[cygwin] cygwin64セットアップメモ</title><updated>2016-11-28T00:47:36.358+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/09/cygwin-cygwin64.html"/><summary type="text">自分向け備忘録。cygwin64環境をセットアップする際の手順をまとめておきます。


設定


ssh-agent関連

ssh-agentの重複起動を防ぐ
ssh-agentのために秘密鍵セットアップ

~/.ssh/

※group/otherのrw権限は削除


ssh-agentがパスワードを覚えてくれなくなった問題への対処

pingのエラー回避
ユーザーのアカウント名、ホームディレクトリの変更

/etc/passwdを編集する

GNU screen でlessやvimの終了後に画面クリアをしない方法
改行コードにCR+LFが用いられているbashスクリプトを実行するための設定
tcshのデフォルト補完設定のイマイチな部分を修正




環境変数

HOME

ホームディレクトリを設定



SHELL

"/bin/tcsh"とすることでデフォルトのシェルが切り替わる
</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html</id><title type="text">[haskell][yesod] YesodにおけるRESTfulなJSON API実装チュートリアル</title><updated>2016-08-28T17:53:43.356+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/08/haskellyesod-yesodrestfuljson-api.html"/><summary type="text">HaskellのwebフレームワークであるYesodにおいて、RESTful APIを実装する手順を紹介します。Haskell上のデータ構造をJSONテキストに変換する、逆に、JSONテキストをパースしてHaskell上のデータ構造を生成する、といった処理が非常に簡単に実現できます。加えて、コードを書かなくてもバックエンドのDBとのORマッピングが可能になっており、効率的に開発することができます。
ここで紹介しているコードはgithubにコミットしています。


準備：

json-sampleというプロジェクト名でYesodのscaffolding siteをセットアップする

空のプロジェクト生成

% stack new json-sample yesod-sqlite --system-ghc

"--system-ghc"は省略可能。インストール済みのghcを使うことを指示し</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html</id><title type="text">[haskell][yesod] stack対応版Yesod tutorial</title><updated>2016-07-17T18:06:36.108+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/haskellyesod-stackyesod-tutorial.html"/><summary type="text">HaskellのwebサービスフレームワークにYesodというフレームワークがあります。Yesodに触れたことのない開発者向けに書かれたチュートリアルの一つにYesod tutorialがあり、手順に沿っていくだけで簡単なwebサービスを動作させることができ、Yesodで何ができるかを簡単に理解できるようになっています。
ただ残念なことに、このYesod tutorialの記載は内容が古く、stackを利用した現行の手順とマッチしなくなっています。stackに対応している最新環境（Yesod 1.4.x）における順があると役に立つと思い、書き起こしてみました。


Before the real start（はじめに）

Install（インストール手順）
stackをインストールする。以下のサイトが参考になります。

installation instructions for </summary></entry><entry><id>http://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html</id><title type="text">[haskell][yesod] stack exec -- yesod devel で devel.hs: getAddrInfo: does not existというエラーになる問題の対処方法</title><updated>2016-07-17T17:39:43.279+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/07/haskellyesod-stack-exec-yesod-devel.html"/><summary type="text">
Widnwos環境での現象：
windows上でyesodのscafolding siteをセットアップし、さあ起動！ブラウザから接続確認してOKとなるはずが、なぜか「The application isn't built」という表示が出てしまいました。



このときターミナルには以下のようなログが出力されていました。
% stack exec -- yesod devel
Yesod devel server. Type 'quit' to quit
Application can be accessed at:

http://localhost:3000
https://localhost:3443
If you wish to test https capabilities, you should set the following variable:
  export </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html</id><title type="text">[haskell] cmdargsパッケージで楽々コマンドライン引数パース</title><updated>2016-02-11T01:10:46.307+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/04/haskell-cmdargs.html"/><summary type="text">コマンドラインツール実装時、オプション指定とか引数の並びとか考え始めると大変です。HaskellではSystem.EnvironmentモジュールからgetArgsという関数が提供されていますが、本エントリで紹介するcmdargsパッケージを利用すると以下のようなことが簡単にできます。

cmdargsパッケージの特徴：

データ構造を定義するだけで起動引数・オプションのパースができる
パース結果を型付きで参照することができる
パース失敗時には、原因がわかるエラーメッセージが表示される
--help, --versionオプションで表示される情報を自動で生成してくれる

Haskell版GNU getoptライブラリと比べて以下の2点が優れている、とHPには書かれています。

HLintコマンドラインのハンドリングが1/3の短さ
Cabal, darcsなどのmultiple mode</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージ利用時にテーブルにインデックスを生成する方法</title><updated>2016-01-30T17:12:12.076+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/haskellyesodsqlite-persistent.html"/><summary type="text">PersistentパッケージにはMigration機能が備わっており、自動的にテーブルを生成してくれます。スキーマ変更を行った際にも、変換が可能な限りテーブル内のレコードを保持したまま新しいスキーマに変換してくれます（Migration機能については過去のエントリでまとめています）。

自分が利用する上で、インデックスやトリガーを生成する手順が紹介されておらず困っていたのですが、rawExecuteという関数を用いることで自由にDDLを発行できることがわかりました。以下その手順とサンプルを紹介しておきます。


サンプルコード：
以下は、personテーブルのnameカラムにインデックスをs生成するサンプルです。runMigration実行直後に、runExecuteを実行することでインデックスを生成しています。このサンプルではインデックスを生成しているだけですが、同じ手順でトリガーの</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html</id><title type="text">[haskell][persistent][sqlite] Persistentパッケージのmigration機能のまとめ</title><updated>2016-01-30T17:11:40.032+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/08/haskellyesodsqlite-persistentmigration.html"/><summary type="text">HaskellでDB操作ができるPersistentパッケージの紹介をしましたが、このエントリではPersistentパッケージが提供しているmigration機能をまとめておきます。
DBを作って運用していると、機能追加や仕様変更に伴いスキーマ変更が必要になるケースが多々あります。このようなケースにおいてPersistentのmigration機能がどれくらい使えるのかを調べた結果です。


基本：
Persistetのmigration機構は（保守的なルールに沿って）スキーマ変更をある程度まで自動で処理してくれます。
ロードしたDB内のテーブル情報と、コードで定義されたEntity Definition（テーブル定義）を比較し、以下のケースにおいてスキーマの変更を行います。

カラムの型を変更した場合：

ただし、値の変換ができない場合には、DBによって拒否されることになります。

</summary></entry><entry><id>http://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html</id><title type="text">[haskell][gcc][win] Windows版Haskell Platform付属のgccでC++11のコードをコンパイルする方法</title><updated>2016-01-15T00:45:37.692+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2016/01/haskellgccwin-windowshaskell.html"/><summary type="text">Windows版のHaskell Platformにはmingwが同梱されておりgccが含まれています。現在自分のPCにはHaskell Platform 2014.2.0.0をインストールしているのですが、これに付属されているgccでC++11のコードをコンパイルしようとすると、以下のようなエラーになってしまいました。
% gcc -std=c++11 cpp11.cpp
cc1plus.exe: error: unrecognized command line option '-std=c++11'


-stdオプションで"c++11"を指定しても、認識してくれません。
本家のサイトによると、'-std=c++11'オプションはgcc 4.7でサポートされたようです。これに対し、Haskell Platform 2014.2.0.0に付属されているgccのバージョンを確認したところ</summary></entry><entry><id>http://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html</id><title type="text">[sqlite] SQLiteのロック・トランザクション関連仕様の整理</title><updated>2016-01-06T12:11:40.986+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2013/11/sqlite-sqlite.html"/><summary type="text">SQLiteは共有ロック・排他ロックの仕組みを備えており、プロセス内の複数スレッド、だけでなく、プロセスをまたぐ状態でSQLが同時に発行されても適切に処理されます。
トランザクションに複数のモードが存在し、指定するモードに依って取得されるロックが変わります。さらにSQLの内容に依存してロック状態が遷移するため、複数プロセスがアクセスしたときの挙動を正確に把握できるよう、仕様を整理してみました。
（文中の「プロセス」は、正確には「プロセス、もしくはスレッド」を意味します。）


DBのロック状態の種類：

UNLOCKED

ロックされていない状態。誰も読み書きしていない。DBの初期状態。

SHARED

read可、write不可な状態。複数プロセスが同時にSHAREDロックを取得可能。複数プロセスが同時にreadできることを意味する。DBがこの状態にあるとき、他のプロセスからの</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html</id><title type="text">[cygwin][haskell][emacs] MinGWでcygwinの"/cygdrive"パスにアクセスする裏技（cygwin環境のemacsでflycheckを動作させる方法）</title><updated>2015-12-27T23:55:24.842+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/07/cygwinhaskellemacs-mingwcygwincygdrivec.html"/><summary type="text">haskell関連のコマンドはMinGW上でビルドされているため、cygwin環境の"/cygdrive"から始まるパスには対応していません。haskell-hlintから呼び出されるhlintも当然この問題の影響を受けておりemacs関連の設定が適切にされていたとしても、以下のようなエラーが表示されてしまいます。



ミニバッファに表示されるエラー詳細：
Suspicious state from syntax checker haskell-hlint: Checker haskell-hlint returned non-zero exit code 1, but no errors from output: hlint.exe: Couldn't find file: /cygdrive/c/Users/Hiroyuki/tmp/flycheck_hello.hs



</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html</id><title type="text">[haskell][stack] stack exec ghciで”Couldn't match expected type"エラーが発生する問題の対処</title><updated>2015-11-08T15:09:21.187+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/haskellstack-stack-exec-ghcicouldnt.html"/><summary type="text">先日、haskellのパッケージ管理をcabalからstackに移行して「便利〜！」と感動していたところなのですが、stach exec ghciでソースをロードしようとすると"Couldn't match expected type: xxxxx"とエラーが発生する問題に遭遇しました。
ネットの情報を参考に解決することができたのでその手順をまとめておきます。


問題：
stack buildは成功するにもかかわらず、stack exec ghci xxx.hs（xxx.hsはbuild対象のファイル）がエラーになる。
stack exec ghci実行時のエラーログ：
% stack exec ghci FileToVec.hs
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
[1 of 1] </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html</id><title type="text">[cygwin] cygwinのシェル起動時にPATHの先頭に/usr/binと/usr/local/binが勝手に追加されないようにする</title><updated>2015-11-04T22:29:43.126+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/11/cygwin-cygwinpathusrbinusrlocalbin.html"/><summary type="text">cygwinのデフォルトの設定では、シェル起動時に以下の2つのディレクトリが自動的にPATHの先頭に追加されます。

/usr/local/bin
/usr/bin


cygwinでインストールされているコマンドと同名の別コマンドを優先して起動したい場合には、この設定が邪魔になります。
これを無効にするには以下の方法があります。お好みでどちらかを選択してください。

/etc/profileもしくは/etc/csh.loginの該当処理をコメントアウトする（bash / tcsh）

cygwinがPATHを上書きしているのは、/etc/profile（bashの場合）と/etc/csh.login（tcshの場合）です。これらのスクリプトを編集することで、/usr/binと/usr/local/binが勝手に追加されないようにできます。

ORIGINAL_PATHでPATHを上書き</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html</id><title type="text">[ssh] OpenSSHのアップデートでssh-agentがパスワードを覚えてくれなくなった問題への対処</title><updated>2015-09-06T00:44:24.703+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/09/ssh-opensshssh-agent.html"/><summary type="text">ssh-agent/ssh-addを利用してsshを用いたサーバーへのログイン時のパスワード入力を省略している方、OpenSSHのアップデートにより、毎回パスワード入力を求められるようになった場合は以下の設定を疑ってみてください。


問題の症状：
OpenSSHパッケージを最新版にアップデートすると発生するようになった問題です。ssh-agentを起動してssh-addで鍵を正しく登録しているにも関わらず、sshコマンドを実行する度に"password:"というプロンプトが表示されてパスワードの入力を求められてしまいます。


環境：
問題に遭遇＆解決した私のcygwin環境では以下のバージョンで問題が発生することを確認しました。

OpenSSH_7.0p1, OpenSSL 1.0.2d 9 Jul 2015
OpenSSH_7.1p1, OpenSSL 1.0.2d 9 Jul </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html</id><title type="text">[cygwin] cygwin版X server（XWin）にリモートクライアントから接続できない問題の対処方法</title><updated>2015-09-02T23:09:07.989+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/09/cygwin-cygwinx-serverxwin.html"/><summary type="text">cygwinを最新バージョンにアップデートしたところ、リモートのX clientからwindows上のcygwin版X serverに接続できなくなってしまいました。
対処方法は簡単でXWin起動時に"-listen tcp"オプションを付けてあげればよいだけです。cygwinバージョンアップ前にはオプション指定なしで接続できていたため、デフォルトの設定が変わったのだと思われます。


cygwin環境：
uname -aで表示されるcygwinバージョン情報です。

% uname -a
CYGWIN_NT-6.1 xxx 2.2.1(0.289/5/3) 2015-08-20 11:42 x86_64 Cygwin



問題発生時の症状：
クライアント側で起動したxtermをサーバー側で表示しようとすると、以下のようなエラーになっていました。
% xterm
xterm Xt </summary></entry><entry><id>http://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html</id><title type="text">[cygwin][emacs] cygwin版emacsでgtagsを使えるようにする方法</title><updated>2015-08-17T00:49:02.649+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/08/cygwinemacs-cygwinemacsgtags.html"/><summary type="text">これまでタグジャンプにはctagsを用いていたのですが、gtagsの「呼び出し元も一覧できる」という機能に惹かれてセットアップしてみました。いくつかはまりポイントがあったのでその対応方法も含め、手順を残しておきます。
cgwin提供のパッケージにはgtagsは含まれていなかったため、自前でビルドすることにしました。


目次：

gatgsの特徴
gtagsのインストール手順
emacsの設定
gtagsの使い方




gtagsの特徴：

良い点！

関数の呼び出し元を一覧表示しジャンプできる（gtags-find-rtag）
関数だけでなく、ローカル変数を含む任意のシンボルをタグジャンプできる（gtags-find-symbol）

正規表現で一覧絞り込み可能（gtags-find-pattern）
開いているファイルで絞り込み可能（gtags-parsefiile）

特定文字列</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/06/subversion.html</id><title type="text">[subversion] 特定ディレクトリ以下をサーバーとの同期対象から除外する方法</title><updated>2015-06-26T13:55:24.651+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/06/subversion.html"/><summary type="text">subversionでチェックアウトした作業コピー内の特定ディレクトリ以下をサーバーとの同期対象から除外したい、ということを考えたことはないでしょうか。
例えば、リポジトリの特定ディレクトリ以下に自分にとって不要なファイルやアーカイブが多数コミットされていると、以下のような無駄が生じます。これらの無駄をなくしたい、というのが主なユースケースです。

不要なファイル・アーカイブによってディスクスペースが占有される
サーバー上に更新が発生した際にupdateに余計な時間がかかってしまう



単純に特定ディレクトリ以下の作業ファイルを削除してしまうと、コミット時に差分として検知されてしまう、また、次回以降のupdateコマンドで再ダウンロードされてしまう、という非常に残念な挙動になります。

このようなケースでは以下の方法を使えば、差分が検知されない状態で所定ディレクトリ以下のファイルを削除</summary></entry><entry><id>http://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html</id><title type="text">[windows][haskell] Widnwos環境でHaskell Platformを完全削除する方法</title><updated>2015-04-05T01:53:40.022+09:00</updated><author><name>Hiroyuki Kurokawa</name></author><link href="http://kurokawh.blogspot.com/2015/04/windowshaskell-widnwoshaskell-platform.html"/><summary type="text">Windows上でHaskell Platformを完全削除する方法です。
LinuxやMac環境についてはネット上に多数情報がありますが、Windows環境についてはそれが見当たらなかったため、本エントリにまとめておきます。確認した環境はWindows 8.1＋Haslell Platform 2014.2.0.0です。


削除手順：
Windows環境では以下の手順でHaskell Platformを完全に削除できます。

Haskell Platformのアンインストール

[コントロールパネル] - [プログラム] - [プログラムと機能]を開く
"Haslell Platform 2014.2.0.0"を選択して[アンインストール]を実行

ユーザー領域に作成されたパッケージ関連ファイルの削除

手動（エクスプローラ、rmコマンドなど）で次の２つのディレクトリ以下を完全に削除</summary></entry></feed>